var JsonRefs =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Jeremy Whitlock
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


var _ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");

var gl = __webpack_require__(/*! graphlib */ "./node_modules/graphlib/index.js");

var path = __webpack_require__(/*! path */ "./node_modules/webpack/node_modules/path-browserify/index.js");

var PathLoader = __webpack_require__(/*! path-loader */ "./node_modules/path-loader/index.js");

var qs = __webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js");

var slash = __webpack_require__(/*! slash */ "./node_modules/slash/index.js");

var URI = __webpack_require__(/*! uri-js */ "./node_modules/uri-js/dist/es5/uri.all.js");

var badPtrTokenRegex = /~(?:[^01]|$)/g;
var remoteCache = {};
var remoteTypes = ['relative', 'remote'];
var remoteUriTypes = ['absolute', 'uri'];
var uriDetailsCache = {}; // Load promises polyfill if necessary

/* istanbul ignore if */

if (typeof Promise === 'undefined') {
  __webpack_require__(/*! native-promise-only */ "./node_modules/native-promise-only/lib/npo.src.js");
}
/* Internal Functions */


function combineQueryParams(qs1, qs2) {
  var combined = {};

  function mergeQueryParams(obj) {
    _.forOwn(obj, function (val, key) {
      combined[key] = val;
    });
  }

  mergeQueryParams(qs.parse(qs1 || ''));
  mergeQueryParams(qs.parse(qs2 || ''));
  return Object.keys(combined).length === 0 ? undefined : qs.stringify(combined);
}

function combineURIs(u1, u2) {
  // Convert Windows paths
  if (_.isString(u1)) {
    u1 = slash(u1);
  }

  if (_.isString(u2)) {
    u2 = slash(u2);
  }

  var u2Details = parseURI(_.isUndefined(u2) ? '' : u2);
  var u1Details;
  var combinedDetails;

  if (remoteUriTypes.indexOf(u2Details.reference) > -1) {
    combinedDetails = u2Details;
  } else {
    u1Details = _.isUndefined(u1) ? undefined : parseURI(u1);

    if (!_.isUndefined(u1Details)) {
      combinedDetails = u1Details; // Join the paths

      combinedDetails.path = slash(path.join(u1Details.path, u2Details.path)); // Join query parameters

      combinedDetails.query = combineQueryParams(u1Details.query, u2Details.query);
    } else {
      combinedDetails = u2Details;
    }
  } // Remove the fragment


  combinedDetails.fragment = undefined; // For relative URIs, add back the '..' since it was removed above

  return (remoteUriTypes.indexOf(combinedDetails.reference) === -1 && combinedDetails.path.indexOf('../') === 0 ? '../' : '') + URI.serialize(combinedDetails);
}

function findAncestors(obj, path) {
  var ancestors = [];
  var node;

  if (path.length > 0) {
    node = obj;
    path.slice(0, path.length - 1).forEach(function (seg) {
      if (seg in node) {
        node = node[seg];
        ancestors.push(node);
      }
    });
  }

  return ancestors;
}

function isRemote(refDetails) {
  return remoteTypes.indexOf(getRefType(refDetails)) > -1;
}

function isValid(refDetails) {
  return _.isUndefined(refDetails.error) && refDetails.type !== 'invalid';
}

function findValue(obj, path) {
  var value = obj; // Using this manual approach instead of _.get since we have to decodeURI the segments

  path.forEach(function (seg) {
    if (seg in value) {
      value = value[seg];
    } else {
      throw Error('JSON Pointer points to missing location: ' + pathToPtr(path));
    }
  });
  return value;
}

function getExtraRefKeys(ref) {
  return Object.keys(ref).filter(function (key) {
    return key !== '$ref';
  });
}

function getRefType(refDetails) {
  var type; // Convert the URI reference to one of our types

  switch (refDetails.uriDetails.reference) {
    case 'absolute':
    case 'uri':
      type = 'remote';
      break;

    case 'same-document':
      type = 'local';
      break;

    default:
      type = refDetails.uriDetails.reference;
  }

  return type;
}

function getRemoteDocument(url, options) {
  var cacheEntry = remoteCache[url];
  var allTasks = Promise.resolve();

  var loaderOptions = _.cloneDeep(options.loaderOptions || {});

  if (_.isUndefined(cacheEntry)) {
    // If there is no content processor, default to processing the raw response as JSON
    if (_.isUndefined(loaderOptions.processContent)) {
      loaderOptions.processContent = function (res, callback) {
        callback(undefined, JSON.parse(res.text));
      };
    } // Attempt to load the resource using path-loader


    allTasks = PathLoader.load(decodeURI(url), loaderOptions); // Update the cache

    allTasks = allTasks.then(function (res) {
      remoteCache[url] = {
        value: res
      };
      return res;
    })["catch"](function (err) {
      remoteCache[url] = {
        error: err
      };
      throw err;
    });
  } else {
    // Return the cached version
    allTasks = allTasks.then(function () {
      if (_.isError(cacheEntry.error)) {
        throw cacheEntry.error;
      } else {
        return cacheEntry.value;
      }
    });
  } // Return a cloned version to avoid updating the cache


  allTasks = allTasks.then(function (res) {
    return _.cloneDeep(res);
  });
  return allTasks;
}

function isRefLike(obj, throwWithDetails) {
  var refLike = true;

  try {
    if (!_.isPlainObject(obj)) {
      throw new Error('obj is not an Object');
    } else if (!_.isString(obj.$ref)) {
      throw new Error('obj.$ref is not a String');
    }
  } catch (err) {
    if (throwWithDetails) {
      throw err;
    }

    refLike = false;
  }

  return refLike;
}

function makeAbsolute(location) {
  if (location.indexOf('://') === -1 && !path.isAbsolute(location)) {
    return path.resolve(process.cwd(), location);
  } else {
    return location;
  }
}

function makeRefFilter(options) {
  var refFilter;
  var validTypes;

  if (_.isArray(options.filter) || _.isString(options.filter)) {
    validTypes = _.isString(options.filter) ? [options.filter] : options.filter;

    refFilter = function refFilter(refDetails) {
      // Check the exact type or for invalid URIs, check its original type
      return validTypes.indexOf(refDetails.type) > -1 || validTypes.indexOf(getRefType(refDetails)) > -1;
    };
  } else if (_.isFunction(options.filter)) {
    refFilter = options.filter;
  } else if (_.isUndefined(options.filter)) {
    refFilter = function refFilter() {
      return true;
    };
  }

  return function (refDetails, path) {
    return (refDetails.type !== 'invalid' || options.includeInvalid === true) && refFilter(refDetails, path);
  };
}

function makeSubDocPath(options) {
  var subDocPath;

  if (_.isArray(options.subDocPath)) {
    subDocPath = options.subDocPath;
  } else if (_.isString(options.subDocPath)) {
    subDocPath = pathFromPtr(options.subDocPath);
  } else if (_.isUndefined(options.subDocPath)) {
    subDocPath = [];
  }

  return subDocPath;
}

function markMissing(refDetails, err) {
  refDetails.error = err.message;
  refDetails.missing = true;
}

function parseURI(uri) {
  // We decode first to avoid doubly encoding
  return URI.parse(uri);
}

function buildRefModel(document, options, metadata) {
  var allTasks = Promise.resolve();
  var subDocPtr = pathToPtr(options.subDocPath);
  var absLocation = makeAbsolute(options.location);
  var relativeBase = path.dirname(options.location);
  var docDepKey = absLocation + subDocPtr;
  var refs;
  var rOptions; // Store the document in the metadata if necessary

  if (_.isUndefined(metadata.docs[absLocation])) {
    metadata.docs[absLocation] = document;
  } // If there are no dependencies stored for the location+subDocPath, we've never seen it before and will process it


  if (_.isUndefined(metadata.deps[docDepKey])) {
    metadata.deps[docDepKey] = {}; // Find the references based on the options

    refs = findRefs(document, options); // Iterate over the references and process

    _.forOwn(refs, function (refDetails, refPtr) {
      var refKey = makeAbsolute(options.location) + refPtr;
      var refdKey = refDetails.refdId = decodeURI(makeAbsolute(isRemote(refDetails) ? combineURIs(relativeBase, refDetails.uri) : options.location) + '#' + (refDetails.uri.indexOf('#') > -1 ? refDetails.uri.split('#')[1] : '')); // Record reference metadata

      metadata.refs[refKey] = refDetails; // Do not process invalid references

      if (!isValid(refDetails)) {
        return;
      } // Record the fully-qualified URI


      refDetails.fqURI = refdKey; // Record dependency (relative to the document's sub-document path)

      metadata.deps[docDepKey][refPtr === subDocPtr ? '#' : refPtr.replace(subDocPtr + '/', '#/')] = refdKey; // Do not process directly-circular references (to an ancestor or self)

      if (refKey.indexOf(refdKey + '/') === 0 || refKey === refdKey) {
        refDetails.circular = true;
        return;
      } // Prepare the options for subsequent processDocument calls


      rOptions = _.cloneDeep(options);
      rOptions.subDocPath = _.isUndefined(refDetails.uriDetails.fragment) ? [] : pathFromPtr(decodeURI(refDetails.uriDetails.fragment)); // Resolve the reference

      if (isRemote(refDetails)) {
        // Delete filter.options because all remote references should be fully resolved
        delete rOptions.filter; // The new location being referenced

        rOptions.location = refdKey.split('#')[0];
        allTasks = allTasks.then(function (nMetadata, nOptions) {
          return function () {
            var rAbsLocation = makeAbsolute(nOptions.location);
            var rDoc = nMetadata.docs[rAbsLocation];

            if (_.isUndefined(rDoc)) {
              // We have no cache so we must retrieve the document
              return getRemoteDocument(rAbsLocation, nOptions)["catch"](function (err) {
                // Store the response in the document cache
                nMetadata.docs[rAbsLocation] = err; // Return the error to allow the subsequent `then` to handle both errors and successes

                return err;
              });
            } else {
              // We have already retrieved (or attempted to) the document and should use the cached version in the
              // metadata since it could already be processed some.
              return Promise.resolve().then(function () {
                return rDoc;
              });
            }
          };
        }(metadata, rOptions));
      } else {
        allTasks = allTasks.then(function () {
          return document;
        });
      } // Process the remote document or the referenced portion of the local document


      allTasks = allTasks.then(function (nMetadata, nOptions, nRefDetails) {
        return function (doc) {
          if (_.isError(doc)) {
            markMissing(nRefDetails, doc);
          } else {
            // Wrapped in a try/catch since findRefs throws
            try {
              return buildRefModel(doc, nOptions, nMetadata)["catch"](function (err) {
                markMissing(nRefDetails, err);
              });
            } catch (err) {
              markMissing(nRefDetails, err);
            }
          }
        };
      }(metadata, rOptions, refDetails));
    });
  }

  return allTasks;
}

function setValue(obj, refPath, value) {
  findValue(obj, refPath.slice(0, refPath.length - 1))[refPath[refPath.length - 1]] = value;
}

function walk(ancestors, node, path, fn) {
  var processChildren = true;

  function walkItem(item, segment) {
    path.push(segment);
    walk(ancestors, item, path, fn);
    path.pop();
  } // Call the iteratee


  if (_.isFunction(fn)) {
    processChildren = fn(ancestors, node, path);
  } // We do not process circular objects again


  if (ancestors.indexOf(node) === -1) {
    ancestors.push(node);

    if (processChildren !== false) {
      if (_.isArray(node)) {
        node.forEach(function (member, index) {
          walkItem(member, index.toString());
        });
      } else if (_.isObject(node)) {
        _.forOwn(node, function (cNode, key) {
          walkItem(cNode, key);
        });
      }
    }

    ancestors.pop();
  }
}

function validateOptions(options, obj) {
  var locationParts;
  var shouldDecode;

  if (_.isUndefined(options)) {
    // Default to an empty options object
    options = {};
  } else {
    // Clone the options so we do not alter the ones passed in
    options = _.cloneDeep(options);
  }

  if (!_.isObject(options)) {
    throw new TypeError('options must be an Object');
  } else if (!_.isUndefined(options.resolveCirculars) && !_.isBoolean(options.resolveCirculars)) {
    throw new TypeError('options.resolveCirculars must be a Boolean');
  } else if (!_.isUndefined(options.filter) && !_.isArray(options.filter) && !_.isFunction(options.filter) && !_.isString(options.filter)) {
    throw new TypeError('options.filter must be an Array, a Function of a String');
  } else if (!_.isUndefined(options.includeInvalid) && !_.isBoolean(options.includeInvalid)) {
    throw new TypeError('options.includeInvalid must be a Boolean');
  } else if (!_.isUndefined(options.location) && !_.isString(options.location)) {
    throw new TypeError('options.location must be a String');
  } else if (!_.isUndefined(options.refPreProcessor) && !_.isFunction(options.refPreProcessor)) {
    throw new TypeError('options.refPreProcessor must be a Function');
  } else if (!_.isUndefined(options.refPostProcessor) && !_.isFunction(options.refPostProcessor)) {
    throw new TypeError('options.refPostProcessor must be a Function');
  } else if (!_.isUndefined(options.subDocPath) && !_.isArray(options.subDocPath) && !isPtr(options.subDocPath)) {
    // If a pointer is provided, throw an error if it's not the proper type
    throw new TypeError('options.subDocPath must be an Array of path segments or a valid JSON Pointer');
  } // Default to false for allowing circulars


  if (_.isUndefined(options.resolveCirculars)) {
    options.resolveCirculars = false;
  }

  options.filter = makeRefFilter(options); // options.location is not officially supported yet but will be when Issue 88 is complete

  if (_.isUndefined(options.location)) {
    options.location = makeAbsolute('./root.json');
  }

  locationParts = options.location.split('#'); // If options.location contains a fragment, turn it into an options.subDocPath

  if (locationParts.length > 1) {
    options.subDocPath = '#' + locationParts[1];
  }

  shouldDecode = decodeURI(options.location) === options.location; // Just to be safe, remove any accidental fragment as it would break things

  options.location = combineURIs(options.location, undefined); // If the location was not encoded, meke sure it's not when we get it back (Issue #138)

  if (shouldDecode) {
    options.location = decodeURI(options.location);
  } // Set the subDocPath to avoid everyone else having to compute it


  options.subDocPath = makeSubDocPath(options);

  if (!_.isUndefined(obj)) {
    try {
      findValue(obj, options.subDocPath);
    } catch (err) {
      err.message = err.message.replace('JSON Pointer', 'options.subDocPath');
      throw err;
    }
  }

  return options;
}

function decodePath(path) {
  if (!_.isArray(path)) {
    throw new TypeError('path must be an array');
  }

  return path.map(function (seg) {
    if (!_.isString(seg)) {
      seg = JSON.stringify(seg);
    }

    return seg.replace(/~1/g, '/').replace(/~0/g, '~');
  });
}

function encodePath(path) {
  if (!_.isArray(path)) {
    throw new TypeError('path must be an array');
  }

  return path.map(function (seg) {
    if (!_.isString(seg)) {
      seg = JSON.stringify(seg);
    }

    return seg.replace(/~/g, '~0').replace(/\//g, '~1');
  });
}

function findRefs(obj, options) {
  var refs = {}; // Validate the provided document

  if (!_.isArray(obj) && !_.isObject(obj)) {
    throw new TypeError('obj must be an Array or an Object');
  } // Validate options


  options = validateOptions(options, obj); // Walk the document (or sub document) and find all JSON References

  walk(findAncestors(obj, options.subDocPath), findValue(obj, options.subDocPath), _.cloneDeep(options.subDocPath), function (ancestors, node, path) {
    var processChildren = true;
    var refDetails;
    var refPtr;

    if (isRefLike(node)) {
      // Pre-process the node when necessary
      if (!_.isUndefined(options.refPreProcessor)) {
        node = options.refPreProcessor(_.cloneDeep(node), path);
      }

      refDetails = getRefDetails(node); // Post-process the reference details

      if (!_.isUndefined(options.refPostProcessor)) {
        refDetails = options.refPostProcessor(refDetails, path);
      }

      if (options.filter(refDetails, path)) {
        refPtr = pathToPtr(path);
        refs[refPtr] = refDetails;
      } // Whenever a JSON Reference has extra children, its children should not be processed.
      //   See: http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03#section-3


      if (getExtraRefKeys(node).length > 0) {
        processChildren = false;
      }
    }

    return processChildren;
  });
  return refs;
}

function findRefsAt(location, options) {
  var allTasks = Promise.resolve();
  allTasks = allTasks.then(function () {
    // Validate the provided location
    if (!_.isString(location)) {
      throw new TypeError('location must be a string');
    }

    if (_.isUndefined(options)) {
      options = {};
    }

    if (_.isObject(options)) {
      // Add the location to the options for processing/validation
      options.location = location;
    } // Validate options


    options = validateOptions(options);
    return getRemoteDocument(options.location, options);
  }).then(function (res) {
    var cacheEntry = _.cloneDeep(remoteCache[options.location]);

    var cOptions = _.cloneDeep(options);

    if (_.isUndefined(cacheEntry.refs)) {
      // Do not filter any references so the cache is complete
      delete cOptions.filter;
      delete cOptions.subDocPath;
      cOptions.includeInvalid = true;
      remoteCache[options.location].refs = findRefs(res, cOptions);
    } // Add the filter options back


    if (!_.isUndefined(options.filter)) {
      cOptions.filter = options.filter;
    } // This will use the cache so don't worry about calling it twice


    return {
      refs: findRefs(res, cOptions),
      value: res
    };
  });
  return allTasks;
}

function getRefDetails(obj) {
  var details = {
    def: _.cloneDeep(obj)
  };
  var cacheKey;
  var extraKeys;
  var uriDetails;

  try {
    // This will throw so the result doesn't matter
    isRefLike(obj, true);
    cacheKey = obj.$ref;
    uriDetails = uriDetailsCache[cacheKey];

    if (_.isUndefined(uriDetails)) {
      uriDetails = uriDetailsCache[cacheKey] = parseURI(cacheKey);
    }

    details.uri = cacheKey;
    details.uriDetails = uriDetails;

    if (_.isUndefined(uriDetails.error)) {
      details.type = getRefType(details); // Validate the JSON Pointer

      try {
        if (['#', '/'].indexOf(cacheKey[0]) > -1) {
          isPtr(cacheKey, true);
        } else if (cacheKey.indexOf('#') > -1) {
          isPtr(uriDetails.fragment, true);
        }
      } catch (err) {
        details.error = err.message;
        details.type = 'invalid';
      }
    } else {
      details.error = details.uriDetails.error;
      details.type = 'invalid';
    } // Identify warning


    extraKeys = getExtraRefKeys(obj);

    if (extraKeys.length > 0) {
      details.warning = 'Extra JSON Reference properties will be ignored: ' + extraKeys.join(', ');
    }
  } catch (err) {
    details.error = err.message;
    details.type = 'invalid';
  }

  return details;
}

function isPtr(ptr, throwWithDetails) {
  var valid = true;
  var firstChar;

  try {
    if (_.isString(ptr)) {
      if (ptr !== '') {
        firstChar = ptr.charAt(0);

        if (['#', '/'].indexOf(firstChar) === -1) {
          throw new Error('ptr must start with a / or #/');
        } else if (firstChar === '#' && ptr !== '#' && ptr.charAt(1) !== '/') {
          throw new Error('ptr must start with a / or #/');
        } else if (ptr.match(badPtrTokenRegex)) {
          throw new Error('ptr has invalid token(s)');
        }
      }
    } else {
      throw new Error('ptr is not a String');
    }
  } catch (err) {
    if (throwWithDetails === true) {
      throw err;
    }

    valid = false;
  }

  return valid;
}

function isRef(obj, throwWithDetails) {
  return isRefLike(obj, throwWithDetails) && getRefDetails(obj).type !== 'invalid';
}

function pathFromPtr(ptr) {
  try {
    isPtr(ptr, true);
  } catch (err) {
    throw new Error('ptr must be a JSON Pointer: ' + err.message);
  }

  var segments = ptr.split('/'); // Remove the first segment

  segments.shift();
  return decodePath(segments);
}

function pathToPtr(path, hashPrefix) {
  if (!_.isArray(path)) {
    throw new Error('path must be an Array');
  } // Encode each segment and return


  return (hashPrefix !== false ? '#' : '') + (path.length > 0 ? '/' : '') + encodePath(path).join('/');
}

function resolveRefs(obj, options) {
  var allTasks = Promise.resolve();
  allTasks = allTasks.then(function () {
    // Validate the provided document
    if (!_.isArray(obj) && !_.isObject(obj)) {
      throw new TypeError('obj must be an Array or an Object');
    } // Validate options


    options = validateOptions(options, obj); // Clone the input so we do not alter it

    obj = _.cloneDeep(obj);
  }).then(function () {
    var metadata = {
      deps: {},
      // To avoid processing the same refernece twice, and for circular reference identification
      docs: {},
      // Cache to avoid processing the same document more than once
      refs: {} // Reference locations and their metadata

    };
    return buildRefModel(obj, options, metadata).then(function () {
      return metadata;
    });
  }).then(function (results) {
    var allRefs = {};
    var circularPaths = [];
    var circulars = [];
    var depGraph = new gl.Graph();
    var fullLocation = makeAbsolute(options.location);
    var refsRoot = fullLocation + pathToPtr(options.subDocPath);
    var relativeBase = path.dirname(fullLocation); // Identify circulars
    // Add nodes first

    Object.keys(results.deps).forEach(function (node) {
      depGraph.setNode(node);
    }); // Add edges

    _.forOwn(results.deps, function (props, node) {
      _.forOwn(props, function (dep) {
        depGraph.setEdge(node, dep);
      });
    });

    circularPaths = gl.alg.findCycles(depGraph); // Create a unique list of circulars

    circularPaths.forEach(function (path) {
      path.forEach(function (seg) {
        if (circulars.indexOf(seg) === -1) {
          circulars.push(seg);
        }
      });
    }); // Identify circulars

    _.forOwn(results.deps, function (props, node) {
      _.forOwn(props, function (dep, prop) {
        var isCircular = false;
        var refPtr = node + prop.slice(1);
        var refDetails = results.refs[node + prop.slice(1)];
        var remote = isRemote(refDetails);
        var pathIndex;

        if (circulars.indexOf(dep) > -1) {
          // Figure out if the circular is part of a circular chain or just a reference to a circular
          circularPaths.forEach(function (path) {
            // Short circuit
            if (isCircular) {
              return;
            }

            pathIndex = path.indexOf(dep);

            if (pathIndex > -1) {
              // Check each path segment to see if the reference location is beneath one of its segments
              path.forEach(function (seg) {
                // Short circuit
                if (isCircular) {
                  return;
                }

                if (refPtr.indexOf(seg + '/') === 0) {
                  // If the reference is local, mark it as circular but if it's a remote reference, only mark it
                  // circular if the matching path is the last path segment or its match is not to a document root
                  if (!remote || pathIndex === path.length - 1 || dep[dep.length - 1] !== '#') {
                    isCircular = true;
                  }
                }
              });
            }
          });
        }

        if (isCircular) {
          // Update all references and reference details
          refDetails.circular = true;
        }
      });
    }); // Resolve the references in reverse order since the current order is top-down


    _.forOwn(Object.keys(results.deps).reverse(), function (parentPtr) {
      var deps = results.deps[parentPtr];
      var pPtrParts = parentPtr.split('#');
      var pDocument = results.docs[pPtrParts[0]];
      var pPtrPath = pathFromPtr(pPtrParts[1]);

      _.forOwn(deps, function (dep, prop) {
        var depParts = dep.split('#');
        var dDocument = results.docs[depParts[0]];
        var dPtrPath = pPtrPath.concat(pathFromPtr(prop));
        var refDetails = results.refs[pPtrParts[0] + pathToPtr(dPtrPath)]; // Resolve reference if valid

        if (_.isUndefined(refDetails.error) && _.isUndefined(refDetails.missing)) {
          if (!options.resolveCirculars && refDetails.circular) {
            refDetails.value = _.cloneDeep(refDetails.def);
          } else {
            try {
              refDetails.value = findValue(dDocument, pathFromPtr(depParts[1]));
            } catch (err) {
              markMissing(refDetails, err);
              return;
            } // If the reference is at the root of the document, replace the document in the cache.  Otherwise, replace
            // the value in the appropriate location in the document cache.


            if (pPtrParts[1] === '' && prop === '#') {
              results.docs[pPtrParts[0]] = refDetails.value;
            } else {
              setValue(pDocument, dPtrPath, refDetails.value);
            }
          }
        }
      });
    });

    function walkRefs(root, refPtr, refPath) {
      var refPtrParts = refPtr.split('#');
      var refDetails = results.refs[refPtr];
      var refDeps; // Record the reference (relative to the root document unless the reference is in the root document)

      allRefs[refPtrParts[0] === options.location ? '#' + refPtrParts[1] : pathToPtr(options.subDocPath.concat(refPath))] = refDetails; // Do not walk invalid references

      if (refDetails.circular || !isValid(refDetails)) {
        // Sanitize errors
        if (!refDetails.circular && refDetails.error) {
          // The way we use findRefs now results in an error that doesn't match the expectation
          refDetails.error = refDetails.error.replace('options.subDocPath', 'JSON Pointer'); // Update the error to use the appropriate JSON Pointer

          if (refDetails.error.indexOf('#') > -1) {
            refDetails.error = refDetails.error.replace(refDetails.uri.substr(refDetails.uri.indexOf('#')), refDetails.uri);
          } // Report errors opening files as JSON Pointer errors


          if (refDetails.error.indexOf('ENOENT:') === 0 || refDetails.error.indexOf('Not Found') === 0) {
            refDetails.error = 'JSON Pointer points to missing location: ' + refDetails.uri;
          }
        }

        return;
      }

      refDeps = results.deps[refDetails.refdId];

      if (refDetails.refdId.indexOf(root) !== 0) {
        Object.keys(refDeps).forEach(function (prop) {
          walkRefs(refDetails.refdId, refDetails.refdId + prop.substr(1), refPath.concat(pathFromPtr(prop)));
        });
      }
    } // For performance reasons, we only process a document (or sub document) and each reference once ever.  This means
    // that if we want to provide the full picture as to what paths in the resolved document were created as a result
    // of a reference, we have to take our fully-qualified reference locations and expand them to be all local based
    // on the original document.


    Object.keys(results.refs).forEach(function (refPtr) {
      var refDetails = results.refs[refPtr];
      var fqURISegments;
      var uriSegments; // Make all fully-qualified reference URIs relative to the document root (if necessary).  This step is done here
      // for performance reasons instead of below when the official sanitization process runs.

      if (refDetails.type !== 'invalid') {
        // Remove the trailing hash from document root references if they weren't in the original URI
        if (refDetails.fqURI[refDetails.fqURI.length - 1] === '#' && refDetails.uri[refDetails.uri.length - 1] !== '#') {
          refDetails.fqURI = refDetails.fqURI.substr(0, refDetails.fqURI.length - 1);
        }

        fqURISegments = refDetails.fqURI.split('/');
        uriSegments = refDetails.uri.split('/'); // The fully-qualified URI is unencoded so to keep the original formatting of the URI (encoded vs. unencoded),
        // we need to replace each URI segment in reverse order.

        _.times(uriSegments.length - 1, function (time) {
          var nSeg = uriSegments[uriSegments.length - time - 1];
          var pSeg = uriSegments[uriSegments.length - time];
          var fqSegIndex = fqURISegments.length - time - 1;

          if (nSeg === '.' || nSeg === '..' || pSeg === '..') {
            return;
          }

          fqURISegments[fqSegIndex] = nSeg;
        });

        refDetails.fqURI = fqURISegments.join('/'); // Make the fully-qualified URIs relative to the document root

        if (refDetails.fqURI.indexOf(fullLocation) === 0) {
          refDetails.fqURI = refDetails.fqURI.replace(fullLocation, '');
        } else if (refDetails.fqURI.indexOf(relativeBase) === 0) {
          refDetails.fqURI = refDetails.fqURI.replace(relativeBase, '');
        }

        if (refDetails.fqURI[0] === '/') {
          refDetails.fqURI = '.' + refDetails.fqURI;
        }
      } // We only want to process references found at or beneath the provided document and sub-document path


      if (refPtr.indexOf(refsRoot) !== 0) {
        return;
      }

      walkRefs(refsRoot, refPtr, pathFromPtr(refPtr.substr(refsRoot.length)));
    }); // Sanitize the reference details

    _.forOwn(allRefs, function (refDetails, refPtr) {
      // Delete the reference id used for dependency tracking and circular identification
      delete refDetails.refdId; // For locally-circular references, update the $ref to be fully qualified (Issue #175)

      if (refDetails.circular && refDetails.type === 'local') {
        refDetails.value.$ref = refDetails.fqURI;
        setValue(results.docs[fullLocation], pathFromPtr(refPtr), refDetails.value);
      } // To avoid the error message being URI encoded/decoded by mistake, replace the current JSON Pointer with the
      // value in the JSON Reference definition.


      if (refDetails.missing) {
        refDetails.error = refDetails.error.split(': ')[0] + ': ' + refDetails.def.$ref;
      }
    });

    return {
      refs: allRefs,
      resolved: results.docs[fullLocation]
    };
  });
  return allTasks;
}

function resolveRefsAt(location, options) {
  var allTasks = Promise.resolve();
  allTasks = allTasks.then(function () {
    // Validate the provided location
    if (!_.isString(location)) {
      throw new TypeError('location must be a string');
    }

    if (_.isUndefined(options)) {
      options = {};
    }

    if (_.isObject(options)) {
      // Add the location to the options for processing/validation
      options.location = location;
    } // Validate options


    options = validateOptions(options);
    return getRemoteDocument(options.location, options);
  }).then(function (res) {
    return resolveRefs(res, options).then(function (res2) {
      return {
        refs: res2.refs,
        resolved: res2.resolved,
        value: res
      };
    });
  });
  return allTasks;
}
/**
 * Various utilities for JSON References *(http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03)* and
 * JSON Pointers *(https://tools.ietf.org/html/rfc6901)*.
 *
 * @module json-refs
 */

/**
 * A number of functions exported below are used within the exported functions.  Typically, I would use a function
 * declaration _(with documenation)_ above and then just export a reference to the function but due to a bug in JSDoc
 * (https://github.com/jsdoc3/jsdoc/issues/679), this breaks the generated API documentation and TypeScript
 * declarations.  So that's why each `module.exports` below basically just wraps a call to the function declaration.
 */

/**
* Clears the internal cache of remote documents, reference details, etc.
*/


module.exports.clearCache = function () {
  remoteCache = {};
};
/**
 * Takes an array of path segments and decodes the JSON Pointer tokens in them.
 *
 * @param {string[]} path - The array of path segments
 *
 * @returns {string[]} the array of path segments with their JSON Pointer tokens decoded
 *
 * @throws {Error} if the path is not an `Array`
 *
 * @see {@link https://tools.ietf.org/html/rfc6901#section-3}
 */


module.exports.decodePath = function (path) {
  return decodePath(path);
};
/**
 * Takes an array of path segments and encodes the special JSON Pointer characters in them.
 *
 * @param {string[]} path - The array of path segments
 *
 * @returns {string[]} the array of path segments with their JSON Pointer tokens encoded
 *
 * @throws {Error} if the path is not an `Array`
 *
 * @see {@link https://tools.ietf.org/html/rfc6901#section-3}
 */


module.exports.encodePath = function (path) {
  return encodePath(path);
};
/**
 * Finds JSON References defined within the provided array/object.
 *
 * @param {array|object} obj - The structure to find JSON References within
 * @param {module:json-refs.JsonRefsOptions} [options] - The JsonRefs options
 *
 * @returns {Object.<string, module:json-refs.UnresolvedRefDetails|undefined>} an object whose keys are JSON Pointers
 * *(fragment version)* to where the JSON Reference is defined and whose values are {@link UnresolvedRefDetails}.
 *
 * @throws {Error} when the input arguments fail validation or if `options.subDocPath` points to an invalid location
 *
 * @example
 * // Finding all valid references
 * var allRefs = JsonRefs.findRefs(obj);
 * // Finding all remote references
 * var remoteRefs = JsonRefs.findRefs(obj, {filter: ['relative', 'remote']});
 * // Finding all invalid references
 * var invalidRefs = JsonRefs.findRefs(obj, {filter: 'invalid', includeInvalid: true});
 */


module.exports.findRefs = function (obj, options) {
  return findRefs(obj, options);
};
/**
 * Finds JSON References defined within the document at the provided location.
 *
 * This API is identical to {@link findRefs} except this API will retrieve a remote document and then
 * return the result of {@link findRefs} on the retrieved document.
 *
 * @param {string} location - The location to retrieve *(Can be relative or absolute, just make sure you look at the
 * {@link module:json-refs.JsonRefsOptions|options documentation} to see how relative references are handled.)*
 * @param {module:json-refs.JsonRefsOptions} [options] - The JsonRefs options
 *
 * @returns {Promise<module:json-refs.RetrievedRefsResults>} a promise that resolves a
 * {@link module:json-refs.RetrievedRefsResults} and rejects with an `Error` when the input arguments fail validation,
 * when `options.subDocPath` points to an invalid location or when the location argument points to an unloadable
 * resource
 *
 * @example
 * // Example that only resolves references within a sub document
 * JsonRefs.findRefsAt('http://petstore.swagger.io/v2/swagger.json', {
 *     subDocPath: '#/definitions'
 *   })
 *   .then(function (res) {
 *      // Do something with the response
 *      //
 *      // res.refs: JSON Reference locations and details
 *      // res.value: The retrieved document
 *   }, function (err) {
 *     console.log(err.stack);
 *   });
 */


module.exports.findRefsAt = function (location, options) {
  return findRefsAt(location, options);
};
/**
 * Returns detailed information about the JSON Reference.
 *
 * @param {object} obj - The JSON Reference definition
 *
 * @returns {module:json-refs.UnresolvedRefDetails} the detailed information
 */


module.exports.getRefDetails = function (obj) {
  return getRefDetails(obj);
};
/**
 * Returns whether the argument represents a JSON Pointer.
 *
 * A string is a JSON Pointer if the following are all true:
 *
 *   * The string is of type `String`
 *   * The string must be empty, `#` or start with a `/` or `#/`
 *
 * @param {string} ptr - The string to check
 * @param {boolean} [throwWithDetails=false] - Whether or not to throw an `Error` with the details as to why the value
 * provided is invalid
 *
 * @returns {boolean} the result of the check
 *
 * @throws {error} when the provided value is invalid and the `throwWithDetails` argument is `true`
 *
 * @see {@link https://tools.ietf.org/html/rfc6901#section-3}
 *
 * @example
 * // Separating the different ways to invoke isPtr for demonstration purposes
 * if (isPtr(str)) {
 *   // Handle a valid JSON Pointer
 * } else {
 *   // Get the reason as to why the value is not a JSON Pointer so you can fix/report it
 *   try {
 *     isPtr(str, true);
 *   } catch (err) {
 *     // The error message contains the details as to why the provided value is not a JSON Pointer
 *   }
 * }
 */


module.exports.isPtr = function (ptr, throwWithDetails) {
  return isPtr(ptr, throwWithDetails);
};
/**
 * Returns whether the argument represents a JSON Reference.
 *
 * An object is a JSON Reference only if the following are all true:
 *
 *   * The object is of type `Object`
 *   * The object has a `$ref` property
 *   * The `$ref` property is a valid URI *(We do not require 100% strict URIs and will handle unescaped special
 *     characters.)*
 *
 * @param {object} obj - The object to check
 * @param {boolean} [throwWithDetails=false] - Whether or not to throw an `Error` with the details as to why the value
 * provided is invalid
 *
 * @returns {boolean} the result of the check
 *
 * @throws {error} when the provided value is invalid and the `throwWithDetails` argument is `true`
 *
 * @see {@link http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03#section-3}
 *
 * @example
 * // Separating the different ways to invoke isRef for demonstration purposes
 * if (isRef(obj)) {
 *   // Handle a valid JSON Reference
 * } else {
 *   // Get the reason as to why the value is not a JSON Reference so you can fix/report it
 *   try {
 *     isRef(str, true);
 *   } catch (err) {
 *     // The error message contains the details as to why the provided value is not a JSON Reference
 *   }
 * }
 */


module.exports.isRef = function (obj, throwWithDetails) {
  return isRef(obj, throwWithDetails);
};
/**
 * Returns an array of path segments for the provided JSON Pointer.
 *
 * @param {string} ptr - The JSON Pointer
 *
 * @returns {string[]} the path segments
 *
 * @throws {Error} if the provided `ptr` argument is not a JSON Pointer
 */


module.exports.pathFromPtr = function (ptr) {
  return pathFromPtr(ptr);
};
/**
 * Returns a JSON Pointer for the provided array of path segments.
 *
 * **Note:** If a path segment in `path` is not a `String`, it will be converted to one using `JSON.stringify`.
 *
 * @param {string[]} path - The array of path segments
 * @param {boolean} [hashPrefix=true] - Whether or not create a hash-prefixed JSON Pointer
 *
 * @returns {string} the corresponding JSON Pointer
 *
 * @throws {Error} if the `path` argument is not an array
 */


module.exports.pathToPtr = function (path, hashPrefix) {
  return pathToPtr(path, hashPrefix);
};
/**
 * Finds JSON References defined within the provided array/object and resolves them.
 *
 * @param {array|object} obj - The structure to find JSON References within
 * @param {module:json-refs.JsonRefsOptions} [options] - The JsonRefs options
 *
 * @returns {Promise<module:json-refs.ResolvedRefsResults>} a promise that resolves a
 * {@link module:json-refs.ResolvedRefsResults} and rejects with an `Error` when the input arguments fail validation,
 * when `options.subDocPath` points to an invalid location or when the location argument points to an unloadable
 * resource
 *
 * @example
 * // Example that only resolves relative and remote references
 * JsonRefs.resolveRefs(swaggerObj, {
 *     filter: ['relative', 'remote']
 *   })
 *   .then(function (res) {
 *      // Do something with the response
 *      //
 *      // res.refs: JSON Reference locations and details
 *      // res.resolved: The document with the appropriate JSON References resolved
 *   }, function (err) {
 *     console.log(err.stack);
 *   });
 */


module.exports.resolveRefs = function (obj, options) {
  return resolveRefs(obj, options);
};
/**
 * Resolves JSON References defined within the document at the provided location.
 *
 * This API is identical to {@link module:json-refs.resolveRefs} except this API will retrieve a remote document and
 * then return the result of {@link module:json-refs.resolveRefs} on the retrieved document.
 *
 * @param {string} location - The location to retrieve *(Can be relative or absolute, just make sure you look at the
 * {@link module:json-refs.JsonRefsOptions|options documentation} to see how relative references are handled.)*
 * @param {module:json-refs.JsonRefsOptions} [options] - The JsonRefs options
 *
 * @returns {Promise<module:json-refs.RetrievedResolvedRefsResults>} a promise that resolves a
 * {@link module:json-refs.RetrievedResolvedRefsResults} and rejects with an `Error` when the input arguments fail
 * validation, when `options.subDocPath` points to an invalid location or when the location argument points to an
 * unloadable resource
 *
 * @example
 * // Example that loads a JSON document (No options.loaderOptions.processContent required) and resolves all references
 * JsonRefs.resolveRefsAt('./swagger.json')
 *   .then(function (res) {
 *      // Do something with the response
 *      //
 *      // res.refs: JSON Reference locations and details
 *      // res.resolved: The document with the appropriate JSON References resolved
 *      // res.value: The retrieved document
 *   }, function (err) {
 *     console.log(err.stack);
 *   });
 */


module.exports.resolveRefsAt = function (location, options) {
  return resolveRefsAt(location, options);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/component-emitter/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-emitter/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Expose `Emitter`.
 */
if (true) {
  module.exports = Emitter;
}
/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */


function Emitter(obj) {
  if (obj) return mixin(obj);
}

;
/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }

  return obj;
}
/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};
/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};
/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {}; // all

  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  } // specific event


  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this; // remove all handlers

  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  } // remove specific handler


  var cb;

  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];

    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  return this;
};
/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */


Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1),
      callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);

    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};
/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */


Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};
/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */


Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

/***/ }),

/***/ "./node_modules/graphlib/index.js":
/*!****************************************!*\
  !*** ./node_modules/graphlib/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014, Chris Pettitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var lib = __webpack_require__(/*! ./lib */ "./node_modules/graphlib/lib/index.js");

module.exports = {
  Graph: lib.Graph,
  json: __webpack_require__(/*! ./lib/json */ "./node_modules/graphlib/lib/json.js"),
  alg: __webpack_require__(/*! ./lib/alg */ "./node_modules/graphlib/lib/alg/index.js"),
  version: lib.version
};

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/components.js":
/*!*****************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/components.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = components;

function components(g) {
  var visited = {};
  var cmpts = [];
  var cmpt;

  function dfs(v) {
    if (_.has(visited, v)) return;
    visited[v] = true;
    cmpt.push(v);

    _.each(g.successors(v), dfs);

    _.each(g.predecessors(v), dfs);
  }

  _.each(g.nodes(), function (v) {
    cmpt = [];
    dfs(v);

    if (cmpt.length) {
      cmpts.push(cmpt);
    }
  });

  return cmpts;
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/dfs.js":
/*!**********************************************!*\
  !*** ./node_modules/graphlib/lib/alg/dfs.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = dfs;
/*
 * A helper that preforms a pre- or post-order traversal on the input graph
 * and returns the nodes in the order they were visited. If the graph is
 * undirected then this algorithm will navigate using neighbors. If the graph
 * is directed then this algorithm will navigate using successors.
 *
 * Order must be one of "pre" or "post".
 */

function dfs(g, vs, order) {
  if (!_.isArray(vs)) {
    vs = [vs];
  }

  var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);
  var acc = [];
  var visited = {};

  _.each(vs, function (v) {
    if (!g.hasNode(v)) {
      throw new Error("Graph does not have node: " + v);
    }

    doDfs(g, v, order === "post", visited, navigation, acc);
  });

  return acc;
}

function doDfs(g, v, postorder, visited, navigation, acc) {
  if (!_.has(visited, v)) {
    visited[v] = true;

    if (!postorder) {
      acc.push(v);
    }

    _.each(navigation(v), function (w) {
      doDfs(g, w, postorder, visited, navigation, acc);
    });

    if (postorder) {
      acc.push(v);
    }
  }
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/dijkstra-all.js":
/*!*******************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/dijkstra-all.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dijkstra = __webpack_require__(/*! ./dijkstra */ "./node_modules/graphlib/lib/alg/dijkstra.js");

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = dijkstraAll;

function dijkstraAll(g, weightFunc, edgeFunc) {
  return _.transform(g.nodes(), function (acc, v) {
    acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
  }, {});
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/dijkstra.js":
/*!***************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/dijkstra.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

var PriorityQueue = __webpack_require__(/*! ../data/priority-queue */ "./node_modules/graphlib/lib/data/priority-queue.js");

module.exports = dijkstra;

var DEFAULT_WEIGHT_FUNC = _.constant(1);

function dijkstra(g, source, weightFn, edgeFn) {
  return runDijkstra(g, String(source), weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function (v) {
    return g.outEdges(v);
  });
}

function runDijkstra(g, source, weightFn, edgeFn) {
  var results = {};
  var pq = new PriorityQueue();
  var v, vEntry;

  var updateNeighbors = function updateNeighbors(edge) {
    var w = edge.v !== v ? edge.v : edge.w;
    var wEntry = results[w];
    var weight = weightFn(edge);
    var distance = vEntry.distance + weight;

    if (weight < 0) {
      throw new Error("dijkstra does not allow negative edge weights. " + "Bad edge: " + edge + " Weight: " + weight);
    }

    if (distance < wEntry.distance) {
      wEntry.distance = distance;
      wEntry.predecessor = v;
      pq.decrease(w, distance);
    }
  };

  g.nodes().forEach(function (v) {
    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;
    results[v] = {
      distance: distance
    };
    pq.add(v, distance);
  });

  while (pq.size() > 0) {
    v = pq.removeMin();
    vEntry = results[v];

    if (vEntry.distance === Number.POSITIVE_INFINITY) {
      break;
    }

    edgeFn(v).forEach(updateNeighbors);
  }

  return results;
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/find-cycles.js":
/*!******************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/find-cycles.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

var tarjan = __webpack_require__(/*! ./tarjan */ "./node_modules/graphlib/lib/alg/tarjan.js");

module.exports = findCycles;

function findCycles(g) {
  return _.filter(tarjan(g), function (cmpt) {
    return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
  });
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/floyd-warshall.js":
/*!*********************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/floyd-warshall.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = floydWarshall;

var DEFAULT_WEIGHT_FUNC = _.constant(1);

function floydWarshall(g, weightFn, edgeFn) {
  return runFloydWarshall(g, weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function (v) {
    return g.outEdges(v);
  });
}

function runFloydWarshall(g, weightFn, edgeFn) {
  var results = {};
  var nodes = g.nodes();
  nodes.forEach(function (v) {
    results[v] = {};
    results[v][v] = {
      distance: 0
    };
    nodes.forEach(function (w) {
      if (v !== w) {
        results[v][w] = {
          distance: Number.POSITIVE_INFINITY
        };
      }
    });
    edgeFn(v).forEach(function (edge) {
      var w = edge.v === v ? edge.w : edge.v;
      var d = weightFn(edge);
      results[v][w] = {
        distance: d,
        predecessor: v
      };
    });
  });
  nodes.forEach(function (k) {
    var rowK = results[k];
    nodes.forEach(function (i) {
      var rowI = results[i];
      nodes.forEach(function (j) {
        var ik = rowI[k];
        var kj = rowK[j];
        var ij = rowI[j];
        var altDistance = ik.distance + kj.distance;

        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });
  return results;
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/index.js":
/*!************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  components: __webpack_require__(/*! ./components */ "./node_modules/graphlib/lib/alg/components.js"),
  dijkstra: __webpack_require__(/*! ./dijkstra */ "./node_modules/graphlib/lib/alg/dijkstra.js"),
  dijkstraAll: __webpack_require__(/*! ./dijkstra-all */ "./node_modules/graphlib/lib/alg/dijkstra-all.js"),
  findCycles: __webpack_require__(/*! ./find-cycles */ "./node_modules/graphlib/lib/alg/find-cycles.js"),
  floydWarshall: __webpack_require__(/*! ./floyd-warshall */ "./node_modules/graphlib/lib/alg/floyd-warshall.js"),
  isAcyclic: __webpack_require__(/*! ./is-acyclic */ "./node_modules/graphlib/lib/alg/is-acyclic.js"),
  postorder: __webpack_require__(/*! ./postorder */ "./node_modules/graphlib/lib/alg/postorder.js"),
  preorder: __webpack_require__(/*! ./preorder */ "./node_modules/graphlib/lib/alg/preorder.js"),
  prim: __webpack_require__(/*! ./prim */ "./node_modules/graphlib/lib/alg/prim.js"),
  tarjan: __webpack_require__(/*! ./tarjan */ "./node_modules/graphlib/lib/alg/tarjan.js"),
  topsort: __webpack_require__(/*! ./topsort */ "./node_modules/graphlib/lib/alg/topsort.js")
};

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/is-acyclic.js":
/*!*****************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/is-acyclic.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var topsort = __webpack_require__(/*! ./topsort */ "./node_modules/graphlib/lib/alg/topsort.js");

module.exports = isAcyclic;

function isAcyclic(g) {
  try {
    topsort(g);
  } catch (e) {
    if (e instanceof topsort.CycleException) {
      return false;
    }

    throw e;
  }

  return true;
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/postorder.js":
/*!****************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/postorder.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dfs = __webpack_require__(/*! ./dfs */ "./node_modules/graphlib/lib/alg/dfs.js");

module.exports = postorder;

function postorder(g, vs) {
  return dfs(g, vs, "post");
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/preorder.js":
/*!***************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/preorder.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dfs = __webpack_require__(/*! ./dfs */ "./node_modules/graphlib/lib/alg/dfs.js");

module.exports = preorder;

function preorder(g, vs) {
  return dfs(g, vs, "pre");
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/prim.js":
/*!***********************************************!*\
  !*** ./node_modules/graphlib/lib/alg/prim.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

var Graph = __webpack_require__(/*! ../graph */ "./node_modules/graphlib/lib/graph.js");

var PriorityQueue = __webpack_require__(/*! ../data/priority-queue */ "./node_modules/graphlib/lib/data/priority-queue.js");

module.exports = prim;

function prim(g, weightFunc) {
  var result = new Graph();
  var parents = {};
  var pq = new PriorityQueue();
  var v;

  function updateNeighbors(edge) {
    var w = edge.v === v ? edge.w : edge.v;
    var pri = pq.priority(w);

    if (pri !== undefined) {
      var edgeWeight = weightFunc(edge);

      if (edgeWeight < pri) {
        parents[w] = v;
        pq.decrease(w, edgeWeight);
      }
    }
  }

  if (g.nodeCount() === 0) {
    return result;
  }

  _.each(g.nodes(), function (v) {
    pq.add(v, Number.POSITIVE_INFINITY);
    result.setNode(v);
  }); // Start from an arbitrary node


  pq.decrease(g.nodes()[0], 0);
  var init = false;

  while (pq.size() > 0) {
    v = pq.removeMin();

    if (_.has(parents, v)) {
      result.setEdge(v, parents[v]);
    } else if (init) {
      throw new Error("Input graph is not connected: " + g);
    } else {
      init = true;
    }

    g.nodeEdges(v).forEach(updateNeighbors);
  }

  return result;
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/tarjan.js":
/*!*************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/tarjan.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = tarjan;

function tarjan(g) {
  var index = 0;
  var stack = [];
  var visited = {}; // node id -> { onStack, lowlink, index }

  var results = [];

  function dfs(v) {
    var entry = visited[v] = {
      onStack: true,
      lowlink: index,
      index: index++
    };
    stack.push(v);
    g.successors(v).forEach(function (w) {
      if (!_.has(visited, w)) {
        dfs(w);
        entry.lowlink = Math.min(entry.lowlink, visited[w].lowlink);
      } else if (visited[w].onStack) {
        entry.lowlink = Math.min(entry.lowlink, visited[w].index);
      }
    });

    if (entry.lowlink === entry.index) {
      var cmpt = [];
      var w;

      do {
        w = stack.pop();
        visited[w].onStack = false;
        cmpt.push(w);
      } while (v !== w);

      results.push(cmpt);
    }
  }

  g.nodes().forEach(function (v) {
    if (!_.has(visited, v)) {
      dfs(v);
    }
  });
  return results;
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/topsort.js":
/*!**************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/topsort.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = topsort;
topsort.CycleException = CycleException;

function topsort(g) {
  var visited = {};
  var stack = {};
  var results = [];

  function visit(node) {
    if (_.has(stack, node)) {
      throw new CycleException();
    }

    if (!_.has(visited, node)) {
      stack[node] = true;
      visited[node] = true;

      _.each(g.predecessors(node), visit);

      delete stack[node];
      results.push(node);
    }
  }

  _.each(g.sinks(), visit);

  if (_.size(visited) !== g.nodeCount()) {
    throw new CycleException();
  }

  return results;
}

function CycleException() {}

CycleException.prototype = new Error(); // must be an instance of Error to pass testing

/***/ }),

/***/ "./node_modules/graphlib/lib/data/priority-queue.js":
/*!**********************************************************!*\
  !*** ./node_modules/graphlib/lib/data/priority-queue.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = PriorityQueue;
/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., "Introduction to Algorithms". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */

function PriorityQueue() {
  this._arr = [];
  this._keyIndices = {};
}
/**
 * Returns the number of elements in the queue. Takes `O(1)` time.
 */


PriorityQueue.prototype.size = function () {
  return this._arr.length;
};
/**
 * Returns the keys that are in the queue. Takes `O(n)` time.
 */


PriorityQueue.prototype.keys = function () {
  return this._arr.map(function (x) {
    return x.key;
  });
};
/**
 * Returns `true` if **key** is in the queue and `false` if not.
 */


PriorityQueue.prototype.has = function (key) {
  return _.has(this._keyIndices, key);
};
/**
 * Returns the priority for **key**. If **key** is not present in the queue
 * then this function returns `undefined`. Takes `O(1)` time.
 *
 * @param {Object} key
 */


PriorityQueue.prototype.priority = function (key) {
  var index = this._keyIndices[key];

  if (index !== undefined) {
    return this._arr[index].priority;
  }
};
/**
 * Returns the key for the minimum element in this queue. If the queue is
 * empty this function throws an Error. Takes `O(1)` time.
 */


PriorityQueue.prototype.min = function () {
  if (this.size() === 0) {
    throw new Error("Queue underflow");
  }

  return this._arr[0].key;
};
/**
 * Inserts a new key into the priority queue. If the key already exists in
 * the queue this function returns `false`; otherwise it will return `true`.
 * Takes `O(n)` time.
 *
 * @param {Object} key the key to add
 * @param {Number} priority the initial priority for the key
 */


PriorityQueue.prototype.add = function (key, priority) {
  var keyIndices = this._keyIndices;
  key = String(key);

  if (!_.has(keyIndices, key)) {
    var arr = this._arr;
    var index = arr.length;
    keyIndices[key] = index;
    arr.push({
      key: key,
      priority: priority
    });

    this._decrease(index);

    return true;
  }

  return false;
};
/**
 * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
 */


PriorityQueue.prototype.removeMin = function () {
  this._swap(0, this._arr.length - 1);

  var min = this._arr.pop();

  delete this._keyIndices[min.key];

  this._heapify(0);

  return min.key;
};
/**
 * Decreases the priority for **key** to **priority**. If the new priority is
 * greater than the previous priority, this function will throw an Error.
 *
 * @param {Object} key the key for which to raise priority
 * @param {Number} priority the new priority for the key
 */


PriorityQueue.prototype.decrease = function (key, priority) {
  var index = this._keyIndices[key];

  if (priority > this._arr[index].priority) {
    throw new Error("New priority is greater than current priority. " + "Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
  }

  this._arr[index].priority = priority;

  this._decrease(index);
};

PriorityQueue.prototype._heapify = function (i) {
  var arr = this._arr;
  var l = 2 * i;
  var r = l + 1;
  var largest = i;

  if (l < arr.length) {
    largest = arr[l].priority < arr[largest].priority ? l : largest;

    if (r < arr.length) {
      largest = arr[r].priority < arr[largest].priority ? r : largest;
    }

    if (largest !== i) {
      this._swap(i, largest);

      this._heapify(largest);
    }
  }
};

PriorityQueue.prototype._decrease = function (index) {
  var arr = this._arr;
  var priority = arr[index].priority;
  var parent;

  while (index !== 0) {
    parent = index >> 1;

    if (arr[parent].priority < priority) {
      break;
    }

    this._swap(index, parent);

    index = parent;
  }
};

PriorityQueue.prototype._swap = function (i, j) {
  var arr = this._arr;
  var keyIndices = this._keyIndices;
  var origArrI = arr[i];
  var origArrJ = arr[j];
  arr[i] = origArrJ;
  arr[j] = origArrI;
  keyIndices[origArrJ.key] = i;
  keyIndices[origArrI.key] = j;
};

/***/ }),

/***/ "./node_modules/graphlib/lib/graph.js":
/*!********************************************!*\
  !*** ./node_modules/graphlib/lib/graph.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = Graph;
var DEFAULT_EDGE_NAME = "\x00";
var GRAPH_NODE = "\x00";
var EDGE_KEY_DELIM = "\x01"; // Implementation notes:
//
//  * Node id query functions should return string ids for the nodes
//  * Edge id query functions should return an "edgeObj", edge object, that is
//    composed of enough information to uniquely identify an edge: {v, w, name}.
//  * Internally we use an "edgeId", a stringified form of the edgeObj, to
//    reference edges. This is because we need a performant way to look these
//    edges up and, object properties, which have string keys, are the closest
//    we're going to get to a performant hashtable in JavaScript.

function Graph(opts) {
  this._isDirected = _.has(opts, "directed") ? opts.directed : true;
  this._isMultigraph = _.has(opts, "multigraph") ? opts.multigraph : false;
  this._isCompound = _.has(opts, "compound") ? opts.compound : false; // Label for the graph itself

  this._label = undefined; // Defaults to be set when creating a new node

  this._defaultNodeLabelFn = _.constant(undefined); // Defaults to be set when creating a new edge

  this._defaultEdgeLabelFn = _.constant(undefined); // v -> label

  this._nodes = {};

  if (this._isCompound) {
    // v -> parent
    this._parent = {}; // v -> children

    this._children = {};
    this._children[GRAPH_NODE] = {};
  } // v -> edgeObj


  this._in = {}; // u -> v -> Number

  this._preds = {}; // v -> edgeObj

  this._out = {}; // v -> w -> Number

  this._sucs = {}; // e -> edgeObj

  this._edgeObjs = {}; // e -> label

  this._edgeLabels = {};
}
/* Number of nodes in the graph. Should only be changed by the implementation. */


Graph.prototype._nodeCount = 0;
/* Number of edges in the graph. Should only be changed by the implementation. */

Graph.prototype._edgeCount = 0;
/* === Graph functions ========= */

Graph.prototype.isDirected = function () {
  return this._isDirected;
};

Graph.prototype.isMultigraph = function () {
  return this._isMultigraph;
};

Graph.prototype.isCompound = function () {
  return this._isCompound;
};

Graph.prototype.setGraph = function (label) {
  this._label = label;
  return this;
};

Graph.prototype.graph = function () {
  return this._label;
};
/* === Node functions ========== */


Graph.prototype.setDefaultNodeLabel = function (newDefault) {
  if (!_.isFunction(newDefault)) {
    newDefault = _.constant(newDefault);
  }

  this._defaultNodeLabelFn = newDefault;
  return this;
};

Graph.prototype.nodeCount = function () {
  return this._nodeCount;
};

Graph.prototype.nodes = function () {
  return _.keys(this._nodes);
};

Graph.prototype.sources = function () {
  var self = this;
  return _.filter(this.nodes(), function (v) {
    return _.isEmpty(self._in[v]);
  });
};

Graph.prototype.sinks = function () {
  var self = this;
  return _.filter(this.nodes(), function (v) {
    return _.isEmpty(self._out[v]);
  });
};

Graph.prototype.setNodes = function (vs, value) {
  var args = arguments;
  var self = this;

  _.each(vs, function (v) {
    if (args.length > 1) {
      self.setNode(v, value);
    } else {
      self.setNode(v);
    }
  });

  return this;
};

Graph.prototype.setNode = function (v, value) {
  if (_.has(this._nodes, v)) {
    if (arguments.length > 1) {
      this._nodes[v] = value;
    }

    return this;
  }

  this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);

  if (this._isCompound) {
    this._parent[v] = GRAPH_NODE;
    this._children[v] = {};
    this._children[GRAPH_NODE][v] = true;
  }

  this._in[v] = {};
  this._preds[v] = {};
  this._out[v] = {};
  this._sucs[v] = {};
  ++this._nodeCount;
  return this;
};

Graph.prototype.node = function (v) {
  return this._nodes[v];
};

Graph.prototype.hasNode = function (v) {
  return _.has(this._nodes, v);
};

Graph.prototype.removeNode = function (v) {
  var self = this;

  if (_.has(this._nodes, v)) {
    var removeEdge = function removeEdge(e) {
      self.removeEdge(self._edgeObjs[e]);
    };

    delete this._nodes[v];

    if (this._isCompound) {
      this._removeFromParentsChildList(v);

      delete this._parent[v];

      _.each(this.children(v), function (child) {
        self.setParent(child);
      });

      delete this._children[v];
    }

    _.each(_.keys(this._in[v]), removeEdge);

    delete this._in[v];
    delete this._preds[v];

    _.each(_.keys(this._out[v]), removeEdge);

    delete this._out[v];
    delete this._sucs[v];
    --this._nodeCount;
  }

  return this;
};

Graph.prototype.setParent = function (v, parent) {
  if (!this._isCompound) {
    throw new Error("Cannot set parent in a non-compound graph");
  }

  if (_.isUndefined(parent)) {
    parent = GRAPH_NODE;
  } else {
    // Coerce parent to string
    parent += "";

    for (var ancestor = parent; !_.isUndefined(ancestor); ancestor = this.parent(ancestor)) {
      if (ancestor === v) {
        throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
      }
    }

    this.setNode(parent);
  }

  this.setNode(v);

  this._removeFromParentsChildList(v);

  this._parent[v] = parent;
  this._children[parent][v] = true;
  return this;
};

Graph.prototype._removeFromParentsChildList = function (v) {
  delete this._children[this._parent[v]][v];
};

Graph.prototype.parent = function (v) {
  if (this._isCompound) {
    var parent = this._parent[v];

    if (parent !== GRAPH_NODE) {
      return parent;
    }
  }
};

Graph.prototype.children = function (v) {
  if (_.isUndefined(v)) {
    v = GRAPH_NODE;
  }

  if (this._isCompound) {
    var children = this._children[v];

    if (children) {
      return _.keys(children);
    }
  } else if (v === GRAPH_NODE) {
    return this.nodes();
  } else if (this.hasNode(v)) {
    return [];
  }
};

Graph.prototype.predecessors = function (v) {
  var predsV = this._preds[v];

  if (predsV) {
    return _.keys(predsV);
  }
};

Graph.prototype.successors = function (v) {
  var sucsV = this._sucs[v];

  if (sucsV) {
    return _.keys(sucsV);
  }
};

Graph.prototype.neighbors = function (v) {
  var preds = this.predecessors(v);

  if (preds) {
    return _.union(preds, this.successors(v));
  }
};

Graph.prototype.isLeaf = function (v) {
  var neighbors;

  if (this.isDirected()) {
    neighbors = this.successors(v);
  } else {
    neighbors = this.neighbors(v);
  }

  return neighbors.length === 0;
};

Graph.prototype.filterNodes = function (filter) {
  var copy = new this.constructor({
    directed: this._isDirected,
    multigraph: this._isMultigraph,
    compound: this._isCompound
  });
  copy.setGraph(this.graph());
  var self = this;

  _.each(this._nodes, function (value, v) {
    if (filter(v)) {
      copy.setNode(v, value);
    }
  });

  _.each(this._edgeObjs, function (e) {
    if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
      copy.setEdge(e, self.edge(e));
    }
  });

  var parents = {};

  function findParent(v) {
    var parent = self.parent(v);

    if (parent === undefined || copy.hasNode(parent)) {
      parents[v] = parent;
      return parent;
    } else if (parent in parents) {
      return parents[parent];
    } else {
      return findParent(parent);
    }
  }

  if (this._isCompound) {
    _.each(copy.nodes(), function (v) {
      copy.setParent(v, findParent(v));
    });
  }

  return copy;
};
/* === Edge functions ========== */


Graph.prototype.setDefaultEdgeLabel = function (newDefault) {
  if (!_.isFunction(newDefault)) {
    newDefault = _.constant(newDefault);
  }

  this._defaultEdgeLabelFn = newDefault;
  return this;
};

Graph.prototype.edgeCount = function () {
  return this._edgeCount;
};

Graph.prototype.edges = function () {
  return _.values(this._edgeObjs);
};

Graph.prototype.setPath = function (vs, value) {
  var self = this;
  var args = arguments;

  _.reduce(vs, function (v, w) {
    if (args.length > 1) {
      self.setEdge(v, w, value);
    } else {
      self.setEdge(v, w);
    }

    return w;
  });

  return this;
};
/*
 * setEdge(v, w, [value, [name]])
 * setEdge({ v, w, [name] }, [value])
 */


Graph.prototype.setEdge = function () {
  var v, w, name, value;
  var valueSpecified = false;
  var arg0 = arguments[0];

  if (_typeof(arg0) === "object" && arg0 !== null && "v" in arg0) {
    v = arg0.v;
    w = arg0.w;
    name = arg0.name;

    if (arguments.length === 2) {
      value = arguments[1];
      valueSpecified = true;
    }
  } else {
    v = arg0;
    w = arguments[1];
    name = arguments[3];

    if (arguments.length > 2) {
      value = arguments[2];
      valueSpecified = true;
    }
  }

  v = "" + v;
  w = "" + w;

  if (!_.isUndefined(name)) {
    name = "" + name;
  }

  var e = edgeArgsToId(this._isDirected, v, w, name);

  if (_.has(this._edgeLabels, e)) {
    if (valueSpecified) {
      this._edgeLabels[e] = value;
    }

    return this;
  }

  if (!_.isUndefined(name) && !this._isMultigraph) {
    throw new Error("Cannot set a named edge when isMultigraph = false");
  } // It didn't exist, so we need to create it.
  // First ensure the nodes exist.


  this.setNode(v);
  this.setNode(w);
  this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);
  var edgeObj = edgeArgsToObj(this._isDirected, v, w, name); // Ensure we add undirected edges in a consistent way.

  v = edgeObj.v;
  w = edgeObj.w;
  Object.freeze(edgeObj);
  this._edgeObjs[e] = edgeObj;
  incrementOrInitEntry(this._preds[w], v);
  incrementOrInitEntry(this._sucs[v], w);
  this._in[w][e] = edgeObj;
  this._out[v][e] = edgeObj;
  this._edgeCount++;
  return this;
};

Graph.prototype.edge = function (v, w, name) {
  var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
  return this._edgeLabels[e];
};

Graph.prototype.hasEdge = function (v, w, name) {
  var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
  return _.has(this._edgeLabels, e);
};

Graph.prototype.removeEdge = function (v, w, name) {
  var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
  var edge = this._edgeObjs[e];

  if (edge) {
    v = edge.v;
    w = edge.w;
    delete this._edgeLabels[e];
    delete this._edgeObjs[e];
    decrementOrRemoveEntry(this._preds[w], v);
    decrementOrRemoveEntry(this._sucs[v], w);
    delete this._in[w][e];
    delete this._out[v][e];
    this._edgeCount--;
  }

  return this;
};

Graph.prototype.inEdges = function (v, u) {
  var inV = this._in[v];

  if (inV) {
    var edges = _.values(inV);

    if (!u) {
      return edges;
    }

    return _.filter(edges, function (edge) {
      return edge.v === u;
    });
  }
};

Graph.prototype.outEdges = function (v, w) {
  var outV = this._out[v];

  if (outV) {
    var edges = _.values(outV);

    if (!w) {
      return edges;
    }

    return _.filter(edges, function (edge) {
      return edge.w === w;
    });
  }
};

Graph.prototype.nodeEdges = function (v, w) {
  var inEdges = this.inEdges(v, w);

  if (inEdges) {
    return inEdges.concat(this.outEdges(v, w));
  }
};

function incrementOrInitEntry(map, k) {
  if (map[k]) {
    map[k]++;
  } else {
    map[k] = 1;
  }
}

function decrementOrRemoveEntry(map, k) {
  if (! --map[k]) {
    delete map[k];
  }
}

function edgeArgsToId(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;

  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }

  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
}

function edgeArgsToObj(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;

  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }

  var edgeObj = {
    v: v,
    w: w
  };

  if (name) {
    edgeObj.name = name;
  }

  return edgeObj;
}

function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}

/***/ }),

/***/ "./node_modules/graphlib/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/graphlib/lib/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Includes only the "core" of graphlib
module.exports = {
  Graph: __webpack_require__(/*! ./graph */ "./node_modules/graphlib/lib/graph.js"),
  version: __webpack_require__(/*! ./version */ "./node_modules/graphlib/lib/version.js")
};

/***/ }),

/***/ "./node_modules/graphlib/lib/json.js":
/*!*******************************************!*\
  !*** ./node_modules/graphlib/lib/json.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/graphlib/lib/lodash.js");

var Graph = __webpack_require__(/*! ./graph */ "./node_modules/graphlib/lib/graph.js");

module.exports = {
  write: write,
  read: read
};

function write(g) {
  var json = {
    options: {
      directed: g.isDirected(),
      multigraph: g.isMultigraph(),
      compound: g.isCompound()
    },
    nodes: writeNodes(g),
    edges: writeEdges(g)
  };

  if (!_.isUndefined(g.graph())) {
    json.value = _.clone(g.graph());
  }

  return json;
}

function writeNodes(g) {
  return _.map(g.nodes(), function (v) {
    var nodeValue = g.node(v);
    var parent = g.parent(v);
    var node = {
      v: v
    };

    if (!_.isUndefined(nodeValue)) {
      node.value = nodeValue;
    }

    if (!_.isUndefined(parent)) {
      node.parent = parent;
    }

    return node;
  });
}

function writeEdges(g) {
  return _.map(g.edges(), function (e) {
    var edgeValue = g.edge(e);
    var edge = {
      v: e.v,
      w: e.w
    };

    if (!_.isUndefined(e.name)) {
      edge.name = e.name;
    }

    if (!_.isUndefined(edgeValue)) {
      edge.value = edgeValue;
    }

    return edge;
  });
}

function read(json) {
  var g = new Graph(json.options).setGraph(json.value);

  _.each(json.nodes, function (entry) {
    g.setNode(entry.v, entry.value);

    if (entry.parent) {
      g.setParent(entry.v, entry.parent);
    }
  });

  _.each(json.edges, function (entry) {
    g.setEdge({
      v: entry.v,
      w: entry.w,
      name: entry.name
    }, entry.value);
  });

  return g;
}

/***/ }),

/***/ "./node_modules/graphlib/lib/lodash.js":
/*!*********************************************!*\
  !*** ./node_modules/graphlib/lib/lodash.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* global window */
var lodash;

if (true) {
  try {
    lodash = {
      clone: __webpack_require__(/*! lodash/clone */ "./node_modules/lodash/clone.js"),
      constant: __webpack_require__(/*! lodash/constant */ "./node_modules/lodash/constant.js"),
      each: __webpack_require__(/*! lodash/each */ "./node_modules/lodash/each.js"),
      filter: __webpack_require__(/*! lodash/filter */ "./node_modules/lodash/filter.js"),
      has: __webpack_require__(/*! lodash/has */ "./node_modules/lodash/has.js"),
      isArray: __webpack_require__(/*! lodash/isArray */ "./node_modules/lodash/isArray.js"),
      isEmpty: __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js"),
      isFunction: __webpack_require__(/*! lodash/isFunction */ "./node_modules/lodash/isFunction.js"),
      isUndefined: __webpack_require__(/*! lodash/isUndefined */ "./node_modules/lodash/isUndefined.js"),
      keys: __webpack_require__(/*! lodash/keys */ "./node_modules/lodash/keys.js"),
      map: __webpack_require__(/*! lodash/map */ "./node_modules/lodash/map.js"),
      reduce: __webpack_require__(/*! lodash/reduce */ "./node_modules/lodash/reduce.js"),
      size: __webpack_require__(/*! lodash/size */ "./node_modules/lodash/size.js"),
      transform: __webpack_require__(/*! lodash/transform */ "./node_modules/lodash/transform.js"),
      union: __webpack_require__(/*! lodash/union */ "./node_modules/lodash/union.js"),
      values: __webpack_require__(/*! lodash/values */ "./node_modules/lodash/values.js")
    };
  } catch (e) {// continue regardless of error
  }
}

if (!lodash) {
  lodash = window._;
}

module.exports = lodash;

/***/ }),

/***/ "./node_modules/graphlib/lib/version.js":
/*!**********************************************!*\
  !*** ./node_modules/graphlib/lib/version.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = '2.1.8';

/***/ }),

/***/ "./node_modules/lodash/_DataView.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_DataView.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var DataView = getNative(root, 'DataView');
module.exports = DataView;

/***/ }),

/***/ "./node_modules/lodash/_Hash.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_Hash.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(/*! ./_hashClear */ "./node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "./node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "./node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "./node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "./node_modules/lodash/_hashSet.js");
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;

/***/ }),

/***/ "./node_modules/lodash/_ListCache.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_ListCache.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "./node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "./node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "./node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "./node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "./node_modules/lodash/_listCacheSet.js");
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;

/***/ }),

/***/ "./node_modules/lodash/_Map.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Map.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var Map = getNative(root, 'Map');
module.exports = Map;

/***/ }),

/***/ "./node_modules/lodash/_MapCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_MapCache.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "./node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "./node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "./node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "./node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "./node_modules/lodash/_mapCacheSet.js");
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;

/***/ }),

/***/ "./node_modules/lodash/_Promise.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_Promise.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var Promise = getNative(root, 'Promise');
module.exports = Promise;

/***/ }),

/***/ "./node_modules/lodash/_Set.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Set.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var Set = getNative(root, 'Set');
module.exports = Set;

/***/ }),

/***/ "./node_modules/lodash/_SetCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_SetCache.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js"),
    setCacheAdd = __webpack_require__(/*! ./_setCacheAdd */ "./node_modules/lodash/_setCacheAdd.js"),
    setCacheHas = __webpack_require__(/*! ./_setCacheHas */ "./node_modules/lodash/_setCacheHas.js");
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */


function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
module.exports = SetCache;

/***/ }),

/***/ "./node_modules/lodash/_Stack.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_Stack.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__(/*! ./_stackClear */ "./node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__(/*! ./_stackDelete */ "./node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__(/*! ./_stackGet */ "./node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__(/*! ./_stackHas */ "./node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__(/*! ./_stackSet */ "./node_modules/lodash/_stackSet.js");
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
module.exports = Stack;

/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/** Built-in value references. */


var _Symbol = root.Symbol;
module.exports = _Symbol;

/***/ }),

/***/ "./node_modules/lodash/_Uint8Array.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_Uint8Array.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/** Built-in value references. */


var Uint8Array = root.Uint8Array;
module.exports = Uint8Array;

/***/ }),

/***/ "./node_modules/lodash/_WeakMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_WeakMap.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var WeakMap = getNative(root, 'WeakMap');
module.exports = WeakMap;

/***/ }),

/***/ "./node_modules/lodash/_apply.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_apply.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

module.exports = apply;

/***/ }),

/***/ "./node_modules/lodash/_arrayEach.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayEach.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

module.exports = arrayEach;

/***/ }),

/***/ "./node_modules/lodash/_arrayFilter.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayFilter.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

module.exports = arrayFilter;

/***/ }),

/***/ "./node_modules/lodash/_arrayIncludes.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayIncludes.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf = __webpack_require__(/*! ./_baseIndexOf */ "./node_modules/lodash/_baseIndexOf.js");
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */


function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;

/***/ }),

/***/ "./node_modules/lodash/_arrayIncludesWith.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash/_arrayIncludesWith.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }

  return false;
}

module.exports = arrayIncludesWith;

/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = arrayLikeKeys;

/***/ }),

/***/ "./node_modules/lodash/_arrayMap.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_arrayMap.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

module.exports = arrayMap;

/***/ }),

/***/ "./node_modules/lodash/_arrayPush.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayPush.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

module.exports = arrayPush;

/***/ }),

/***/ "./node_modules/lodash/_arrayReduce.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayReduce.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }

  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }

  return accumulator;
}

module.exports = arrayReduce;

/***/ }),

/***/ "./node_modules/lodash/_arraySome.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arraySome.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

module.exports = arraySome;

/***/ }),

/***/ "./node_modules/lodash/_asciiSize.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_asciiSize.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseProperty = __webpack_require__(/*! ./_baseProperty */ "./node_modules/lodash/_baseProperty.js");
/**
 * Gets the size of an ASCII `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */


var asciiSize = baseProperty('length');
module.exports = asciiSize;

/***/ }),

/***/ "./node_modules/lodash/_assignValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_assignValue.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

/***/ }),

/***/ "./node_modules/lodash/_assocIndexOf.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_assocIndexOf.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

module.exports = assocIndexOf;

/***/ }),

/***/ "./node_modules/lodash/_baseAssign.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseAssign.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

/***/ }),

/***/ "./node_modules/lodash/_baseAssignIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseAssignIn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");
/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

/***/ }),

/***/ "./node_modules/lodash/_baseAssignValue.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseAssignValue.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js");
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

/***/ }),

/***/ "./node_modules/lodash/_baseClone.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseClone.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssign = __webpack_require__(/*! ./_baseAssign */ "./node_modules/lodash/_baseAssign.js"),
    baseAssignIn = __webpack_require__(/*! ./_baseAssignIn */ "./node_modules/lodash/_baseAssignIn.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"),
    copySymbols = __webpack_require__(/*! ./_copySymbols */ "./node_modules/lodash/_copySymbols.js"),
    copySymbolsIn = __webpack_require__(/*! ./_copySymbolsIn */ "./node_modules/lodash/_copySymbolsIn.js"),
    getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js"),
    getAllKeysIn = __webpack_require__(/*! ./_getAllKeysIn */ "./node_modules/lodash/_getAllKeysIn.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    initCloneArray = __webpack_require__(/*! ./_initCloneArray */ "./node_modules/lodash/_initCloneArray.js"),
    initCloneByTag = __webpack_require__(/*! ./_initCloneByTag */ "./node_modules/lodash/_initCloneByTag.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isMap = __webpack_require__(/*! ./isMap */ "./node_modules/lodash/isMap.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSet = __webpack_require__(/*! ./isSet */ "./node_modules/lodash/isSet.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
/** Used to compose bitmasks for cloning. */


var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values supported by `_.clone`. */

var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */

function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }

  if (result !== undefined) {
    return result;
  }

  if (!isObject(value)) {
    return value;
  }

  var isArr = isArray(value);

  if (isArr) {
    result = initCloneArray(value);

    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }

    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);

      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }

      result = initCloneByTag(value, tag, isDeep);
    }
  } // Check for circular references and return its corresponding clone.


  stack || (stack = new Stack());
  var stacked = stack.get(value);

  if (stacked) {
    return stacked;
  }

  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function (subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function (subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function (subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    } // Recursively populate clone (susceptible to call stack limits).


    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

/***/ }),

/***/ "./node_modules/lodash/_baseCreate.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseCreate.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");
/** Built-in value references. */


var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

module.exports = baseCreate;

/***/ }),

/***/ "./node_modules/lodash/_baseEach.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseEach.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    createBaseEach = __webpack_require__(/*! ./_createBaseEach */ "./node_modules/lodash/_createBaseEach.js");
/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */


var baseEach = createBaseEach(baseForOwn);
module.exports = baseEach;

/***/ }),

/***/ "./node_modules/lodash/_baseFilter.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseFilter.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js");
/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */


function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function (value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

module.exports = baseFilter;

/***/ }),

/***/ "./node_modules/lodash/_baseFindIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseFindIndex.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }

  return -1;
}

module.exports = baseFindIndex;

/***/ }),

/***/ "./node_modules/lodash/_baseFlatten.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseFlatten.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isFlattenable = __webpack_require__(/*! ./_isFlattenable */ "./node_modules/lodash/_isFlattenable.js");
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */


function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];

    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }

  return result;
}

module.exports = baseFlatten;

/***/ }),

/***/ "./node_modules/lodash/_baseFor.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseFor.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(/*! ./_createBaseFor */ "./node_modules/lodash/_createBaseFor.js");
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */


var baseFor = createBaseFor();
module.exports = baseFor;

/***/ }),

/***/ "./node_modules/lodash/_baseForOwn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseForOwn.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */


function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

/***/ }),

/***/ "./node_modules/lodash/_baseGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseGet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */


function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

module.exports = baseGet;

/***/ }),

/***/ "./node_modules/lodash/_baseGetAllKeys.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_baseGetAllKeys.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */


function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),

/***/ "./node_modules/lodash/_baseHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseHas.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */

function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;

/***/ }),

/***/ "./node_modules/lodash/_baseHasIn.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseHasIn.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

/***/ }),

/***/ "./node_modules/lodash/_baseIndexOf.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIndexOf.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"),
    baseIsNaN = __webpack_require__(/*! ./_baseIsNaN */ "./node_modules/lodash/_baseIsNaN.js"),
    strictIndexOf = __webpack_require__(/*! ./_strictIndexOf */ "./node_modules/lodash/_strictIndexOf.js");
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),

/***/ "./node_modules/lodash/_baseIsEqual.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsEqual.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqualDeep = __webpack_require__(/*! ./_baseIsEqualDeep */ "./node_modules/lodash/_baseIsEqualDeep.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */


function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

/***/ }),

/***/ "./node_modules/lodash/_baseIsEqualDeep.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsEqualDeep.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    equalByTag = __webpack_require__(/*! ./_equalByTag */ "./node_modules/lodash/_equalByTag.js"),
    equalObjects = __webpack_require__(/*! ./_equalObjects */ "./node_modules/lodash/_equalObjects.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

/***/ }),

/***/ "./node_modules/lodash/_baseIsMap.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsMap.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var mapTag = '[object Map]';
/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */

function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;

/***/ }),

/***/ "./node_modules/lodash/_baseIsMatch.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsMatch.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

module.exports = baseIsMatch;

/***/ }),

/***/ "./node_modules/lodash/_baseIsNaN.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsNaN.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

/***/ }),

/***/ "./node_modules/lodash/_baseIsNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */


var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

/***/ }),

/***/ "./node_modules/lodash/_baseIsSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsSet.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var setTag = '[object Set]';
/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */

function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;

/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),

/***/ "./node_modules/lodash/_baseIteratee.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIteratee.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var baseMatches = __webpack_require__(/*! ./_baseMatches */ "./node_modules/lodash/_baseMatches.js"),
    baseMatchesProperty = __webpack_require__(/*! ./_baseMatchesProperty */ "./node_modules/lodash/_baseMatchesProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    property = __webpack_require__(/*! ./property */ "./node_modules/lodash/property.js");
/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */


function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return identity;
  }

  if (_typeof(value) == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }

  return property(value);
}

module.exports = baseIteratee;

/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeys;

/***/ }),

/***/ "./node_modules/lodash/_baseKeysIn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseKeysIn.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ "./node_modules/lodash/_nativeKeysIn.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeysIn;

/***/ }),

/***/ "./node_modules/lodash/_baseMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseMap.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");
/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */


function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach(collection, function (value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;

/***/ }),

/***/ "./node_modules/lodash/_baseMatches.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseMatches.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMatch = __webpack_require__(/*! ./_baseIsMatch */ "./node_modules/lodash/_baseIsMatch.js"),
    getMatchData = __webpack_require__(/*! ./_getMatchData */ "./node_modules/lodash/_getMatchData.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js");
/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */


function baseMatches(source) {
  var matchData = getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

/***/ }),

/***/ "./node_modules/lodash/_baseMatchesProperty.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash/_baseMatchesProperty.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js"),
    get = __webpack_require__(/*! ./get */ "./node_modules/lodash/get.js"),
    hasIn = __webpack_require__(/*! ./hasIn */ "./node_modules/lodash/hasIn.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }

  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

/***/ }),

/***/ "./node_modules/lodash/_baseProperty.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseProperty.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

/***/ }),

/***/ "./node_modules/lodash/_basePropertyDeep.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_basePropertyDeep.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");
/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */


function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

/***/ }),

/***/ "./node_modules/lodash/_baseReduce.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseReduce.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function (value, index, collection) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

module.exports = baseReduce;

/***/ }),

/***/ "./node_modules/lodash/_baseRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseRest.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "./node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "./node_modules/lodash/_setToString.js");
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */


function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

/***/ }),

/***/ "./node_modules/lodash/_baseSetToString.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseSetToString.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(/*! ./constant */ "./node_modules/lodash/constant.js"),
    defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");
/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};
module.exports = baseSetToString;

/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

module.exports = baseTimes;

/***/ }),

/***/ "./node_modules/lodash/_baseToString.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseToString.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = baseToString;

/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),

/***/ "./node_modules/lodash/_baseUniq.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseUniq.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arrayIncludes = __webpack_require__(/*! ./_arrayIncludes */ "./node_modules/lodash/_arrayIncludes.js"),
    arrayIncludesWith = __webpack_require__(/*! ./_arrayIncludesWith */ "./node_modules/lodash/_arrayIncludesWith.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js"),
    createSet = __webpack_require__(/*! ./_createSet */ "./node_modules/lodash/_createSet.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */

function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);

    if (set) {
      return setToArray(set);
    }

    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }

  outer: while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;
    value = comparator || value !== 0 ? value : 0;

    if (isCommon && computed === computed) {
      var seenIndex = seen.length;

      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }

      if (iteratee) {
        seen.push(computed);
      }

      result.push(value);
    } else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }

      result.push(value);
    }
  }

  return result;
}

module.exports = baseUniq;

/***/ }),

/***/ "./node_modules/lodash/_baseValues.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseValues.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js");
/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */


function baseValues(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

module.exports = baseValues;

/***/ }),

/***/ "./node_modules/lodash/_cacheHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_cacheHas.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

/***/ }),

/***/ "./node_modules/lodash/_castFunction.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_castFunction.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");
/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */


function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;

/***/ }),

/***/ "./node_modules/lodash/_castPath.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_castPath.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    stringToPath = __webpack_require__(/*! ./_stringToPath */ "./node_modules/lodash/_stringToPath.js"),
    toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */


function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

/***/ }),

/***/ "./node_modules/lodash/_cloneArrayBuffer.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_cloneArrayBuffer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js");
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */


function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

/***/ }),

/***/ "./node_modules/lodash/_cloneBuffer.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneBuffer.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/** Detect free variable `exports`. */


var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/_cloneDataView.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_cloneDataView.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");
/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */


function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

/***/ }),

/***/ "./node_modules/lodash/_cloneRegExp.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneRegExp.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */

function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

/***/ }),

/***/ "./node_modules/lodash/_cloneSymbol.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneSymbol.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");
/** Used to convert symbols to primitives and strings. */


var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */

function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

/***/ }),

/***/ "./node_modules/lodash/_cloneTypedArray.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_cloneTypedArray.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */


function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

/***/ }),

/***/ "./node_modules/lodash/_copyArray.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_copyArray.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

module.exports = copyArray;

/***/ }),

/***/ "./node_modules/lodash/_copyObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_copyObject.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js");
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */


function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

module.exports = copyObject;

/***/ }),

/***/ "./node_modules/lodash/_copySymbols.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_copySymbols.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js");
/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

/***/ }),

/***/ "./node_modules/lodash/_copySymbolsIn.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_copySymbolsIn.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js");
/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

/***/ }),

/***/ "./node_modules/lodash/_coreJsData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/** Used to detect overreaching core-js shims. */


var coreJsData = root['__core-js_shared__'];
module.exports = coreJsData;

/***/ }),

/***/ "./node_modules/lodash/_createBaseEach.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_createBaseEach.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");
/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */


function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }

    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }

    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }

    return collection;
  };
}

module.exports = createBaseEach;

/***/ }),

/***/ "./node_modules/lodash/_createBaseFor.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_createBaseFor.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

module.exports = createBaseFor;

/***/ }),

/***/ "./node_modules/lodash/_createSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_createSet.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    noop = __webpack_require__(/*! ./noop */ "./node_modules/lodash/noop.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */

var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
  return new Set(values);
};
module.exports = createSet;

/***/ }),

/***/ "./node_modules/lodash/_defineProperty.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_defineProperty.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

module.exports = defineProperty;

/***/ }),

/***/ "./node_modules/lodash/_equalArrays.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_equalArrays.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arraySome = __webpack_require__(/*! ./_arraySome */ "./node_modules/lodash/_arraySome.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Assume cyclic values are equal.


  var stacked = stack.get(array);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

/***/ }),

/***/ "./node_modules/lodash/_equalByTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_equalByTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    mapToArray = __webpack_require__(/*! ./_mapToArray */ "./node_modules/lodash/_mapToArray.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/** `Object#toString` result references. */

var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

module.exports = equalByTag;

/***/ }),

/***/ "./node_modules/lodash/_equalObjects.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_equalObjects.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1;
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  } // Assume cyclic values are equal.


  var stacked = stack.get(object);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;
module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash/_getAllKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getAllKeys.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

/***/ }),

/***/ "./node_modules/lodash/_getAllKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getAllKeysIn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");
/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

/***/ }),

/***/ "./node_modules/lodash/_getMapData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getMapData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "./node_modules/lodash/_isKeyable.js");
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

module.exports = getMapData;

/***/ }),

/***/ "./node_modules/lodash/_getMatchData.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getMatchData.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */


function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }

  return result;
}

module.exports = getMatchData;

/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "./node_modules/lodash/_getValue.js");
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

/***/ }),

/***/ "./node_modules/lodash/_getPrototype.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");
/** Built-in value references. */


var getPrototype = overArg(Object.getPrototypeOf, Object);
module.exports = getPrototype;

/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

module.exports = getRawTag;

/***/ }),

/***/ "./node_modules/lodash/_getSymbols.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getSymbols.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
module.exports = getSymbols;

/***/ }),

/***/ "./node_modules/lodash/_getSymbolsIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getSymbolsIn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
  var result = [];

  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }

  return result;
};
module.exports = getSymbolsIn;

/***/ }),

/***/ "./node_modules/lodash/_getTag.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(/*! ./_DataView */ "./node_modules/lodash/_DataView.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    Promise = __webpack_require__(/*! ./_Promise */ "./node_modules/lodash/_Promise.js"),
    Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    WeakMap = __webpack_require__(/*! ./_WeakMap */ "./node_modules/lodash/_WeakMap.js"),
    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';
var dataViewTag = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function getTag(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;

        case mapCtorString:
          return mapTag;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag;

        case weakMapCtorString:
          return weakMapTag;
      }
    }

    return result;
  };
}

module.exports = getTag;

/***/ }),

/***/ "./node_modules/lodash/_getValue.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

/***/ }),

/***/ "./node_modules/lodash/_hasPath.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hasPath.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");
/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */


function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

module.exports = hasPath;

/***/ }),

/***/ "./node_modules/lodash/_hasUnicode.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hasUnicode.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = "\\ud800-\\udfff",
    rsComboMarksRange = "\\u0300-\\u036f",
    reComboHalfMarksRange = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange = "\\u20d0-\\u20ff",
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = "\\ufe0e\\ufe0f";
/** Used to compose unicode capture groups. */

var rsZWJ = "\\u200d";
/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */

var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */

function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;

/***/ }),

/***/ "./node_modules/lodash/_hashClear.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_hashClear.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */


function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

/***/ }),

/***/ "./node_modules/lodash/_hashDelete.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hashDelete.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

/***/ }),

/***/ "./node_modules/lodash/_hashGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashGet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

/***/ }),

/***/ "./node_modules/lodash/_hashHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashHas.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

/***/ }),

/***/ "./node_modules/lodash/_hashSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashSet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

/***/ }),

/***/ "./node_modules/lodash/_initCloneArray.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneArray.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */

function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }

  return result;
}

module.exports = initCloneArray;

/***/ }),

/***/ "./node_modules/lodash/_initCloneByTag.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneByTag.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js"),
    cloneDataView = __webpack_require__(/*! ./_cloneDataView */ "./node_modules/lodash/_cloneDataView.js"),
    cloneRegExp = __webpack_require__(/*! ./_cloneRegExp */ "./node_modules/lodash/_cloneRegExp.js"),
    cloneSymbol = __webpack_require__(/*! ./_cloneSymbol */ "./node_modules/lodash/_cloneSymbol.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js");
/** `Object#toString` result references. */


var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;

  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag:
    case float64Tag:
    case int8Tag:
    case int16Tag:
    case int32Tag:
    case uint8Tag:
    case uint8ClampedTag:
    case uint16Tag:
    case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor();

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor();

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

/***/ }),

/***/ "./node_modules/lodash/_initCloneObject.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_initCloneObject.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js");
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */


function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

module.exports = initCloneObject;

/***/ }),

/***/ "./node_modules/lodash/_isFlattenable.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_isFlattenable.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");
/** Built-in value references. */


var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */

function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = _typeof(value);

  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),

/***/ "./node_modules/lodash/_isKey.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_isKey.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");
/** Used to match property names within property paths. */


var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = _typeof(value);

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

module.exports = isKey;

/***/ }),

/***/ "./node_modules/lodash/_isKeyable.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_isKeyable.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = _typeof(value);

  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

module.exports = isKeyable;

/***/ }),

/***/ "./node_modules/lodash/_isMasked.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js");
/** Used to detect methods masquerading as native. */


var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;

/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

module.exports = isPrototype;

/***/ }),

/***/ "./node_modules/lodash/_isStrictComparable.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash/_isStrictComparable.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");
/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */


function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

/***/ }),

/***/ "./node_modules/lodash/_listCacheClear.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_listCacheClear.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

/***/ }),

/***/ "./node_modules/lodash/_listCacheDelete.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_listCacheDelete.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
/** Used for built-in method references. */


var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

module.exports = listCacheDelete;

/***/ }),

/***/ "./node_modules/lodash/_listCacheGet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheGet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

/***/ }),

/***/ "./node_modules/lodash/_listCacheHas.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheHas.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

/***/ }),

/***/ "./node_modules/lodash/_listCacheSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheSet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

module.exports = listCacheSet;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheClear.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_mapCacheClear.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(/*! ./_Hash */ "./node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js");
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */


function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

module.exports = mapCacheClear;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheDelete.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_mapCacheDelete.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheGet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheGet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheHas.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheSet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheSet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

/***/ }),

/***/ "./node_modules/lodash/_mapToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_mapToArray.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

/***/ }),

/***/ "./node_modules/lodash/_matchesStrictComparable.js":
/*!*********************************************************!*\
  !*** ./node_modules/lodash/_matchesStrictComparable.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

module.exports = matchesStrictComparable;

/***/ }),

/***/ "./node_modules/lodash/_memoizeCapped.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_memoizeCapped.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(/*! ./memoize */ "./node_modules/lodash/memoize.js");
/** Used as the maximum memoize cache size. */


var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

/***/ }),

/***/ "./node_modules/lodash/_nativeCreate.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeCreate.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");
/* Built-in method references that are verified to be native. */


var nativeCreate = getNative(Object, 'create');
module.exports = nativeCreate;

/***/ }),

/***/ "./node_modules/lodash/_nativeKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeKeys = overArg(Object.keys, Object);
module.exports = nativeKeys;

/***/ }),

/***/ "./node_modules/lodash/_nativeKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeKeysIn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

module.exports = nativeKeysIn;

/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");
/** Detect free variable `exports`. */


var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),

/***/ "./node_modules/lodash/_overRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_overRest.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(/*! ./_apply */ "./node_modules/lodash/_apply.js");
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");
/** Detect free variable `self`. */


var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

/***/ }),

/***/ "./node_modules/lodash/_setCacheAdd.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheAdd.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);

  return this;
}

module.exports = setCacheAdd;

/***/ }),

/***/ "./node_modules/lodash/_setCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheHas.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

/***/ }),

/***/ "./node_modules/lodash/_setToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_setToArray.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

/***/ }),

/***/ "./node_modules/lodash/_setToString.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setToString.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(/*! ./_baseSetToString */ "./node_modules/lodash/_baseSetToString.js"),
    shortOut = __webpack_require__(/*! ./_shortOut */ "./node_modules/lodash/_shortOut.js");
/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var setToString = shortOut(baseSetToString);
module.exports = setToString;

/***/ }),

/***/ "./node_modules/lodash/_shortOut.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_shortOut.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

/***/ }),

/***/ "./node_modules/lodash/_stackClear.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stackClear.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js");
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */


function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

module.exports = stackClear;

/***/ }),

/***/ "./node_modules/lodash/_stackDelete.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_stackDelete.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

module.exports = stackDelete;

/***/ }),

/***/ "./node_modules/lodash/_stackGet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackGet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

/***/ }),

/***/ "./node_modules/lodash/_stackHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackHas.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

/***/ }),

/***/ "./node_modules/lodash/_stackSet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackSet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

/***/ }),

/***/ "./node_modules/lodash/_strictIndexOf.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_strictIndexOf.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }

  return -1;
}

module.exports = strictIndexOf;

/***/ }),

/***/ "./node_modules/lodash/_stringSize.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stringSize.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var asciiSize = __webpack_require__(/*! ./_asciiSize */ "./node_modules/lodash/_asciiSize.js"),
    hasUnicode = __webpack_require__(/*! ./_hasUnicode */ "./node_modules/lodash/_hasUnicode.js"),
    unicodeSize = __webpack_require__(/*! ./_unicodeSize */ "./node_modules/lodash/_unicodeSize.js");
/**
 * Gets the number of symbols in `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */


function stringSize(string) {
  return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
}

module.exports = stringSize;

/***/ }),

/***/ "./node_modules/lodash/_stringToPath.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_stringToPath.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(/*! ./_memoizeCapped */ "./node_modules/lodash/_memoizeCapped.js");
/** Used to match property names within property paths. */


var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
      result.push('');
    }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
module.exports = stringToPath;

/***/ }),

/***/ "./node_modules/lodash/_toKey.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_toKey.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = toKey;

/***/ }),

/***/ "./node_modules/lodash/_toSource.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

module.exports = toSource;

/***/ }),

/***/ "./node_modules/lodash/_unicodeSize.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_unicodeSize.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = "\\ud800-\\udfff",
    rsComboMarksRange = "\\u0300-\\u036f",
    reComboHalfMarksRange = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange = "\\u20d0-\\u20ff",
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = "\\ufe0e\\ufe0f";
/** Used to compose unicode capture groups. */

var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = "\\ud83c[\\udffb-\\udfff]",
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
    rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
    rsZWJ = "\\u200d";
/** Used to compose unicode regexes. */

var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
/**
 * Gets the size of a Unicode `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */

function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;

  while (reUnicode.test(string)) {
    ++result;
  }

  return result;
}

module.exports = unicodeSize;

/***/ }),

/***/ "./node_modules/lodash/clone.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/clone.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseClone = __webpack_require__(/*! ./_baseClone */ "./node_modules/lodash/_baseClone.js");
/** Used to compose bitmasks for cloning. */


var CLONE_SYMBOLS_FLAG = 4;
/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */

function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;

/***/ }),

/***/ "./node_modules/lodash/constant.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/constant.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

module.exports = constant;

/***/ }),

/***/ "./node_modules/lodash/each.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/each.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./forEach */ "./node_modules/lodash/forEach.js");

/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

module.exports = eq;

/***/ }),

/***/ "./node_modules/lodash/filter.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/filter.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    baseFilter = __webpack_require__(/*! ./_baseFilter */ "./node_modules/lodash/_baseFilter.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");
/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 */


function filter(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = filter;

/***/ }),

/***/ "./node_modules/lodash/forEach.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/forEach.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    castFunction = __webpack_require__(/*! ./_castFunction */ "./node_modules/lodash/_castFunction.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");
/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */


function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;

/***/ }),

/***/ "./node_modules/lodash/get.js":
/*!************************************!*\
  !*** ./node_modules/lodash/get.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");
/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */


function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

/***/ }),

/***/ "./node_modules/lodash/has.js":
/*!************************************!*\
  !*** ./node_modules/lodash/has.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseHas = __webpack_require__(/*! ./_baseHas */ "./node_modules/lodash/_baseHas.js"),
    hasPath = __webpack_require__(/*! ./_hasPath */ "./node_modules/lodash/_hasPath.js");
/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */


function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;

/***/ }),

/***/ "./node_modules/lodash/hasIn.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/hasIn.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(/*! ./_baseHasIn */ "./node_modules/lodash/_baseHasIn.js"),
    hasPath = __webpack_require__(/*! ./_hasPath */ "./node_modules/lodash/_hasPath.js");
/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */


function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

/***/ }),

/***/ "./node_modules/lodash/identity.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/identity.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;

/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
module.exports = isArray;

/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */


function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),

/***/ "./node_modules/lodash/isArrayLikeObject.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/isArrayLikeObject.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */


function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");
/** Detect free variable `exports`. */


var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/isEmpty.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isEmpty.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    setTag = '[object Set]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */

function isEmpty(value) {
  if (value == null) {
    return true;
  }

  if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }

  var tag = getTag(value);

  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }

  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }

  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }

  return true;
}

module.exports = isEmpty;

/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");
/** `Object#toString` result references. */


var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),

/***/ "./node_modules/lodash/isMap.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isMap.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMap = __webpack_require__(/*! ./_baseIsMap */ "./node_modules/lodash/_baseIsMap.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");
/* Node.js helper references. */


var nodeIsMap = nodeUtil && nodeUtil.isMap;
/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */

var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
module.exports = isMap;

/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = _typeof(value);

  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && _typeof(value) == 'object';
}

module.exports = isObjectLike;

/***/ }),

/***/ "./node_modules/lodash/isSet.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isSet.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsSet = __webpack_require__(/*! ./_baseIsSet */ "./node_modules/lodash/_baseIsSet.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");
/* Node.js helper references. */


var nodeIsSet = nodeUtil && nodeUtil.isSet;
/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */

var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
module.exports = isSet;

/***/ }),

/***/ "./node_modules/lodash/isString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isString.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var stringTag = '[object String]';
/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */

function isString(value) {
  return typeof value == 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
}

module.exports = isString;

/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return _typeof(value) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");
/* Node.js helper references. */


var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;

/***/ }),

/***/ "./node_modules/lodash/isUndefined.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isUndefined.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

module.exports = isUndefined;

/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */


function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

/***/ }),

/***/ "./node_modules/lodash/keysIn.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/keysIn.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ "./node_modules/lodash/_baseKeysIn.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */


function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

/***/ }),

/***/ "./node_modules/lodash/lodash.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/lodash.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */;(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined;/** Used as the semantic version number. */var VERSION='4.17.15';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading and trailing whitespace. */var reTrim=/^\s+|\s+$/g,reTrimStart=/^\s+/,reTrimEnd=/\s+$/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange="\\ud800-\\udfff",rsComboMarksRange="\\u0300-\\u036f",reComboHalfMarksRange="\\ufe20-\\ufe2f",rsComboSymbolsRange="\\u20d0-\\u20ff",rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange="\\u2700-\\u27bf",rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange="\\u2000-\\u206f",rsSpaceRange=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange="\\ufe0e\\ufe0f",rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz="\\ud83c[\\udffb-\\udfff]",rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional="(?:\\ud83c[\\udde6-\\uddff]){2}",rsSurrPair="[\\ud800-\\udbff][\\udc00-\\udfff]",rsUpper='['+rsUpperRange+']',rsZWJ="\\u200d";/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
"\u0100":'A',"\u0102":'A',"\u0104":'A',"\u0101":'a',"\u0103":'a',"\u0105":'a',"\u0106":'C',"\u0108":'C',"\u010A":'C',"\u010C":'C',"\u0107":'c',"\u0109":'c',"\u010B":'c',"\u010D":'c',"\u010E":'D',"\u0110":'D',"\u010F":'d',"\u0111":'d',"\u0112":'E',"\u0114":'E',"\u0116":'E',"\u0118":'E',"\u011A":'E',"\u0113":'e',"\u0115":'e',"\u0117":'e',"\u0119":'e',"\u011B":'e',"\u011C":'G',"\u011E":'G',"\u0120":'G',"\u0122":'G',"\u011D":'g',"\u011F":'g',"\u0121":'g',"\u0123":'g',"\u0124":'H',"\u0126":'H',"\u0125":'h',"\u0127":'h',"\u0128":'I',"\u012A":'I',"\u012C":'I',"\u012E":'I',"\u0130":'I',"\u0129":'i',"\u012B":'i',"\u012D":'i',"\u012F":'i',"\u0131":'i',"\u0134":'J',"\u0135":'j',"\u0136":'K',"\u0137":'k',"\u0138":'k',"\u0139":'L',"\u013B":'L',"\u013D":'L',"\u013F":'L',"\u0141":'L',"\u013A":'l',"\u013C":'l',"\u013E":'l',"\u0140":'l',"\u0142":'l',"\u0143":'N',"\u0145":'N',"\u0147":'N',"\u014A":'N',"\u0144":'n',"\u0146":'n',"\u0148":'n',"\u014B":'n',"\u014C":'O',"\u014E":'O',"\u0150":'O',"\u014D":'o',"\u014F":'o',"\u0151":'o',"\u0154":'R',"\u0156":'R',"\u0158":'R',"\u0155":'r',"\u0157":'r',"\u0159":'r',"\u015A":'S',"\u015C":'S',"\u015E":'S',"\u0160":'S',"\u015B":'s',"\u015D":'s',"\u015F":'s',"\u0161":'s',"\u0162":'T',"\u0164":'T',"\u0166":'T',"\u0163":'t',"\u0165":'t',"\u0167":'t',"\u0168":'U',"\u016A":'U',"\u016C":'U',"\u016E":'U',"\u0170":'U',"\u0172":'U',"\u0169":'u',"\u016B":'u',"\u016D":'u',"\u016F":'u',"\u0171":'u',"\u0173":'u',"\u0174":'W',"\u0175":'w',"\u0176":'Y',"\u0177":'y',"\u0178":'Y',"\u0179":'Z',"\u017B":'Z',"\u017D":'Z',"\u017A":'z',"\u017C":'z',"\u017E":'z',"\u0132":'IJ',"\u0133":'ij',"\u0152":'Oe',"\u0153":'oe',"\u0149":"'n","\u017F":'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r',"\u2028":'u2028',"\u2029":'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=(typeof global==="undefined"?"undefined":_typeof(global))=='object'&&global&&global.Object===Object&&global;/** Detect free variable `self`. */var freeSelf=(typeof self==="undefined"?"undefined":_typeof(self))=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=( false?undefined:_typeof(exports))=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&( false?undefined:_typeof(module))=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*/ /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}/**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */var asciiSize=baseProperty('length');/**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function asciiToArray(string){return string.split('');}/**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}/**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}/**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */function baseIsNaN(value){return value!==value;}/**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */function basePropertyOf(object){return function(key){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined){result=result===undefined?current:result+current;}}return result;}/**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */function baseToPairs(object,props){return arrayMap(props,function(key){return[key,object[key]];});}/**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */function baseUnary(func){return function(value){return func(value);};}/**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */function cacheHas(cache,key){return cache.has(key);}/**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */var deburrLetter=basePropertyOf(deburredLetters);/**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */function escapeStringChar(chr){return'\\'+stringEscapes[chr];}/**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */function getValue(object,key){return object==null?undefined:object[key];}/**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */function hasUnicode(string){return reHasUnicode.test(string);}/**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}/**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*/ /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined,_Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=_Symbol?_Symbol.isConcatSpreadable:undefined,symIterator=_Symbol?_Symbol.iterator:undefined,symToStringTag=_Symbol?_Symbol.toStringTag:undefined;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol?_Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();/**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */function baseLodash(){}// No operation performed.
/**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined;}/**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */lodash.templateSettings={/**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'escape':reEscape,/**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'evaluate':reEvaluate,/**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'interpolate':reInterpolate,/**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */'variable':'',/**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */'imports':{/**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else{result=this.clone();result.__dir__*=-1;}return result;}/**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else{break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*/ /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */function listCacheClear(){this.__data__=[];this.size=0;}/**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}/**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*/ /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*/ /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*/ /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function stackGet(key){return this.__data__.get(key);}/**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function stackHas(key){return this.__data__.has(key);}/**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*/ /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}/**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined;}/**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}/**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined:get(object,paths[index]);}return result;}/**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}/**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return!length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined&&!(key in object)||!predicate(value)){return false;}}return true;}/**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined,args);},wait);}/**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEach=createBaseEach(baseForOwn);/**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
baseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseFor=createBaseFor();/**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseForRight=createBaseFor(true);/**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}/**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */function baseGt(value,other){return value>other;}/**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined:apply(func,object,args);}/**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
if(typeof value=='function'){return value;}if(value==null){return identity;}if(_typeof(value)=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */function baseLt(value,other){return value<other;}/**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else{newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined;}/**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */function baseOrderBy(collection,iteratees,orders){var index=-1;iteratees=arrayMap(iteratees.length?iteratees:[identity],baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else{baseUnset(array,index);}}}return array;}/**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */function baseSample(collection){return arraySample(values(collection));}/**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return!result;});return!!result;}/**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else{high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndexBy(array,value,iteratee,retHighest){value=iteratee(value);var low=0,high=array==null?0:array.length,valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else{setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else{high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return+value;}/**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined;assignFunc(result,props[index],value);}return result;}/**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */function castFunction(value){return typeof value=='function'?value:identity;}/**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */var castRest=baseRest;/**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */function castSlice(array,start,end){var length=array.length;end=end===undefined?length:end;return!start&&end>=length?array:baseSlice(array,start,end);}/**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}/**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
// that causes it, under certain circumstances, to provide the same value for
// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
// for more details.
//
// This also ensures a stable sort in V8 and other engines.
// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
return object.index-other.index;}/**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}/**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
// for more details.
var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
// See https://es5.github.io/#x13.2.2 for more details.
return isObject(result)?result:thisBinding;};}/**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function predicate(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined;};}/**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined&&other===undefined){return defaultValue;}if(value!==undefined){result=value;}if(other!==undefined){if(result===undefined){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else{value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */function createPadding(length,chars){chars=chars===undefined?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined;}// Ensure the sign of `-0` is preserved.
start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}step=step===undefined?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision&&nativeIsFinite(number)){// Shift with exponential notation to avoid floating-point issues.
// See [MDN](https://mdn.io/round#Examples) for more details.
var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return+(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else{result=createHybrid.apply(undefined,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */function customOmitClone(value){return isPlainObject(value)?undefined:value;}/**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Assume cyclic values are equal.
var stacked=stack.get(array);if(stacked&&stack.get(other)){return stacked==other;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
// Invalid dates are coerced to `NaN`.
return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
// for more details.
return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked&&stack.get(other)){return stacked==other;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */function flatRest(func){return setToString(overRest(func,undefined,flatten),func+'');}/**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}/**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return[];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function getTag(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return{'start':start,'end':end};}/**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */function isIndex(value,length){var type=_typeof(value);length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=_typeof(index);if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */function isKey(value,object){if(isArray(value)){return false;}var type=_typeof(value);if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */function isKeyable(value){var type=_typeof(value);return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return!!data&&func===data[0];}/**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */var isMaskable=coreJsData?isFunction:stubFalse;/**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}/**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
data[0]=source[0];data[1]=newBitmask;return data;}/**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */function objectToString(value){return nativeObjectToString.call(value);}/**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}/**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var setData=shortOut(baseSetData);/**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var setToString=shortOut(baseSetToString);/**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}/**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*/ /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined){size=1;}else{size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return[];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */function concat(){var length=arguments.length;if(!length){return[];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined,comparator):[];});/**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return[];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length-1;if(fromIndex!==undefined){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return[];}depth=depth===undefined?1:toInteger(depth);return baseFlatten(array,depth);}/**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */function head(array){return array&&array.length?array[0]:undefined;}/**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined,comparator):[];});/**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined;}/**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length;if(fromIndex!==undefined){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined;}/**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */var pull=baseRest(pullAll);/**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined,comparator):array;}/**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}/**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */function take(array,n,guard){if(!(array&&array.length)){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined,comparator);});/**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined;return array&&array.length?baseUniq(array,undefined,comparator):[];}/**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}/**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined,comparator);});/**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */var zip=baseRest(unzip);/**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */function tap(value,interceptor){interceptor(value);return value;}/**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */function thru(value,interceptor){return interceptor(value);}/**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function interceptor(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined);}return array;});});/**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */function wrapperChain(){return chain(this);}/**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */function wrapperNext(){if(this.__values__===undefined){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined:this.__values__[this.__index__++];return{'done':done,'value':value};}/**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */function wrapperToIterator(){return this;}/**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined;if(result){previous.__wrapped__=clone;}else{result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*/ /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else{baseAssignValue(result,key,1);}});/**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */var find=createFind(findIndex);/**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */var findLast=createFind(findLastIndex);/**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{baseAssignValue(result,key,[value]);}});/**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return[];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});/**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined){n=1;}else{n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*/ /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*/ /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined,undefined,undefined,undefined,n);}/**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}/**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}/**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}/**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function memoized(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
memoize.Cache=MapCache;/**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}/**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */function once(func){return before(2,func);}/**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined,partials,holders);});/**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined,partials,holders);});/**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined,undefined,undefined,indexes);});/**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined?start:toInteger(start);return baseRest(func,start);}/**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */function unary(func){return ary(func,1);}/**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*/ /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}/**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */var gt=createRelationalOperation(baseGt);/**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */var isArray=Array.isArray;/**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */var isBuffer=nativeIsBuffer||stubFalse;/**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return!value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}if(isPrototype(value)){return!baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */function isEqual(value,other){return baseIsEqual(value,other);}/**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined;var result=customizer?customizer(value,other):undefined;return result===undefined?baseIsEqual(value,other,undefined,customizer):!!result;}/**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */function isObject(value){var type=_typeof(value);return value!=null&&(type=='object'||type=='function');}/**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */function isObjectLike(value){return value!=null&&_typeof(value)=='object';}/**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
// Perform the `toStringTag` check first to avoid errors with some
// ActiveX objects in IE.
return isNumber(value)&&value!=+value;}/**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */function isNull(value){return value===null;}/**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */function isNil(value){return value==null;}/**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */function isSymbol(value){return _typeof(value)=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */function isUndefined(value){return value===undefined;}/**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */var lt=createRelationalOperation(baseLt);/**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */function toArray(value){if(!value){return[];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=value.replace(reTrim,'');var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*/ /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */var at=flatRest(baseAt);/**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */var defaultsDeep=baseRest(function(args){args.push(undefined,customDefaultsMerge);return apply(mergeWith,undefined,args);});/**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}/**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}},getIteratee);/**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */var invoke=baseRest(baseInvoke);/**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */function pickBy(object,predicate){if(object==null){return{};}var props=arrayMap(getAllKeysIn(object),function(prop){return[prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
if(!length){length=1;object=undefined;}while(++index<length){var value=object==null?undefined:object[toKey(path[index])];if(value===undefined){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseSet(object,path,value,customizer);}/**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */var toPairs=createToPairs(keys);/**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */var toPairsIn=createToPairs(keysIn);/**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else{accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*/ /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */function inRange(number,start,end){start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toFinite(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*/ /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */var lowerFirst=createCaseFirst('toLowerCase');/**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined){n=1;}else{n=toInteger(n);}return baseRepeat(toString(string),n);}/**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined;}limit=limit===undefined?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return[];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
// (http://ejohn.org/blog/javascript-micro-templating/)
// and Laura Doktorova's doT.js (https://github.com/olado/doT).
var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
// The sourceURL gets injected into the source that's eval-ed, so be careful
// with lookup (in case of e.g. prototype pollution), and strip newlines if any.
// A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.
var sourceURL='//# sourceURL='+(hasOwnProperty.call(options,'sourceURL')?(options.sourceURL+'').replace(/[\r\n]/g,' '):'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
// order to produce the correct `offset` value.
return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
// code to add the data object to the top of the scope chain.
// Like with sourceURL, we take care to not check the option's prototype,
// as this configuration is a code injection vector.
var variable=hasOwnProperty.call(options,'variable')&&options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Cleanup code by stripping empty strings.
source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined,importsValues);});// Provide the compiled function's source by its `toString` method or
// the `source` property as a convenience for inlining compiled templates.
result.source=source;if(isError(result)){throw result;}return result;}/**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */function toLower(value){return toString(value).toLowerCase();}/**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */function toUpper(value){return toString(value).toUpperCase();}/**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrim,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimEnd,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */var upperFirst=createCaseFirst('toUpperCase');/**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined:pattern;if(pattern===undefined){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*/ /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */var attempt=baseRest(function(func,args){try{return apply(func,undefined,args);}catch(e){return isError(e)?e:new Error(e);}});/**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return[toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */function constant(value){return function(){return value;};}/**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */var flow=createFlow();/**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */var flowRight=createFlow(true);/**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */function identity(value){return value;}/**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */function noop(){}// No operation performed.
/**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */var over=createOver(arrayMap);/**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */var overEvery=createOver(arrayEvery);/**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */var overSome=createOver(arraySome);/**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */function propertyOf(object){return function(path){return object==null?undefined:baseGet(object,path);};}/**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */var range=createRange();/**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */var rangeRight=createRange(true);/**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */function stubArray(){return[];}/**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */function stubFalse(){return false;}/**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */function stubObject(){return{};}/**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */function stubString(){return'';}/**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */function stubTrue(){return true;}/**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return[];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*/ /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */var ceil=createRound('ceil');/**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */var floor=createRound('floor');/**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined;}/**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined;}/**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */function mean(array){return baseMean(array,identity);}/**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined;}/**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined;}/**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */var round=createRound('round');/**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences.
lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
mixin(lodash,lodash);/*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences.
lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*/ /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */lodash.VERSION=VERSION;// Assign default placeholders.
arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else{result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function interceptor(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'';if(!hasOwnProperty.call(realNames,key)){realNames[key]=[];}realNames[key].push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined}];// Add methods to `LazyWrapper`.
LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/ // Export lodash.
var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
if( true&&_typeof(__webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js"))=='object'&&__webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")){// Expose Lodash on the global object to prevent errors when Lodash is
// loaded by a script tag in the presence of an AMD loader.
// See http://requirejs.org/docs/errors.html#mismatch for more details.
// Use `_.noConflict` to remove Lodash from the global object.
root._=_;// Define as an anonymous module so, through path mapping, it can be
// referenced as the "underscore" module.
!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return _;}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}// Check for `exports` after `define` in case a build optimizer adds it.
else if(freeModule){// Export for Node.js.
(freeModule.exports=_)._=_;// Export for CommonJS support.
freeExports._=_;}else{// Export to the global object.
root._=_;}}).call(this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/map.js":
/*!************************************!*\
  !*** ./node_modules/lodash/map.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseMap = __webpack_require__(/*! ./_baseMap */ "./node_modules/lodash/_baseMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");
/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */


function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;

/***/ }),

/***/ "./node_modules/lodash/memoize.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/memoize.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");
/** Error message constants. */


var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function memoized() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;
module.exports = memoize;

/***/ }),

/***/ "./node_modules/lodash/noop.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/noop.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {// No operation performed.
}

module.exports = noop;

/***/ }),

/***/ "./node_modules/lodash/property.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/property.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseProperty = __webpack_require__(/*! ./_baseProperty */ "./node_modules/lodash/_baseProperty.js"),
    basePropertyDeep = __webpack_require__(/*! ./_basePropertyDeep */ "./node_modules/lodash/_basePropertyDeep.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");
/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */


function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

/***/ }),

/***/ "./node_modules/lodash/reduce.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/reduce.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayReduce = __webpack_require__(/*! ./_arrayReduce */ "./node_modules/lodash/_arrayReduce.js"),
    baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseReduce = __webpack_require__(/*! ./_baseReduce */ "./node_modules/lodash/_baseReduce.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");
/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */


function reduce(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduce : baseReduce,
      initAccum = arguments.length < 3;
  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
}

module.exports = reduce;

/***/ }),

/***/ "./node_modules/lodash/size.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/size.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isString = __webpack_require__(/*! ./isString */ "./node_modules/lodash/isString.js"),
    stringSize = __webpack_require__(/*! ./_stringSize */ "./node_modules/lodash/_stringSize.js");
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    setTag = '[object Set]';
/**
 * Gets the size of `collection` by returning its length for array-like
 * values or the number of own enumerable string keyed properties for objects.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @returns {number} Returns the collection size.
 * @example
 *
 * _.size([1, 2, 3]);
 * // => 3
 *
 * _.size({ 'a': 1, 'b': 2 });
 * // => 2
 *
 * _.size('pebbles');
 * // => 7
 */

function size(collection) {
  if (collection == null) {
    return 0;
  }

  if (isArrayLike(collection)) {
    return isString(collection) ? stringSize(collection) : collection.length;
  }

  var tag = getTag(collection);

  if (tag == mapTag || tag == setTag) {
    return collection.size;
  }

  return baseKeys(collection).length;
}

module.exports = size;

/***/ }),

/***/ "./node_modules/lodash/stubArray.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubArray.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),

/***/ "./node_modules/lodash/toString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toString.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(/*! ./_baseToString */ "./node_modules/lodash/_baseToString.js");
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */


function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

/***/ }),

/***/ "./node_modules/lodash/transform.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/transform.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/**
 * An alternative to `_.reduce`; this method transforms `object` to a new
 * `accumulator` object which is the result of running each of its own
 * enumerable string keyed properties thru `iteratee`, with each invocation
 * potentially mutating the `accumulator` object. If `accumulator` is not
 * provided, a new object with the same `[[Prototype]]` will be used. The
 * iteratee is invoked with four arguments: (accumulator, value, key, object).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 1.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The custom accumulator value.
 * @returns {*} Returns the accumulated value.
 * @example
 *
 * _.transform([2, 3, 4], function(result, n) {
 *   result.push(n *= n);
 *   return n % 2 == 0;
 * }, []);
 * // => [4, 9]
 *
 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] }
 */


function transform(object, iteratee, accumulator) {
  var isArr = isArray(object),
      isArrLike = isArr || isBuffer(object) || isTypedArray(object);
  iteratee = baseIteratee(iteratee, 4);

  if (accumulator == null) {
    var Ctor = object && object.constructor;

    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject(object)) {
      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
    } else {
      accumulator = {};
    }
  }

  (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
    return iteratee(accumulator, value, index, object);
  });
  return accumulator;
}

module.exports = transform;

/***/ }),

/***/ "./node_modules/lodash/union.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/union.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    baseUniq = __webpack_require__(/*! ./_baseUniq */ "./node_modules/lodash/_baseUniq.js"),
    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ "./node_modules/lodash/isArrayLikeObject.js");
/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */


var union = baseRest(function (arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});
module.exports = union;

/***/ }),

/***/ "./node_modules/lodash/values.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/values.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseValues = __webpack_require__(/*! ./_baseValues */ "./node_modules/lodash/_baseValues.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */


function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;

/***/ }),

/***/ "./node_modules/native-promise-only/lib/npo.src.js":
/*!*********************************************************!*\
  !*** ./node_modules/native-promise-only/lib/npo.src.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, setImmediate) {var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! Native Promise Only
    v0.8.1 (c) Kyle Simpson
    MIT License: http://getify.mit-license.org
*/
(function UMD(name, context, definition) {
  // special form of UMD for polyfilling across evironments
  context[name] = context[name] || definition();

  if ( true && module.exports) {
    module.exports = context[name];
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function $AMD$() {
      return context[name];
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
})("Promise", typeof global != "undefined" ? global : this, function DEF() {
  /*jshint validthis:true */
  "use strict";

  var builtInProp,
      cycle,
      scheduling_queue,
      ToString = Object.prototype.toString,
      timer = typeof setImmediate != "undefined" ? function timer(fn) {
    return setImmediate(fn);
  } : setTimeout; // dammit, IE8.

  try {
    Object.defineProperty({}, "x", {});

    builtInProp = function builtInProp(obj, name, val, config) {
      return Object.defineProperty(obj, name, {
        value: val,
        writable: true,
        configurable: config !== false
      });
    };
  } catch (err) {
    builtInProp = function builtInProp(obj, name, val) {
      obj[name] = val;
      return obj;
    };
  } // Note: using a queue instead of array for efficiency


  scheduling_queue = function Queue() {
    var first, last, item;

    function Item(fn, self) {
      this.fn = fn;
      this.self = self;
      this.next = void 0;
    }

    return {
      add: function add(fn, self) {
        item = new Item(fn, self);

        if (last) {
          last.next = item;
        } else {
          first = item;
        }

        last = item;
        item = void 0;
      },
      drain: function drain() {
        var f = first;
        first = last = cycle = void 0;

        while (f) {
          f.fn.call(f.self);
          f = f.next;
        }
      }
    };
  }();

  function schedule(fn, self) {
    scheduling_queue.add(fn, self);

    if (!cycle) {
      cycle = timer(scheduling_queue.drain);
    }
  } // promise duck typing


  function isThenable(o) {
    var _then,
        o_type = _typeof(o);

    if (o != null && (o_type == "object" || o_type == "function")) {
      _then = o.then;
    }

    return typeof _then == "function" ? _then : false;
  }

  function notify() {
    for (var i = 0; i < this.chain.length; i++) {
      notifyIsolated(this, this.state === 1 ? this.chain[i].success : this.chain[i].failure, this.chain[i]);
    }

    this.chain.length = 0;
  } // NOTE: This is a separate function to isolate
  // the `try..catch` so that other code can be
  // optimized better


  function notifyIsolated(self, cb, chain) {
    var ret, _then;

    try {
      if (cb === false) {
        chain.reject(self.msg);
      } else {
        if (cb === true) {
          ret = self.msg;
        } else {
          ret = cb.call(void 0, self.msg);
        }

        if (ret === chain.promise) {
          chain.reject(TypeError("Promise-chain cycle"));
        } else if (_then = isThenable(ret)) {
          _then.call(ret, chain.resolve, chain.reject);
        } else {
          chain.resolve(ret);
        }
      }
    } catch (err) {
      chain.reject(err);
    }
  }

  function resolve(msg) {
    var _then,
        self = this; // already triggered?


    if (self.triggered) {
      return;
    }

    self.triggered = true; // unwrap

    if (self.def) {
      self = self.def;
    }

    try {
      if (_then = isThenable(msg)) {
        schedule(function () {
          var def_wrapper = new MakeDefWrapper(self);

          try {
            _then.call(msg, function $resolve$() {
              resolve.apply(def_wrapper, arguments);
            }, function $reject$() {
              reject.apply(def_wrapper, arguments);
            });
          } catch (err) {
            reject.call(def_wrapper, err);
          }
        });
      } else {
        self.msg = msg;
        self.state = 1;

        if (self.chain.length > 0) {
          schedule(notify, self);
        }
      }
    } catch (err) {
      reject.call(new MakeDefWrapper(self), err);
    }
  }

  function reject(msg) {
    var self = this; // already triggered?

    if (self.triggered) {
      return;
    }

    self.triggered = true; // unwrap

    if (self.def) {
      self = self.def;
    }

    self.msg = msg;
    self.state = 2;

    if (self.chain.length > 0) {
      schedule(notify, self);
    }
  }

  function iteratePromises(Constructor, arr, resolver, rejecter) {
    for (var idx = 0; idx < arr.length; idx++) {
      (function IIFE(idx) {
        Constructor.resolve(arr[idx]).then(function $resolver$(msg) {
          resolver(idx, msg);
        }, rejecter);
      })(idx);
    }
  }

  function MakeDefWrapper(self) {
    this.def = self;
    this.triggered = false;
  }

  function MakeDef(self) {
    this.promise = self;
    this.state = 0;
    this.triggered = false;
    this.chain = [];
    this.msg = void 0;
  }

  function Promise(executor) {
    if (typeof executor != "function") {
      throw TypeError("Not a function");
    }

    if (this.__NPO__ !== 0) {
      throw TypeError("Not a promise");
    } // instance shadowing the inherited "brand"
    // to signal an already "initialized" promise


    this.__NPO__ = 1;
    var def = new MakeDef(this);

    this["then"] = function then(success, failure) {
      var o = {
        success: typeof success == "function" ? success : true,
        failure: typeof failure == "function" ? failure : false
      }; // Note: `then(..)` itself can be borrowed to be used against
      // a different promise constructor for making the chained promise,
      // by substituting a different `this` binding.

      o.promise = new this.constructor(function extractChain(resolve, reject) {
        if (typeof resolve != "function" || typeof reject != "function") {
          throw TypeError("Not a function");
        }

        o.resolve = resolve;
        o.reject = reject;
      });
      def.chain.push(o);

      if (def.state !== 0) {
        schedule(notify, def);
      }

      return o.promise;
    };

    this["catch"] = function $catch$(failure) {
      return this.then(void 0, failure);
    };

    try {
      executor.call(void 0, function publicResolve(msg) {
        resolve.call(def, msg);
      }, function publicReject(msg) {
        reject.call(def, msg);
      });
    } catch (err) {
      reject.call(def, err);
    }
  }

  var PromisePrototype = builtInProp({}, "constructor", Promise,
  /*configurable=*/
  false); // Note: Android 4 cannot use `Object.defineProperty(..)` here

  Promise.prototype = PromisePrototype; // built-in "brand" to signal an "uninitialized" promise

  builtInProp(PromisePrototype, "__NPO__", 0,
  /*configurable=*/
  false);
  builtInProp(Promise, "resolve", function Promise$resolve(msg) {
    var Constructor = this; // spec mandated checks
    // note: best "isPromise" check that's practical for now

    if (msg && _typeof(msg) == "object" && msg.__NPO__ === 1) {
      return msg;
    }

    return new Constructor(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      resolve(msg);
    });
  });
  builtInProp(Promise, "reject", function Promise$reject(msg) {
    return new this(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      reject(msg);
    });
  });
  builtInProp(Promise, "all", function Promise$all(arr) {
    var Constructor = this; // spec mandated checks

    if (ToString.call(arr) != "[object Array]") {
      return Constructor.reject(TypeError("Not an array"));
    }

    if (arr.length === 0) {
      return Constructor.resolve([]);
    }

    return new Constructor(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      var len = arr.length,
          msgs = Array(len),
          count = 0;
      iteratePromises(Constructor, arr, function resolver(idx, msg) {
        msgs[idx] = msg;

        if (++count === len) {
          resolve(msgs);
        }
      }, reject);
    });
  });
  builtInProp(Promise, "race", function Promise$race(arr) {
    var Constructor = this; // spec mandated checks

    if (ToString.call(arr) != "[object Array]") {
      return Constructor.reject(TypeError("Not an array"));
    }

    return new Constructor(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      iteratePromises(Constructor, arr, function resolver(idx, msg) {
        resolve(msg);
      }, reject);
    });
  });
  return Promise;
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/path-loader/index.js":
/*!*******************************************!*\
  !*** ./node_modules/path-loader/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Jeremy Whitlock
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var supportedLoaders = {
  file: __webpack_require__(/*! ./lib/loaders/file */ "./node_modules/path-loader/lib/loaders/file-browser.js"),
  http: __webpack_require__(/*! ./lib/loaders/http */ "./node_modules/path-loader/lib/loaders/http.js"),
  https: __webpack_require__(/*! ./lib/loaders/http */ "./node_modules/path-loader/lib/loaders/http.js")
};
var defaultLoader = (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' || typeof importScripts === 'function' ? supportedLoaders.http : supportedLoaders.file; // Load promises polyfill if necessary

/* istanbul ignore if */

if (typeof Promise === 'undefined') {
  __webpack_require__(/*! native-promise-only */ "./node_modules/native-promise-only/lib/npo.src.js");
}

function getScheme(location) {
  if (typeof location !== 'undefined') {
    location = location.indexOf('://') === -1 ? '' : location.split('://')[0];
  }

  return location;
}
/**
 * Utility that provides a single API for loading the content of a path/URL.
 *
 * @module path-loader
 */


function getLoader(location) {
  var scheme = getScheme(location);
  var loader = supportedLoaders[scheme];

  if (typeof loader === 'undefined') {
    if (scheme === '') {
      loader = defaultLoader;
    } else {
      throw new Error('Unsupported scheme: ' + scheme);
    }
  }

  return loader;
}
/**
 * Loads a document at the provided location and returns a JavaScript object representation.
 *
 * @param {string} location - The location to the document
 * @param {module:path-loader.LoadOptions} [options] - The loader options
 *
 * @returns {Promise<*>} Always returns a promise even if there is a callback provided
 *
 * @example
 * // Example using Promises
 *
 * PathLoader
 *   .load('./package.json')
 *   .then(JSON.parse)
 *   .then(function (document) {
 *     console.log(document.name + ' (' + document.version + '): ' + document.description);
 *   }, function (err) {
 *     console.error(err.stack);
 *   });
 *
 * @example
 * // Example using options.prepareRequest to provide authentication details for a remotely secure URL
 *
 * PathLoader
 *   .load('https://api.github.com/repos/whitlockjc/path-loader', {
 *     prepareRequest: function (req, callback) {
 *       req.auth('my-username', 'my-password');
 *       callback(undefined, req);
 *     }
 *   })
 *   .then(JSON.parse)
 *   .then(function (document) {
 *     console.log(document.full_name + ': ' + document.description);
 *   }, function (err) {
 *     console.error(err.stack);
 *   });
 *
 * @example
 * // Example loading a YAML file
 *
 * PathLoader
 *   .load('/Users/not-you/projects/path-loader/.travis.yml')
 *   .then(YAML.safeLoad)
 *   .then(function (document) {
 *     console.log('path-loader uses the', document.language, 'language.');
 *   }, function (err) {
 *     console.error(err.stack);
 *   });
 *
 * @example
 * // Example loading a YAML file with options.processContent (Useful if you need information in the raw response)
 *
 * PathLoader
 *   .load('/Users/not-you/projects/path-loader/.travis.yml', {
 *     processContent: function (res, callback) {
 *       callback(YAML.safeLoad(res.text));
 *     }
 *   })
 *   .then(function (document) {
 *     console.log('path-loader uses the', document.language, 'language.');
 *   }, function (err) {
 *     console.error(err.stack);
 *   });
 */


module.exports.load = function (location, options) {
  var allTasks = Promise.resolve(); // Default options to empty object

  if (typeof options === 'undefined') {
    options = {};
  } // Validate arguments


  allTasks = allTasks.then(function () {
    if (typeof location === 'undefined') {
      throw new TypeError('location is required');
    } else if (typeof location !== 'string') {
      throw new TypeError('location must be a string');
    }

    if (typeof options !== 'undefined') {
      if (_typeof(options) !== 'object') {
        throw new TypeError('options must be an object');
      } else if (typeof options.processContent !== 'undefined' && typeof options.processContent !== 'function') {
        throw new TypeError('options.processContent must be a function');
      }
    }
  }); // Load the document from the provided location and process it

  allTasks = allTasks.then(function () {
    return new Promise(function (resolve, reject) {
      var loader = getLoader(location);
      loader.load(location, options || {}, function (err, document) {
        if (err) {
          reject(err);
        } else {
          resolve(document);
        }
      });
    });
  }).then(function (res) {
    if (options.processContent) {
      return new Promise(function (resolve, reject) {
        // For consistency between file and http, always send an object with a 'text' property containing the raw
        // string value being processed.
        if (_typeof(res) !== 'object') {
          res = {
            text: res
          };
        } // Pass the path being loaded


        res.location = location;
        options.processContent(res, function (err, processed) {
          if (err) {
            reject(err);
          } else {
            resolve(processed);
          }
        });
      });
    } else {
      // If there was no content processor, we will assume that for all objects that it is a Superagent response
      // and will return its `text` property value.  Otherwise, we will return the raw response.
      return _typeof(res) === 'object' ? res.text : res;
    }
  });
  return allTasks;
};

/***/ }),

/***/ "./node_modules/path-loader/lib/loaders/file-browser.js":
/*!**************************************************************!*\
  !*** ./node_modules/path-loader/lib/loaders/file-browser.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Jeremy Whitlock
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


var unsupportedError = new TypeError('The \'file\' scheme is not supported in the browser');
/**
 * The file loader is not supported in the browser.
 *
 * @throws {error} the file loader is not supported in the browser
 */

module.exports.getBase = function () {
  throw unsupportedError;
};
/**
 * The file loader is not supported in the browser.
 */


module.exports.load = function () {
  var fn = arguments[arguments.length - 1];

  if (typeof fn === 'function') {
    fn(unsupportedError);
  } else {
    throw unsupportedError;
  }
};

/***/ }),

/***/ "./node_modules/path-loader/lib/loaders/http.js":
/*!******************************************************!*\
  !*** ./node_modules/path-loader/lib/loaders/http.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env node, browser */

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Jeremy Whitlock
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


var request = __webpack_require__(/*! superagent */ "./node_modules/superagent/lib/client.js");

var supportedHttpMethods = ['delete', 'get', 'head', 'patch', 'post', 'put'];
/**
 * Loads a file from an http or https URL.
 *
 * @param {string} location - The document URL (If relative, location is relative to window.location.origin).
 * @param {object} options - The loader options
 * @param {string} [options.method=get] - The HTTP method to use for the request
 * @param {module:PathLoader~PrepareRequestCallback} [options.prepareRequest] - The callback used to prepare a request
 * @param {module:PathLoader~ProcessResponseCallback} [options.processContent] - The callback used to process the
 * response
 * @param {function} callback - The error-first callback
 */

module.exports.load = function (location, options, callback) {
  var realMethod = options.method ? options.method.toLowerCase() : 'get';
  var err;
  var realRequest;

  function makeRequest(err, req) {
    if (err) {
      callback(err);
    } else {
      // buffer() is only available in Node.js
      if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]' && typeof req.buffer === 'function') {
        req.buffer(true);
      }

      req.end(function (err2, res) {
        if (err2) {
          callback(err2);
        } else {
          callback(undefined, res);
        }
      });
    }
  }

  if (typeof options.method !== 'undefined') {
    if (typeof options.method !== 'string') {
      err = new TypeError('options.method must be a string');
    } else if (supportedHttpMethods.indexOf(options.method) === -1) {
      err = new TypeError('options.method must be one of the following: ' + supportedHttpMethods.slice(0, supportedHttpMethods.length - 1).join(', ') + ' or ' + supportedHttpMethods[supportedHttpMethods.length - 1]);
    }
  } else if (typeof options.prepareRequest !== 'undefined' && typeof options.prepareRequest !== 'function') {
    err = new TypeError('options.prepareRequest must be a function');
  }

  if (!err) {
    realRequest = request[realMethod === 'delete' ? 'del' : realMethod](location);

    if (options.prepareRequest) {
      try {
        options.prepareRequest(realRequest, makeRequest);
      } catch (err2) {
        callback(err2);
      }
    } else {
      makeRequest(undefined, realRequest);
    }
  } else {
    callback(err);
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
 // If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var stringifyPrimitive = function stringifyPrimitive(v) {
  switch (_typeof(v)) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (_typeof(obj) === 'object') {
    return map(objectKeys(obj), function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (isArray(obj[k])) {
        return map(obj[k], function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map(xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }

  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }

  return res;
};

/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring-es3/encode.js");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function registerImmediate(handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function onGlobalMessage(event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function registerImmediate(handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function registerImmediate(handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function registerImmediate(handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function registerImmediate(handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6–8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/slash/index.js":
/*!*************************************!*\
  !*** ./node_modules/slash/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (path) {
  var isExtendedLengthPath = /^\\\\\?\\/.test(path);
  var hasNonAscii = /[^\u0000-\u0080]+/.test(path); // eslint-disable-line no-control-regex

  if (isExtendedLengthPath || hasNonAscii) {
    return path;
  }

  return path.replace(/\\/g, '/');
};

/***/ }),

/***/ "./node_modules/superagent/lib/agent-base.js":
/*!***************************************************!*\
  !*** ./node_modules/superagent/lib/agent-base.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function Agent() {
  this._defaults = [];
}

["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(function (fn) {
  /** Default setting for all requests from this agent */
  Agent.prototype[fn] = function ()
  /*varargs*/
  {
    this._defaults.push({
      fn: fn,
      arguments: arguments
    });

    return this;
  };
});

Agent.prototype._setDefaults = function (req) {
  this._defaults.forEach(function (def) {
    req[def.fn].apply(req, def.arguments);
  });
};

module.exports = Agent;

/***/ }),

/***/ "./node_modules/superagent/lib/client.js":
/*!***********************************************!*\
  !*** ./node_modules/superagent/lib/client.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Root reference for iframes.
 */
var root;

if (typeof window !== 'undefined') {
  // Browser window
  root = window;
} else if (typeof self !== 'undefined') {
  // Web Worker
  root = self;
} else {
  // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");

var RequestBase = __webpack_require__(/*! ./request-base */ "./node_modules/superagent/lib/request-base.js");

var isObject = __webpack_require__(/*! ./is-object */ "./node_modules/superagent/lib/is-object.js");

var ResponseBase = __webpack_require__(/*! ./response-base */ "./node_modules/superagent/lib/response-base.js");

var Agent = __webpack_require__(/*! ./agent-base */ "./node_modules/superagent/lib/agent-base.js");
/**
 * Noop.
 */


function noop() {}

;
/**
 * Expose `request`.
 */

var request = exports = module.exports = function (method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  } // url first


  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
};

exports.Request = Request;
/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest && (!root.location || 'file:' != root.location.protocol || !root.ActiveXObject)) {
    return new XMLHttpRequest();
  } else {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch (e) {}

    try {
      return new ActiveXObject('Msxml2.XMLHTTP.6.0');
    } catch (e) {}

    try {
      return new ActiveXObject('Msxml2.XMLHTTP.3.0');
    } catch (e) {}

    try {
      return new ActiveXObject('Msxml2.XMLHTTP');
    } catch (e) {}
  }

  throw Error("Browser-only version of superagent could not find XHR");
};
/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */


var trim = ''.trim ? function (s) {
  return s.trim();
} : function (s) {
  return s.replace(/(^\s*|\s*$)/g, '');
};
/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];

  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }

  return pairs.join('&');
}
/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */


function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function (v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for (var subkey in val) {
        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}
/**
 * Expose serialization method.
 */


request.serializeObject = serialize;
/**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');

    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}
/**
 * Expose parser.
 */


request.parseString = parseString;
/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};
/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};
/**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};
/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');

    if (index === -1) {
      // could be empty line, just skip it
      continue;
    }

    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}
/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */


function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[\/+]json($|[^-\w])/.test(mime);
}
/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */


function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr; // responseText is accessible only if responseType is '' or 'text' and on older browsers

  this.text = this.req.method != 'HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text') || typeof this.xhr.responseType === 'undefined' ? this.xhr.responseText : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status; // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request

  if (status === 1223) {
    status = 204;
  }

  this._setStatusProperties(status);

  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders()); // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.

  this.header['content-type'] = this.xhr.getResponseHeader('content-type');

  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD' ? this._parseBody(this.text ? this.text : this.xhr.response) : null;
  }
}

ResponseBase(Response.prototype);
/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function (str) {
  var parse = request.parse[this.type];

  if (this.req._parser) {
    return this.req._parser(this, str);
  }

  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }

  return parse && str && (str.length || str instanceof Object) ? parse(str) : null;
};
/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */


Response.prototype.toError = function () {
  var req = this.req;
  var method = req.method;
  var url = req.url;
  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;
  return err;
};
/**
 * Expose `Response`.
 */


request.Response = Response;
/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case

  this._header = {}; // coerces header names to lowercase

  this.on('end', function () {
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch (e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e; // issue #675: return the raw response if the response parsing fails

      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response; // issue #876: return the http status code if the response parsing fails

        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);
    var new_err;

    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch (custom_err) {
      new_err = custom_err; // ok() callback can throw
    } // #1000 don't catch errors from the callback to avoid double calling it


    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}
/**
 * Mixin `Emitter` and `RequestBase`.
 */


Emitter(Request.prototype);
RequestBase(Request.prototype);
/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function (type) {
  this.set('Content-Type', request.types[type] || type);
  return this;
};
/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.accept = function (type) {
  this.set('Accept', request.types[type] || type);
  return this;
};
/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.auth = function (user, pass, options) {
  if (1 === arguments.length) pass = '';

  if (_typeof(pass) === 'object' && pass !== null) {
    // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }

  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto'
    };
  }

  var encoder = function encoder(string) {
    if ('function' === typeof btoa) {
      return btoa(string);
    }

    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};
/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.query = function (val) {
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};
/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.attach = function (field, file, options) {
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }

  return this;
};

Request.prototype._getFormData = function () {
  if (!this._formData) {
    this._formData = new root.FormData();
  }

  return this._formData;
};
/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */


Request.prototype.callback = function (err, res) {
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};
/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */


Request.prototype.crossDomainError = function () {
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;
  err.status = this.status;
  err.method = this.method;
  err.url = this.url;
  this.callback(err);
}; // This only warns, because the request is still likely to work


Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function () {
  console.warn("This is not supported in browser version of superagent");
  return this;
}; // This throws, because it can't send/receive data as expected


Request.prototype.pipe = Request.prototype.write = function () {
  throw Error("Streaming is not supported in browser version of superagent");
};
/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */


Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === _typeof(obj) && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
};
/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.end = function (fn) {
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }

  this._endCalled = true; // store callback

  this._callback = fn || noop; // querystring

  this._finalizeQueryString();

  return this._end();
};

Request.prototype._end = function () {
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var data = this._formData || this._data;

  this._setTimeouts(); // state change


  xhr.onreadystatechange = function () {
    var readyState = xhr.readyState;

    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }

    if (4 != readyState) {
      return;
    } // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"


    var status;

    try {
      status = xhr.status;
    } catch (e) {
      status = 0;
    }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }

    self.emit('end');
  }; // progress


  var handleProgress = function handleProgress(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }

    e.direction = direction;
    self.emit('progress', e);
  };

  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');

      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch (e) {// Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  } // initiate request


  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  } // CORS


  if (this._withCredentials) xhr.withCredentials = true; // body

  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];

    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }

    if (serialize) data = serialize(data);
  } // set header fields


  for (var field in this.header) {
    if (null == this.header[field]) continue;
    if (this.header.hasOwnProperty(field)) xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  } // send stuff


  this.emit('request', this); // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined

  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};

request.agent = function () {
  return new Agent();
};

["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function (method) {
  Agent.prototype[method.toLowerCase()] = function (url, fn) {
    var req = new request.Request(method, url);

    this._setDefaults(req);

    if (fn) {
      req.end(fn);
    }

    return req;
  };
});
Agent.prototype.del = Agent.prototype['delete'];
/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function (url, data, fn) {
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.head = function (url, data, fn) {
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.options = function (url, data, fn) {
  var req = request('OPTIONS', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


function del(url, data, fn) {
  var req = request('DELETE', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request['del'] = del;
request['delete'] = del;
/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function (url, data, fn) {
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.post = function (url, data, fn) {
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.put = function (url, data, fn) {
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/***/ }),

/***/ "./node_modules/superagent/lib/is-object.js":
/*!**************************************************!*\
  !*** ./node_modules/superagent/lib/is-object.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isObject(obj) {
  return null !== obj && 'object' === _typeof(obj);
}

module.exports = isObject;

/***/ }),

/***/ "./node_modules/superagent/lib/request-base.js":
/*!*****************************************************!*\
  !*** ./node_modules/superagent/lib/request-base.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Module of mixed-in functions shared between node and client code
 */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var isObject = __webpack_require__(/*! ./is-object */ "./node_modules/superagent/lib/is-object.js");
/**
 * Expose `RequestBase`.
 */


module.exports = RequestBase;
/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}
/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */


function mixin(obj) {
  for (var key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }

  return obj;
}
/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.clearTimeout = function _clearTimeout() {
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};
/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */


RequestBase.prototype.parse = function parse(fn) {
  this._parser = fn;
  return this;
};
/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.responseType = function (val) {
  this._responseType = val;
  return this;
};
/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */


RequestBase.prototype.serialize = function serialize(fn) {
  this._serializer = fn;
  return this;
};
/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.timeout = function timeout(options) {
  if (!options || 'object' !== _typeof(options)) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for (var option in options) {
    switch (option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;

      case 'response':
        this._responseTimeout = options.response;
        break;

      default:
        console.warn("Unknown timeout option", option);
    }
  }

  return this;
};
/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.retry = function retry(count, fn) {
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

var ERROR_CODES = ['ECONNRESET', 'ETIMEDOUT', 'EADDRINFO', 'ESOCKETTIMEDOUT'];
/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */

RequestBase.prototype._shouldRetry = function (err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }

  if (this._retryCallback) {
    try {
      var override = this._retryCallback(err, res);

      if (override === true) return true;
      if (override === false) return false; // undefined falls back to defaults
    } catch (e) {
      console.error(e);
    }
  }

  if (res && res.status && res.status >= 500 && res.status != 501) return true;

  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true; // Superagent timeout

    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }

  return false;
};
/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */


RequestBase.prototype._retry = function () {
  this.clearTimeout(); // node

  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;
  return this._end();
};
/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */


RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;

    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }

    this._fullfilledPromise = new Promise(function (innerResolve, innerReject) {
      self.end(function (err, res) {
        if (err) innerReject(err);else innerResolve(res);
      });
    });
  }

  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype['catch'] = function (cb) {
  return this.then(undefined, cb);
};
/**
 * Allow for extension
 */


RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function (cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function (res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};
/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */


RequestBase.prototype.get = function (field) {
  return this._header[field.toLowerCase()];
};
/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */


RequestBase.prototype.getHeader = RequestBase.prototype.get;
/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function (field, val) {
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }

    return this;
  }

  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};
/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */


RequestBase.prototype.unset = function (field) {
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};
/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.field = function (name, val) {
  // name should be either a string or an object.
  if (null === name || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      this.field(key, name[key]);
    }

    return this;
  }

  if (Array.isArray(val)) {
    for (var i in val) {
      this.field(name, val[i]);
    }

    return this;
  } // val should be defined now


  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }

  if ('boolean' === typeof val) {
    val = '' + val;
  }

  this._getFormData().append(name, val);

  return this;
};
/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */


RequestBase.prototype.abort = function () {
  if (this._aborted) {
    return this;
  }

  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser

  this.req && this.req.abort(); // node

  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function (user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', 'Basic ' + base64Encoder(user + ':' + pass));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer':
      // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', 'Bearer ' + user);
      break;
  }

  return this;
};
/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */


RequestBase.prototype.withCredentials = function (on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};
/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.redirects = function (n) {
  this._maxRedirects = n;
  return this;
};
/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */


RequestBase.prototype.maxResponseSize = function (n) {
  if ('number' !== typeof n) {
    throw TypeError("Invalid argument");
  }

  this._maxResponseSize = n;
  return this;
};
/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */


RequestBase.prototype.toJSON = function () {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};
/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.send = function (data) {
  var isObj = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  } // merge


  if (isObj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];

    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data ? this._data + '&' + data : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  } // default to json


  if (!type) this.type('json');
  return this;
};
/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.sortQuery = function (sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};
/**
 * Compose querystring to append to req.url
 *
 * @api private
 */


RequestBase.prototype._finalizeQueryString = function () {
  var query = this._query.join('&');

  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }

  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');

    if (index >= 0) {
      var queryArr = this.url.substring(index + 1).split('&');

      if ('function' === typeof this._sort) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }

      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
}; // For backwards compat only


RequestBase.prototype._appendQueryString = function () {
  console.trace("Unsupported");
};
/**
 * Invoke callback with timeout error.
 *
 * @api private
 */


RequestBase.prototype._timeoutError = function (reason, timeout, errno) {
  if (this._aborted) {
    return;
  }

  var err = new Error(reason + timeout + 'ms exceeded');
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function () {
  var self = this; // deadline

  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function () {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  } // response timeout


  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function () {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

/***/ }),

/***/ "./node_modules/superagent/lib/response-base.js":
/*!******************************************************!*\
  !*** ./node_modules/superagent/lib/response-base.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Module dependencies.
 */

var utils = __webpack_require__(/*! ./utils */ "./node_modules/superagent/lib/utils.js");
/**
 * Expose `ResponseBase`.
 */


module.exports = ResponseBase;
/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}
/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */


function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }

  return obj;
}
/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */


ResponseBase.prototype.get = function (field) {
  return this.header[field.toLowerCase()];
};
/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */


ResponseBase.prototype._setHeaderProperties = function (header) {
  // TODO: moar!
  // TODO: make this a util
  // content-type
  var ct = header['content-type'] || '';
  this.type = utils.type(ct); // params

  var params = utils.params(ct);

  for (var key in params) {
    this[key] = params[key];
  }

  this.links = {}; // links

  try {
    if (header.link) {
      this.links = utils.parseLinks(header.link);
    }
  } catch (err) {// ignore
  }
};
/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */


ResponseBase.prototype._setStatusProperties = function (status) {
  var type = status / 100 | 0; // status / class

  this.status = this.statusCode = status;
  this.statusType = type; // basics

  this.info = 1 == type;
  this.ok = 2 == type;
  this.redirect = 3 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = 4 == type || 5 == type ? this.toError() : false; // sugar

  this.created = 201 == status;
  this.accepted = 202 == status;
  this.noContent = 204 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.forbidden = 403 == status;
  this.notFound = 404 == status;
  this.unprocessableEntity = 422 == status;
};

/***/ }),

/***/ "./node_modules/superagent/lib/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/superagent/lib/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = function (str) {
  return str.split(/ *; */).shift();
};
/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */


exports.params = function (str) {
  return str.split(/ *; */).reduce(function (obj, str) {
    var parts = str.split(/ *= */);
    var key = parts.shift();
    var val = parts.shift();
    if (key && val) obj[key] = val;
    return obj;
  }, {});
};
/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */


exports.parseLinks = function (str) {
  return str.split(/ *, */).reduce(function (obj, str) {
    var parts = str.split(/ *; */);
    var url = parts[0].slice(1, -1);
    var rel = parts[1].split(/ *= */)[1].slice(1, -1);
    obj[rel] = url;
    return obj;
  }, {});
};
/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */


exports.cleanHeader = function (header, changesOrigin) {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header['host']; // secuirty

  if (changesOrigin) {
    delete header['authorization'];
    delete header['cookie'];
  }

  return header;
};

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js"); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/uri-js/dist/es5/uri.all.js":
/*!*************************************************!*\
  !*** ./node_modules/uri-js/dist/es5/uri.all.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** @license URI.js v4.2.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (exports) {
  'use strict';

  function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
      sets[_key] = arguments[_key];
    }

    if (sets.length > 1) {
      sets[0] = sets[0].slice(0, -1);
      var xl = sets.length - 1;

      for (var x = 1; x < xl; ++x) {
        sets[x] = sets[x].slice(1, -1);
      }

      sets[xl] = sets[xl].slice(1);
      return sets.join('');
    } else {
      return sets[0];
    }
  }

  function subexp(str) {
    return "(?:" + str + ")";
  }

  function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
  }

  function toUpperCase(str) {
    return str.toUpperCase();
  }

  function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
  }

  function assign(target, source) {
    var obj = target;

    if (source) {
      for (var key in source) {
        obj[key] = source[key];
      }
    }

    return obj;
  }

  function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
        CR$ = "[\\x0D]",
        DIGIT$$ = "[0-9]",
        DQUOTE$$ = "[\\x22]",
        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
        //case-insensitive
    LF$$ = "[\\x0A]",
        SP$$ = "[\\x20]",
        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$),
        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"),
        USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"),
        DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$),
        DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + "{1,4}"),
        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
        //                           6( h16 ":" ) ls32
    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
        //                      "::" 5( h16 ":" ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
        //[               h16 ] "::" 4( h16 ":" ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
        //[ *4( h16 ":" ) h16 ] "::"              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
        //[ *5( h16 ":" ) h16 ] "::"              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
        //[ *6( h16 ":" ) h16 ] "::"
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"),
        //RFC 6874
    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$),
        //RFC 6874
    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$),
        //RFC 6874, with relaxed parsing rules
    IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"),
        IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"),
        //RFC 6874
    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"),
        HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$),
        PORT$ = subexp(DIGIT$$ + "*"),
        AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"),
        PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")),
        SEGMENT$ = subexp(PCHAR$ + "*"),
        SEGMENT_NZ$ = subexp(PCHAR$ + "+"),
        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"),
        PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"),
        PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"),
        //simplified
    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
        //simplified
    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
        //simplified
    PATH_EMPTY$ = "(?!" + PCHAR$ + ")",
        PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"),
        FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"),
        HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$),
        RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$),
        ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"),
        GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$",
        SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
    return {
      NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
      NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
      NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
      ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      UNRESERVED: new RegExp(UNRESERVED$$, "g"),
      OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
      PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
      IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
      IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules

    };
  }

  var URI_PROTOCOL = buildExps(false);
  var IRI_PROTOCOL = buildExps(true);

  var slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var toConsumableArray = function toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return Array.from(arr);
    }
  };
  /** Highest positive signed 32-bit float value */


  var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */

  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128; // 0x80

  var delimiter = '-'; // '\x2D'

  /** Regular expressions */

  var regexPunycode = /^xn--/;
  var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars

  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

  /** Error messages */

  var errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
  };
  /** Convenience shortcuts */

  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;
  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */

  function error$1(type) {
    throw new RangeError(errors[type]);
  }
  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */


  function map(array, fn) {
    var result = [];
    var length = array.length;

    while (length--) {
      result[length] = fn(array[length]);
    }

    return result;
  }
  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */


  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';

    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    } // Avoid `split(regex)` for IE8 compatibility. See #17.


    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map(labels, fn).join('.');
    return result + encoded;
  }
  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */


  function ucs2decode(string) {
    var output = [];
    var counter = 0;
    var length = string.length;

    while (counter < length) {
      var value = string.charCodeAt(counter++);

      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // It's a high surrogate, and there is a next character.
        var extra = string.charCodeAt(counter++);

        if ((extra & 0xFC00) == 0xDC00) {
          // Low surrogate.
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // It's an unmatched surrogate; only append this code unit, in case the
          // next code unit is the high surrogate of a surrogate pair.
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }

    return output;
  }
  /**
   * Creates a string based on an array of numeric code points.
   * @see `punycode.ucs2.decode`
   * @memberOf punycode.ucs2
   * @name encode
   * @param {Array} codePoints The array of numeric code points.
   * @returns {String} The new Unicode string (UCS-2).
   */


  var ucs2encode = function ucs2encode(array) {
    return String.fromCodePoint.apply(String, toConsumableArray(array));
  };
  /**
   * Converts a basic code point into a digit/integer.
   * @see `digitToBasic()`
   * @private
   * @param {Number} codePoint The basic numeric code point value.
   * @returns {Number} The numeric value of a basic code point (for use in
   * representing integers) in the range `0` to `base - 1`, or `base` if
   * the code point does not represent a value.
   */


  var basicToDigit = function basicToDigit(codePoint) {
    if (codePoint - 0x30 < 0x0A) {
      return codePoint - 0x16;
    }

    if (codePoint - 0x41 < 0x1A) {
      return codePoint - 0x41;
    }

    if (codePoint - 0x61 < 0x1A) {
      return codePoint - 0x61;
    }

    return base;
  };
  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */


  var digitToBasic = function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };
  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * https://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */


  var adapt = function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);

    for (;
    /* no initialization */
    delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }

    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  /**
   * Converts a Punycode string of ASCII-only symbols to a string of Unicode
   * symbols.
   * @memberOf punycode
   * @param {String} input The Punycode string of ASCII-only symbols.
   * @returns {String} The resulting string of Unicode symbols.
   */


  var decode = function decode(input) {
    // Don't use UCS-2.
    var output = [];
    var inputLength = input.length;
    var i = 0;
    var n = initialN;
    var bias = initialBias; // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.

    var basic = input.lastIndexOf(delimiter);

    if (basic < 0) {
      basic = 0;
    }

    for (var j = 0; j < basic; ++j) {
      // if it's not a basic code point
      if (input.charCodeAt(j) >= 0x80) {
        error$1('not-basic');
      }

      output.push(input.charCodeAt(j));
    } // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.


    for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;)
    /* no final expression */
    {
      // `index` is the index of the next character to be consumed.
      // Decode a generalized variable-length integer into `delta`,
      // which gets added to `i`. The overflow checking is easier
      // if we increase `i` as we go, then subtract off its starting
      // value at the end to obtain `delta`.
      var oldi = i;

      for (var w = 1, k = base;;
      /* no condition */
      k += base) {
        if (index >= inputLength) {
          error$1('invalid-input');
        }

        var digit = basicToDigit(input.charCodeAt(index++));

        if (digit >= base || digit > floor((maxInt - i) / w)) {
          error$1('overflow');
        }

        i += digit * w;
        var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

        if (digit < t) {
          break;
        }

        var baseMinusT = base - t;

        if (w > floor(maxInt / baseMinusT)) {
          error$1('overflow');
        }

        w *= baseMinusT;
      }

      var out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
      // incrementing `n` each time, so we'll fix that now:

      if (floor(i / out) > maxInt - n) {
        error$1('overflow');
      }

      n += floor(i / out);
      i %= out; // Insert `n` at position `i` of the output.

      output.splice(i++, 0, n);
    }

    return String.fromCodePoint.apply(String, output);
  };
  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */


  var encode = function encode(input) {
    var output = []; // Convert the input in UCS-2 to an array of Unicode code points.

    input = ucs2decode(input); // Cache the length.

    var inputLength = input.length; // Initialize the state.

    var n = initialN;
    var delta = 0;
    var bias = initialBias; // Handle the basic code points.

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _currentValue2 = _step.value;

        if (_currentValue2 < 0x80) {
          output.push(stringFromCharCode(_currentValue2));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var basicLength = output.length;
    var handledCPCount = basicLength; // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.
    // Finish the basic string with a delimiter unless it's empty.

    if (basicLength) {
      output.push(delimiter);
    } // Main encoding loop:


    while (handledCPCount < inputLength) {
      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      var m = maxInt;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var currentValue = _step2.value;

          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
        // but guard against overflow.

      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var handledCPCountPlusOne = handledCPCount + 1;

      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error$1('overflow');
      }

      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _currentValue = _step3.value;

          if (_currentValue < n && ++delta > maxInt) {
            error$1('overflow');
          }

          if (_currentValue == n) {
            // Represent delta as a generalized variable-length integer.
            var q = delta;

            for (var k = base;;
            /* no condition */
            k += base) {
              var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

              if (q < t) {
                break;
              }

              var qMinusT = q - t;
              var baseMinusT = base - t;
              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
              q = floor(qMinusT / baseMinusT);
            }

            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      ++delta;
      ++n;
    }

    return output.join('');
  };
  /**
   * Converts a Punycode string representing a domain name or an email address
   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
   * it doesn't matter if you call it on a string that has already been
   * converted to Unicode.
   * @memberOf punycode
   * @param {String} input The Punycoded domain name or email address to
   * convert to Unicode.
   * @returns {String} The Unicode representation of the given Punycode
   * string.
   */


  var toUnicode = function toUnicode(input) {
    return mapDomain(input, function (string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  };
  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */


  var toASCII = function toASCII(input) {
    return mapDomain(input, function (string) {
      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
  };
  /*--------------------------------------------------------------------------*/

  /** Define the public API */


  var punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    'version': '2.1.0',

    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    'ucs2': {
      'decode': ucs2decode,
      'encode': ucs2encode
    },
    'decode': decode,
    'encode': encode,
    'toASCII': toASCII,
    'toUnicode': toUnicode
  };
  /**
   * URI.js
   *
   * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/uri-js
   */

  /**
   * Copyright 2011 Gary Court. All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without modification, are
   * permitted provided that the following conditions are met:
   *
   *    1. Redistributions of source code must retain the above copyright notice, this list of
   *       conditions and the following disclaimer.
   *
   *    2. Redistributions in binary form must reproduce the above copyright notice, this list
   *       of conditions and the following disclaimer in the documentation and/or other materials
   *       provided with the distribution.
   *
   * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
   * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
   * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
   * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
   * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *
   * The views and conclusions contained in the software and documentation are those of the
   * authors and should not be interpreted as representing official policies, either expressed
   * or implied, of Gary Court.
   */

  var SCHEMES = {};

  function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
  }

  function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;

    while (i < il) {
      var c = parseInt(str.substr(i + 1, 2), 16);

      if (c < 128) {
        newStr += String.fromCharCode(c);
        i += 3;
      } else if (c >= 194 && c < 224) {
        if (il - i >= 6) {
          var c2 = parseInt(str.substr(i + 4, 2), 16);
          newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
        } else {
          newStr += str.substr(i, 6);
        }

        i += 6;
      } else if (c >= 224) {
        if (il - i >= 9) {
          var _c = parseInt(str.substr(i + 4, 2), 16);

          var c3 = parseInt(str.substr(i + 7, 2), 16);
          newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
        } else {
          newStr += str.substr(i, 9);
        }

        i += 9;
      } else {
        newStr += str.substr(i, 3);
        i += 3;
      }
    }

    return newStr;
  }

  function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
      var decStr = pctDecChars(str);
      return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }

    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
  }

  function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
  }

  function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
      return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
      return host;
    }
  }

  function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
      var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
          _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
          last = _address$toLowerCase$2[0],
          first = _address$toLowerCase$2[1];

      var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
      var lastFields = last.split(":").map(_stripLeadingZeros);
      var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
      var fieldCount = isLastFieldIPv4Address ? 7 : 8;
      var lastFieldsStart = lastFields.length - fieldCount;
      var fields = Array(fieldCount);

      for (var x = 0; x < fieldCount; ++x) {
        fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
      }

      if (isLastFieldIPv4Address) {
        fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
      }

      var allZeroFields = fields.reduce(function (acc, field, index) {
        if (!field || field === "0") {
          var lastLongest = acc[acc.length - 1];

          if (lastLongest && lastLongest.index + lastLongest.length === index) {
            lastLongest.length++;
          } else {
            acc.push({
              index: index,
              length: 1
            });
          }
        }

        return acc;
      }, []);
      var longestZeroFields = allZeroFields.sort(function (a, b) {
        return b.length - a.length;
      })[0];
      var newHost = void 0;

      if (longestZeroFields && longestZeroFields.length > 1) {
        var newFirst = fields.slice(0, longestZeroFields.index);
        var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
        newHost = newFirst.join(":") + "::" + newLast.join(":");
      } else {
        newHost = fields.join(":");
      }

      if (zone) {
        newHost += "%" + zone;
      }

      return newHost;
    } else {
      return host;
    }
  }

  var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
  var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;

  function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);

    if (matches) {
      if (NO_MATCH_IS_UNDEFINED) {
        //store each component
        components.scheme = matches[1];
        components.userinfo = matches[3];
        components.host = matches[4];
        components.port = parseInt(matches[5], 10);
        components.path = matches[6] || "";
        components.query = matches[7];
        components.fragment = matches[8]; //fix port number

        if (isNaN(components.port)) {
          components.port = matches[5];
        }
      } else {
        //IE FIX for improper RegExp matching
        //store each component
        components.scheme = matches[1] || undefined;
        components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
        components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
        components.port = parseInt(matches[5], 10);
        components.path = matches[6] || "";
        components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
        components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined; //fix port number

        if (isNaN(components.port)) {
          components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
        }
      }

      if (components.host) {
        //normalize IP hosts
        components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
      } //determine reference type


      if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
        components.reference = "same-document";
      } else if (components.scheme === undefined) {
        components.reference = "relative";
      } else if (components.fragment === undefined) {
        components.reference = "absolute";
      } else {
        components.reference = "uri";
      } //check for reference errors


      if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
        components.error = components.error || "URI is not a " + options.reference + " reference.";
      } //find scheme handler


      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()]; //check if scheme can't handle IRIs

      if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
        //if host component is a domain name
        if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
          //convert Unicode IDN -> ASCII IDN
          try {
            components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
          }
        } //convert IRI -> URI


        _normalizeComponentEncoding(components, URI_PROTOCOL);
      } else {
        //normalize encodings
        _normalizeComponentEncoding(components, protocol);
      } //perform scheme specific parsing


      if (schemeHandler && schemeHandler.parse) {
        schemeHandler.parse(components, options);
      }
    } else {
      components.error = components.error || "URI can not be parsed.";
    }

    return components;
  }

  function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];

    if (components.userinfo !== undefined) {
      uriTokens.push(components.userinfo);
      uriTokens.push("@");
    }

    if (components.host !== undefined) {
      //normalize IP hosts, add brackets and escape zone separator for IPv6
      uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
        return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
      }));
    }

    if (typeof components.port === "number") {
      uriTokens.push(":");
      uriTokens.push(components.port.toString(10));
    }

    return uriTokens.length ? uriTokens.join("") : undefined;
  }

  var RDS1 = /^\.\.?\//;
  var RDS2 = /^\/\.(\/|$)/;
  var RDS3 = /^\/\.\.(\/|$)/;
  var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;

  function removeDotSegments(input) {
    var output = [];

    while (input.length) {
      if (input.match(RDS1)) {
        input = input.replace(RDS1, "");
      } else if (input.match(RDS2)) {
        input = input.replace(RDS2, "/");
      } else if (input.match(RDS3)) {
        input = input.replace(RDS3, "/");
        output.pop();
      } else if (input === "." || input === "..") {
        input = "";
      } else {
        var im = input.match(RDS5);

        if (im) {
          var s = im[0];
          input = input.slice(s.length);
          output.push(s);
        } else {
          throw new Error("Unexpected dot segment condition");
        }
      }
    }

    return output.join("");
  }

  function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = []; //find scheme handler

    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()]; //perform scheme specific serialization

    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);

    if (components.host) {
      //if host component is an IPv6 address
      if (protocol.IPV6ADDRESS.test(components.host)) {} //TODO: normalize IPv6 address as per RFC 5952
      //if host component is a domain name
      else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
          //convert IDN via punycode
          try {
            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
        }
    } //normalize encoding


    _normalizeComponentEncoding(components, protocol);

    if (options.reference !== "suffix" && components.scheme) {
      uriTokens.push(components.scheme);
      uriTokens.push(":");
    }

    var authority = _recomposeAuthority(components, options);

    if (authority !== undefined) {
      if (options.reference !== "suffix") {
        uriTokens.push("//");
      }

      uriTokens.push(authority);

      if (components.path && components.path.charAt(0) !== "/") {
        uriTokens.push("/");
      }
    }

    if (components.path !== undefined) {
      var s = components.path;

      if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
        s = removeDotSegments(s);
      }

      if (authority === undefined) {
        s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
      }

      uriTokens.push(s);
    }

    if (components.query !== undefined) {
      uriTokens.push("?");
      uriTokens.push(components.query);
    }

    if (components.fragment !== undefined) {
      uriTokens.push("#");
      uriTokens.push(components.fragment);
    }

    return uriTokens.join(""); //merge tokens into a string
  }

  function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];
    var target = {};

    if (!skipNormalization) {
      base = parse(serialize(base, options), options); //normalize base components

      relative = parse(serialize(relative, options), options); //normalize relative components
    }

    options = options || {};

    if (!options.tolerant && relative.scheme) {
      target.scheme = relative.scheme; //target.authority = relative.authority;

      target.userinfo = relative.userinfo;
      target.host = relative.host;
      target.port = relative.port;
      target.path = removeDotSegments(relative.path || "");
      target.query = relative.query;
    } else {
      if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (!relative.path) {
          target.path = base.path;

          if (relative.query !== undefined) {
            target.query = relative.query;
          } else {
            target.query = base.query;
          }
        } else {
          if (relative.path.charAt(0) === "/") {
            target.path = removeDotSegments(relative.path);
          } else {
            if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
              target.path = "/" + relative.path;
            } else if (!base.path) {
              target.path = relative.path;
            } else {
              target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
            }

            target.path = removeDotSegments(target.path);
          }

          target.query = relative.query;
        } //target.authority = base.authority;


        target.userinfo = base.userinfo;
        target.host = base.host;
        target.port = base.port;
      }

      target.scheme = base.scheme;
    }

    target.fragment = relative.fragment;
    return target;
  }

  function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({
      scheme: 'null'
    }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
  }

  function normalize(uri, options) {
    if (typeof uri === "string") {
      uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
      uri = parse(serialize(uri, options), options);
    }

    return uri;
  }

  function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
      uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
      uriA = serialize(uriA, options);
    }

    if (typeof uriB === "string") {
      uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
      uriB = serialize(uriB, options);
    }

    return uriA === uriB;
  }

  function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
  }

  function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
  }

  var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
      //report missing host
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }

      return components;
    },
    serialize: function serialize(components, options) {
      //normalize the default port
      if (components.port === (String(components.scheme).toLowerCase() !== "https" ? 80 : 443) || components.port === "") {
        components.port = undefined;
      } //normalize the empty path


      if (!components.path) {
        components.path = "/";
      } //NOTE: We do not parse query strings for HTTP URIs
      //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
      //and not the HTTP spec.


      return components;
    }
  };
  var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
  };
  var O = {};
  var isIRI = true; //RFC 3986

  var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
  var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive

  var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
  //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
  //const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
  //const WSP$$ = "[\\x20\\x09]";
  //const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
  //const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
  //const VCHAR$$ = "[\\x21-\\x7E]";
  //const WSP$$ = "[\\x20\\x09]";
  //const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
  //const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
  //const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
  //const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');

  var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
  var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
  var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
  var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
  var UNRESERVED = new RegExp(UNRESERVED$$, "g");
  var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
  var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
  var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
  var NOT_HFVALUE = NOT_HFNAME;

  function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
  }

  var handler$2 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
      var mailtoComponents = components;
      var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
      mailtoComponents.path = undefined;

      if (mailtoComponents.query) {
        var unknownHeaders = false;
        var headers = {};
        var hfields = mailtoComponents.query.split("&");

        for (var x = 0, xl = hfields.length; x < xl; ++x) {
          var hfield = hfields[x].split("=");

          switch (hfield[0]) {
            case "to":
              var toAddrs = hfield[1].split(",");

              for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                to.push(toAddrs[_x]);
              }

              break;

            case "subject":
              mailtoComponents.subject = unescapeComponent(hfield[1], options);
              break;

            case "body":
              mailtoComponents.body = unescapeComponent(hfield[1], options);
              break;

            default:
              unknownHeaders = true;
              headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
              break;
          }
        }

        if (unknownHeaders) mailtoComponents.headers = headers;
      }

      mailtoComponents.query = undefined;

      for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
        var addr = to[_x2].split("@");

        addr[0] = unescapeComponent(addr[0]);

        if (!options.unicodeSupport) {
          //convert Unicode IDN -> ASCII IDN
          try {
            addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
          } catch (e) {
            mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
          }
        } else {
          addr[1] = unescapeComponent(addr[1], options).toLowerCase();
        }

        to[_x2] = addr.join("@");
      }

      return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
      var components = mailtoComponents;
      var to = toArray(mailtoComponents.to);

      if (to) {
        for (var x = 0, xl = to.length; x < xl; ++x) {
          var toAddr = String(to[x]);
          var atIdx = toAddr.lastIndexOf("@");
          var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
          var domain = toAddr.slice(atIdx + 1); //convert IDN via punycode

          try {
            domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
          } catch (e) {
            components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }

          to[x] = localPart + "@" + domain;
        }

        components.path = to.join(",");
      }

      var headers = mailtoComponents.headers = mailtoComponents.headers || {};
      if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
      if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
      var fields = [];

      for (var name in headers) {
        if (headers[name] !== O[name]) {
          fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
        }
      }

      if (fields.length) {
        components.query = fields.join("&");
      }

      return components;
    }
  };
  var URN_PARSE = /^([^\:]+)\:(.*)/; //RFC 2141

  var handler$3 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
      var matches = components.path && components.path.match(URN_PARSE);
      var urnComponents = components;

      if (matches) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = matches[1].toLowerCase();
        var nss = matches[2];
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        urnComponents.nid = nid;
        urnComponents.nss = nss;
        urnComponents.path = undefined;

        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }

      return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
      var scheme = options.scheme || urnComponents.scheme || "urn";
      var nid = urnComponents.nid;
      var urnScheme = scheme + ":" + (options.nid || nid);
      var schemeHandler = SCHEMES[urnScheme];

      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }

      var uriComponents = urnComponents;
      var nss = urnComponents.nss;
      uriComponents.path = (nid || options.nid) + ":" + nss;
      return uriComponents;
    }
  };
  var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/; //RFC 4122

  var handler$4 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
      var uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = undefined;

      if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }

      return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
      var urnComponents = uuidComponents; //normalize UUID

      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
  };
  SCHEMES[handler.scheme] = handler;
  SCHEMES[handler$1.scheme] = handler$1;
  SCHEMES[handler$2.scheme] = handler$2;
  SCHEMES[handler$3.scheme] = handler$3;
  SCHEMES[handler$4.scheme] = handler$4;
  exports.SCHEMES = SCHEMES;
  exports.pctEncChar = pctEncChar;
  exports.pctDecChars = pctDecChars;
  exports.parse = parse;
  exports.removeDotSegments = removeDotSegments;
  exports.serialize = serialize;
  exports.resolveComponents = resolveComponents;
  exports.resolve = resolve;
  exports.normalize = normalize;
  exports.equal = equal;
  exports.escapeComponent = escapeComponent;
  exports.unescapeComponent = unescapeComponent;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),

/***/ "./node_modules/webpack/node_modules/path-browserify/index.js":
/*!*******************************************************!*\
  !*** (webpack)/node_modules/path-browserify/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;

  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];

    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
} // path.resolve([from ...], to)
// posix version


exports.resolve = function () {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : process.cwd(); // Skip empty and invalid entries

    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  } // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)
  // Normalize the path


  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
    return !!p;
  }), !resolvedAbsolute).join('/');
  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
}; // path.normalize(path)
// posix version


exports.normalize = function (path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/'; // Normalize the path

  path = normalizeArray(filter(path.split('/'), function (p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }

  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
}; // posix version


exports.isAbsolute = function (path) {
  return path.charAt(0) === '/';
}; // posix version


exports.join = function () {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function (p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }

    return p;
  }).join('/'));
}; // path.relative(from, to)
// posix version


exports.relative = function (from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;

    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;

    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;

  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];

  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47
  /*/*/
  ;
  var end = -1;
  var matchedSlash = true;

  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);

    if (code === 47
    /*/*/
    ) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';

  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }

  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';
  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47
    /*/*/
    ) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
} // Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here


exports.basename = function (path, ext) {
  var f = basename(path);

  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }

  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find

  var preDotState = 0;

  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);

    if (code === 47
    /*/*/
    ) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }

        continue;
      }

    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }

    if (code === 46
    /*.*/
    ) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }

  return path.slice(startDot, end);
};

function filter(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs)) res.push(xs[i]);
  }

  return res;
} // String.prototype.substr - negative index don't work in IE8


var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
  return str.substr(start, len);
} : function (str, start, len) {
  if (start < 0) start = str.length + start;
  return str.substr(start, len);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Kc29uUmVmcy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL2luZGV4LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2luZGV4LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvY29tcG9uZW50cy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2Rmcy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2RpamtzdHJhLWFsbC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2RpamtzdHJhLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvZmluZC1jeWNsZXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9mbG95ZC13YXJzaGFsbC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2luZGV4LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvaXMtYWN5Y2xpYy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3Bvc3RvcmRlci5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3ByZW9yZGVyLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvcHJpbS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3Rhcmphbi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3RvcHNvcnQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2RhdGEvcHJpb3JpdHktcXVldWUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2dyYXBoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvanNvbi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvbG9kYXNoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi92ZXJzaW9uLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fRGF0YVZpZXcuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19IYXNoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19Qcm9taXNlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0Q2FjaGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TdGFjay5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19XZWFrTWFwLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUVhY2guanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUZpbHRlci5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUluY2x1ZGVzV2l0aC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UmVkdWNlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlTb21lLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNjaWlTaXplLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbkluLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNsb25lLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VFYWNoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZpbHRlci5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGaW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yT3duLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzSW4uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTWFwLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTWF0Y2guanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYU4uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYXRpdmUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNTZXQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hcC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVkdWNlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5pcS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VWYWx1ZXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVEYXRhVmlldy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lUmVnRXhwLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVR5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VFYWNoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZVNldC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEJ5VGFnLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxPYmplY3RzLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWF0Y2hEYXRhLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9scy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHNJbi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFRhZy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc1VuaWNvZGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQXJyYXkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVCeVRhZy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNTdHJpY3RDb21wYXJhYmxlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBUb0FycmF5LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlclJlc3QuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0hhcy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaWN0SW5kZXhPZi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmluZ1NpemUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb1BhdGguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdW5pY29kZVNpemUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2Nsb25lLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZWFjaC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZm9yRWFjaC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZ2V0LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2hhc0luLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRW1wdHkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTGVuZ3RoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc01hcC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTZXQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3RyaW5nLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1VuZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5cy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5c0luLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9sb2Rhc2guanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL21hcC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVtb2l6ZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbm9vcC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3JlZHVjZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc2l6ZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkFycmF5LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3VuaW9uLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC92YWx1ZXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbmF0aXZlLXByb21pc2Utb25seS9saWIvbnBvLnNyYy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9wYXRoLWxvYWRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9wYXRoLWxvYWRlci9saWIvbG9hZGVycy9maWxlLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvcGF0aC1sb2FkZXIvbGliL2xvYWRlcnMvaHR0cC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL3NsYXNoL2luZGV4LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2FnZW50LWJhc2UuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvY2xpZW50LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9yZXF1ZXN0LWJhc2UuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvcmVzcG9uc2UtYmFzZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4uLy4uL3NyYy91dGlsLnRzIiwid2VicGFjazovL0pzb25SZWZzLy4uLy4uL3NyYy9yZWdleHBzLXVyaS50cyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uLi8uLi9zcmMvcmVnZXhwcy1pcmkudHMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi4vLi4vbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmVzNi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uLi8uLi9zcmMvdXJpLnRzIiwid2VicGFjazovL0pzb25SZWZzLy4uLy4uL3NyYy9zY2hlbWVzL2h0dHAudHMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi4vLi4vc3JjL3NjaGVtZXMvaHR0cHMudHMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi4vLi4vc3JjL3NjaGVtZXMvbWFpbHRvLnRzIiwid2VicGFjazovL0pzb25SZWZzLy4uLy4uL3NyYy9zY2hlbWVzL3Vybi50cyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uLi8uLi9zcmMvc2NoZW1lcy91cm4tdXVpZC50cyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uLi8uLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovL0pzb25SZWZzLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8od2VicGFjaykvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyJdLCJuYW1lcyI6WyJfIiwicmVxdWlyZSIsImdsIiwicGF0aCIsIlBhdGhMb2FkZXIiLCJxcyIsInNsYXNoIiwiVVJJIiwiYmFkUHRyVG9rZW5SZWdleCIsInJlbW90ZUNhY2hlIiwicmVtb3RlVHlwZXMiLCJyZW1vdGVVcmlUeXBlcyIsInVyaURldGFpbHNDYWNoZSIsIlByb21pc2UiLCJjb21iaW5lUXVlcnlQYXJhbXMiLCJxczEiLCJxczIiLCJjb21iaW5lZCIsIm1lcmdlUXVlcnlQYXJhbXMiLCJvYmoiLCJmb3JPd24iLCJ2YWwiLCJrZXkiLCJwYXJzZSIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJzdHJpbmdpZnkiLCJjb21iaW5lVVJJcyIsInUxIiwidTIiLCJpc1N0cmluZyIsInUyRGV0YWlscyIsInBhcnNlVVJJIiwiaXNVbmRlZmluZWQiLCJ1MURldGFpbHMiLCJjb21iaW5lZERldGFpbHMiLCJpbmRleE9mIiwicmVmZXJlbmNlIiwiam9pbiIsInF1ZXJ5IiwiZnJhZ21lbnQiLCJzZXJpYWxpemUiLCJmaW5kQW5jZXN0b3JzIiwiYW5jZXN0b3JzIiwibm9kZSIsInNsaWNlIiwiZm9yRWFjaCIsInNlZyIsInB1c2giLCJpc1JlbW90ZSIsInJlZkRldGFpbHMiLCJnZXRSZWZUeXBlIiwiaXNWYWxpZCIsImVycm9yIiwidHlwZSIsImZpbmRWYWx1ZSIsInZhbHVlIiwiRXJyb3IiLCJwYXRoVG9QdHIiLCJnZXRFeHRyYVJlZktleXMiLCJyZWYiLCJmaWx0ZXIiLCJ1cmlEZXRhaWxzIiwiZ2V0UmVtb3RlRG9jdW1lbnQiLCJ1cmwiLCJvcHRpb25zIiwiY2FjaGVFbnRyeSIsImFsbFRhc2tzIiwicmVzb2x2ZSIsImxvYWRlck9wdGlvbnMiLCJjbG9uZURlZXAiLCJwcm9jZXNzQ29udGVudCIsInJlcyIsImNhbGxiYWNrIiwiSlNPTiIsInRleHQiLCJsb2FkIiwiZGVjb2RlVVJJIiwidGhlbiIsImVyciIsImlzRXJyb3IiLCJpc1JlZkxpa2UiLCJ0aHJvd1dpdGhEZXRhaWxzIiwicmVmTGlrZSIsImlzUGxhaW5PYmplY3QiLCIkcmVmIiwibWFrZUFic29sdXRlIiwibG9jYXRpb24iLCJpc0Fic29sdXRlIiwicHJvY2VzcyIsImN3ZCIsIm1ha2VSZWZGaWx0ZXIiLCJyZWZGaWx0ZXIiLCJ2YWxpZFR5cGVzIiwiaXNBcnJheSIsImlzRnVuY3Rpb24iLCJpbmNsdWRlSW52YWxpZCIsIm1ha2VTdWJEb2NQYXRoIiwic3ViRG9jUGF0aCIsInBhdGhGcm9tUHRyIiwibWFya01pc3NpbmciLCJtZXNzYWdlIiwibWlzc2luZyIsInVyaSIsImJ1aWxkUmVmTW9kZWwiLCJkb2N1bWVudCIsIm1ldGFkYXRhIiwic3ViRG9jUHRyIiwiYWJzTG9jYXRpb24iLCJyZWxhdGl2ZUJhc2UiLCJkaXJuYW1lIiwiZG9jRGVwS2V5IiwicmVmcyIsInJPcHRpb25zIiwiZG9jcyIsImRlcHMiLCJmaW5kUmVmcyIsInJlZlB0ciIsInJlZktleSIsInJlZmRLZXkiLCJyZWZkSWQiLCJzcGxpdCIsImZxVVJJIiwicmVwbGFjZSIsImNpcmN1bGFyIiwibk1ldGFkYXRhIiwibk9wdGlvbnMiLCJyQWJzTG9jYXRpb24iLCJyRG9jIiwiblJlZkRldGFpbHMiLCJkb2MiLCJzZXRWYWx1ZSIsInJlZlBhdGgiLCJ3YWxrIiwiZm4iLCJwcm9jZXNzQ2hpbGRyZW4iLCJ3YWxrSXRlbSIsIml0ZW0iLCJzZWdtZW50IiwicG9wIiwibWVtYmVyIiwiaW5kZXgiLCJ0b1N0cmluZyIsImlzT2JqZWN0IiwiY05vZGUiLCJ2YWxpZGF0ZU9wdGlvbnMiLCJsb2NhdGlvblBhcnRzIiwic2hvdWxkRGVjb2RlIiwiVHlwZUVycm9yIiwicmVzb2x2ZUNpcmN1bGFycyIsImlzQm9vbGVhbiIsInJlZlByZVByb2Nlc3NvciIsInJlZlBvc3RQcm9jZXNzb3IiLCJpc1B0ciIsImRlY29kZVBhdGgiLCJtYXAiLCJlbmNvZGVQYXRoIiwiZ2V0UmVmRGV0YWlscyIsImZpbmRSZWZzQXQiLCJjT3B0aW9ucyIsImRldGFpbHMiLCJkZWYiLCJjYWNoZUtleSIsImV4dHJhS2V5cyIsIndhcm5pbmciLCJwdHIiLCJ2YWxpZCIsImZpcnN0Q2hhciIsImNoYXJBdCIsIm1hdGNoIiwiaXNSZWYiLCJzZWdtZW50cyIsInNoaWZ0IiwiaGFzaFByZWZpeCIsInJlc29sdmVSZWZzIiwicmVzdWx0cyIsImFsbFJlZnMiLCJjaXJjdWxhclBhdGhzIiwiY2lyY3VsYXJzIiwiZGVwR3JhcGgiLCJHcmFwaCIsImZ1bGxMb2NhdGlvbiIsInJlZnNSb290Iiwic2V0Tm9kZSIsInByb3BzIiwiZGVwIiwic2V0RWRnZSIsImFsZyIsImZpbmRDeWNsZXMiLCJwcm9wIiwiaXNDaXJjdWxhciIsInJlbW90ZSIsInBhdGhJbmRleCIsInJldmVyc2UiLCJwYXJlbnRQdHIiLCJwUHRyUGFydHMiLCJwRG9jdW1lbnQiLCJwUHRyUGF0aCIsImRlcFBhcnRzIiwiZERvY3VtZW50IiwiZFB0clBhdGgiLCJjb25jYXQiLCJ3YWxrUmVmcyIsInJvb3QiLCJyZWZQdHJQYXJ0cyIsInJlZkRlcHMiLCJzdWJzdHIiLCJmcVVSSVNlZ21lbnRzIiwidXJpU2VnbWVudHMiLCJ0aW1lcyIsInRpbWUiLCJuU2VnIiwicFNlZyIsImZxU2VnSW5kZXgiLCJyZXNvbHZlZCIsInJlc29sdmVSZWZzQXQiLCJyZXMyIiwibW9kdWxlIiwiZXhwb3J0cyIsImNsZWFyQ2FjaGUiLCJFbWl0dGVyIiwibWl4aW4iLCJwcm90b3R5cGUiLCJvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsIl9jYWxsYmFja3MiLCJvbmNlIiwib2ZmIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYWxsYmFja3MiLCJjYiIsImkiLCJzcGxpY2UiLCJlbWl0IiwiYXJncyIsImNhbGwiLCJsZW4iLCJsaXN0ZW5lcnMiLCJoYXNMaXN0ZW5lcnMiLCJsaWIiLCJqc29uIiwidmVyc2lvbiIsImNvbXBvbmVudHMiLCJnIiwidmlzaXRlZCIsImNtcHRzIiwiY21wdCIsImRmcyIsInYiLCJoYXMiLCJlYWNoIiwic3VjY2Vzc29ycyIsInByZWRlY2Vzc29ycyIsIm5vZGVzIiwidnMiLCJvcmRlciIsIm5hdmlnYXRpb24iLCJpc0RpcmVjdGVkIiwibmVpZ2hib3JzIiwiYmluZCIsImFjYyIsImhhc05vZGUiLCJkb0RmcyIsInBvc3RvcmRlciIsInciLCJkaWprc3RyYSIsImRpamtzdHJhQWxsIiwid2VpZ2h0RnVuYyIsImVkZ2VGdW5jIiwidHJhbnNmb3JtIiwiUHJpb3JpdHlRdWV1ZSIsIkRFRkFVTFRfV0VJR0hUX0ZVTkMiLCJjb25zdGFudCIsInNvdXJjZSIsIndlaWdodEZuIiwiZWRnZUZuIiwicnVuRGlqa3N0cmEiLCJTdHJpbmciLCJvdXRFZGdlcyIsInBxIiwidkVudHJ5IiwidXBkYXRlTmVpZ2hib3JzIiwiZWRnZSIsIndFbnRyeSIsIndlaWdodCIsImRpc3RhbmNlIiwicHJlZGVjZXNzb3IiLCJkZWNyZWFzZSIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwiYWRkIiwic2l6ZSIsInJlbW92ZU1pbiIsInRhcmphbiIsImhhc0VkZ2UiLCJmbG95ZFdhcnNoYWxsIiwicnVuRmxveWRXYXJzaGFsbCIsImQiLCJrIiwicm93SyIsInJvd0kiLCJqIiwiaWsiLCJraiIsImlqIiwiYWx0RGlzdGFuY2UiLCJpc0FjeWNsaWMiLCJwcmVvcmRlciIsInByaW0iLCJ0b3Bzb3J0IiwiZSIsIkN5Y2xlRXhjZXB0aW9uIiwicmVzdWx0IiwicGFyZW50cyIsInByaSIsInByaW9yaXR5IiwiZWRnZVdlaWdodCIsIm5vZGVDb3VudCIsImluaXQiLCJub2RlRWRnZXMiLCJzdGFjayIsImVudHJ5Iiwib25TdGFjayIsImxvd2xpbmsiLCJNYXRoIiwibWluIiwidmlzaXQiLCJzaW5rcyIsIl9hcnIiLCJfa2V5SW5kaWNlcyIsIngiLCJrZXlJbmRpY2VzIiwiYXJyIiwiX2RlY3JlYXNlIiwiX3N3YXAiLCJfaGVhcGlmeSIsImwiLCJyIiwibGFyZ2VzdCIsInBhcmVudCIsIm9yaWdBcnJJIiwib3JpZ0FyckoiLCJERUZBVUxUX0VER0VfTkFNRSIsIkdSQVBIX05PREUiLCJFREdFX0tFWV9ERUxJTSIsIm9wdHMiLCJfaXNEaXJlY3RlZCIsImRpcmVjdGVkIiwiX2lzTXVsdGlncmFwaCIsIm11bHRpZ3JhcGgiLCJfaXNDb21wb3VuZCIsImNvbXBvdW5kIiwiX2xhYmVsIiwiX2RlZmF1bHROb2RlTGFiZWxGbiIsIl9kZWZhdWx0RWRnZUxhYmVsRm4iLCJfbm9kZXMiLCJfcGFyZW50IiwiX2NoaWxkcmVuIiwiX2luIiwiX3ByZWRzIiwiX291dCIsIl9zdWNzIiwiX2VkZ2VPYmpzIiwiX2VkZ2VMYWJlbHMiLCJfbm9kZUNvdW50IiwiX2VkZ2VDb3VudCIsImlzTXVsdGlncmFwaCIsImlzQ29tcG91bmQiLCJzZXRHcmFwaCIsImxhYmVsIiwiZ3JhcGgiLCJzZXREZWZhdWx0Tm9kZUxhYmVsIiwibmV3RGVmYXVsdCIsInNvdXJjZXMiLCJzZWxmIiwiaXNFbXB0eSIsInNldE5vZGVzIiwicmVtb3ZlTm9kZSIsInJlbW92ZUVkZ2UiLCJfcmVtb3ZlRnJvbVBhcmVudHNDaGlsZExpc3QiLCJjaGlsZHJlbiIsImNoaWxkIiwic2V0UGFyZW50IiwiYW5jZXN0b3IiLCJwcmVkc1YiLCJzdWNzViIsInByZWRzIiwidW5pb24iLCJpc0xlYWYiLCJmaWx0ZXJOb2RlcyIsImNvcHkiLCJjb25zdHJ1Y3RvciIsImZpbmRQYXJlbnQiLCJzZXREZWZhdWx0RWRnZUxhYmVsIiwiZWRnZUNvdW50IiwiZWRnZXMiLCJ2YWx1ZXMiLCJzZXRQYXRoIiwicmVkdWNlIiwibmFtZSIsInZhbHVlU3BlY2lmaWVkIiwiYXJnMCIsImVkZ2VBcmdzVG9JZCIsImVkZ2VPYmoiLCJlZGdlQXJnc1RvT2JqIiwiZnJlZXplIiwiaW5jcmVtZW50T3JJbml0RW50cnkiLCJlZGdlT2JqVG9JZCIsImRlY3JlbWVudE9yUmVtb3ZlRW50cnkiLCJpbkVkZ2VzIiwidSIsImluViIsIm91dFYiLCJ2XyIsIndfIiwidG1wIiwid3JpdGUiLCJyZWFkIiwid3JpdGVOb2RlcyIsIndyaXRlRWRnZXMiLCJjbG9uZSIsIm5vZGVWYWx1ZSIsImVkZ2VWYWx1ZSIsImxvZGFzaCIsIndpbmRvdyIsImdldE5hdGl2ZSIsIkRhdGFWaWV3IiwiaGFzaENsZWFyIiwiaGFzaERlbGV0ZSIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkhhc2giLCJlbnRyaWVzIiwiY2xlYXIiLCJzZXQiLCJnZXQiLCJsaXN0Q2FjaGVDbGVhciIsImxpc3RDYWNoZURlbGV0ZSIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIkxpc3RDYWNoZSIsIk1hcCIsIm1hcENhY2hlQ2xlYXIiLCJtYXBDYWNoZURlbGV0ZSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIk1hcENhY2hlIiwiU2V0Iiwic2V0Q2FjaGVBZGQiLCJzZXRDYWNoZUhhcyIsIlNldENhY2hlIiwiX19kYXRhX18iLCJzdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJzdGFja0dldCIsInN0YWNrSGFzIiwic3RhY2tTZXQiLCJTdGFjayIsImRhdGEiLCJTeW1ib2wiLCJVaW50OEFycmF5IiwiV2Vha01hcCIsImZ1bmMiLCJ0aGlzQXJnIiwiYXJyYXlFYWNoIiwiYXJyYXkiLCJpdGVyYXRlZSIsImFycmF5RmlsdGVyIiwicHJlZGljYXRlIiwicmVzSW5kZXgiLCJiYXNlSW5kZXhPZiIsImFycmF5SW5jbHVkZXMiLCJhcnJheUluY2x1ZGVzV2l0aCIsImNvbXBhcmF0b3IiLCJiYXNlVGltZXMiLCJpc0FyZ3VtZW50cyIsImlzQnVmZmVyIiwiaXNJbmRleCIsImlzVHlwZWRBcnJheSIsIm9iamVjdFByb3RvIiwiaGFzT3duUHJvcGVydHkiLCJhcnJheUxpa2VLZXlzIiwiaW5oZXJpdGVkIiwiaXNBcnIiLCJpc0FyZyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiYXJyYXlNYXAiLCJBcnJheSIsImFycmF5UHVzaCIsIm9mZnNldCIsImFycmF5UmVkdWNlIiwiYWNjdW11bGF0b3IiLCJpbml0QWNjdW0iLCJhcnJheVNvbWUiLCJiYXNlUHJvcGVydHkiLCJhc2NpaVNpemUiLCJiYXNlQXNzaWduVmFsdWUiLCJlcSIsImFzc2lnblZhbHVlIiwib2JqZWN0Iiwib2JqVmFsdWUiLCJhc3NvY0luZGV4T2YiLCJjb3B5T2JqZWN0IiwiYmFzZUFzc2lnbiIsImtleXNJbiIsImJhc2VBc3NpZ25JbiIsImRlZmluZVByb3BlcnR5IiwiY2xvbmVCdWZmZXIiLCJjb3B5QXJyYXkiLCJjb3B5U3ltYm9scyIsImNvcHlTeW1ib2xzSW4iLCJnZXRBbGxLZXlzIiwiZ2V0QWxsS2V5c0luIiwiZ2V0VGFnIiwiaW5pdENsb25lQXJyYXkiLCJpbml0Q2xvbmVCeVRhZyIsImluaXRDbG9uZU9iamVjdCIsImlzTWFwIiwiaXNTZXQiLCJDTE9ORV9ERUVQX0ZMQUciLCJDTE9ORV9GTEFUX0ZMQUciLCJDTE9ORV9TWU1CT0xTX0ZMQUciLCJhcmdzVGFnIiwiYXJyYXlUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm9iamVjdFRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsInN5bWJvbFRhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwiY2xvbmVhYmxlVGFncyIsImJhc2VDbG9uZSIsImJpdG1hc2siLCJjdXN0b21pemVyIiwiaXNEZWVwIiwiaXNGbGF0IiwiaXNGdWxsIiwidGFnIiwiaXNGdW5jIiwic3RhY2tlZCIsInN1YlZhbHVlIiwia2V5c0Z1bmMiLCJvYmplY3RDcmVhdGUiLCJjcmVhdGUiLCJiYXNlQ3JlYXRlIiwicHJvdG8iLCJiYXNlRm9yT3duIiwiY3JlYXRlQmFzZUVhY2giLCJiYXNlRWFjaCIsImJhc2VGaWx0ZXIiLCJjb2xsZWN0aW9uIiwiYmFzZUZpbmRJbmRleCIsImZyb21JbmRleCIsImZyb21SaWdodCIsImlzRmxhdHRlbmFibGUiLCJiYXNlRmxhdHRlbiIsImRlcHRoIiwiaXNTdHJpY3QiLCJjcmVhdGVCYXNlRm9yIiwiYmFzZUZvciIsImNhc3RQYXRoIiwidG9LZXkiLCJiYXNlR2V0IiwiYmFzZUdldEFsbEtleXMiLCJzeW1ib2xzRnVuYyIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJiYXNlR2V0VGFnIiwiYmFzZUhhcyIsImJhc2VIYXNJbiIsImJhc2VJc05hTiIsInN0cmljdEluZGV4T2YiLCJpc09iamVjdExpa2UiLCJiYXNlSXNBcmd1bWVudHMiLCJiYXNlSXNFcXVhbERlZXAiLCJiYXNlSXNFcXVhbCIsIm90aGVyIiwiZXF1YWxBcnJheXMiLCJlcXVhbEJ5VGFnIiwiZXF1YWxPYmplY3RzIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUciLCJlcXVhbEZ1bmMiLCJvYmpJc0FyciIsIm90aElzQXJyIiwib2JqVGFnIiwib3RoVGFnIiwib2JqSXNPYmoiLCJvdGhJc09iaiIsImlzU2FtZVRhZyIsIm9iaklzV3JhcHBlZCIsIm90aElzV3JhcHBlZCIsIm9ialVud3JhcHBlZCIsIm90aFVud3JhcHBlZCIsImJhc2VJc01hcCIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUciLCJiYXNlSXNNYXRjaCIsIm1hdGNoRGF0YSIsIm5vQ3VzdG9taXplciIsInNyY1ZhbHVlIiwiaXNNYXNrZWQiLCJ0b1NvdXJjZSIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsImZ1bmNQcm90byIsIkZ1bmN0aW9uIiwiZnVuY1RvU3RyaW5nIiwicmVJc05hdGl2ZSIsIlJlZ0V4cCIsImJhc2VJc05hdGl2ZSIsInBhdHRlcm4iLCJ0ZXN0IiwiYmFzZUlzU2V0IiwiaXNMZW5ndGgiLCJ0eXBlZEFycmF5VGFncyIsImJhc2VJc1R5cGVkQXJyYXkiLCJiYXNlTWF0Y2hlcyIsImJhc2VNYXRjaGVzUHJvcGVydHkiLCJpZGVudGl0eSIsInByb3BlcnR5IiwiYmFzZUl0ZXJhdGVlIiwiaXNQcm90b3R5cGUiLCJuYXRpdmVLZXlzIiwiYmFzZUtleXMiLCJuYXRpdmVLZXlzSW4iLCJiYXNlS2V5c0luIiwiaXNQcm90byIsImlzQXJyYXlMaWtlIiwiYmFzZU1hcCIsImdldE1hdGNoRGF0YSIsIm1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwiaGFzSW4iLCJpc0tleSIsImlzU3RyaWN0Q29tcGFyYWJsZSIsImJhc2VQcm9wZXJ0eURlZXAiLCJiYXNlUmVkdWNlIiwiZWFjaEZ1bmMiLCJvdmVyUmVzdCIsInNldFRvU3RyaW5nIiwiYmFzZVJlc3QiLCJzdGFydCIsImJhc2VTZXRUb1N0cmluZyIsInN0cmluZyIsIm4iLCJpc1N5bWJvbCIsIklORklOSVRZIiwic3ltYm9sUHJvdG8iLCJzeW1ib2xUb1N0cmluZyIsImJhc2VUb1N0cmluZyIsImJhc2VVbmFyeSIsImNhY2hlSGFzIiwiY3JlYXRlU2V0Iiwic2V0VG9BcnJheSIsIkxBUkdFX0FSUkFZX1NJWkUiLCJiYXNlVW5pcSIsImluY2x1ZGVzIiwiaXNDb21tb24iLCJzZWVuIiwib3V0ZXIiLCJjb21wdXRlZCIsInNlZW5JbmRleCIsImJhc2VWYWx1ZXMiLCJjYWNoZSIsImNhc3RGdW5jdGlvbiIsInN0cmluZ1RvUGF0aCIsImNsb25lQXJyYXlCdWZmZXIiLCJhcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsImJ1ZmZlciIsImNsb25lRGF0YVZpZXciLCJkYXRhVmlldyIsImJ5dGVPZmZzZXQiLCJyZUZsYWdzIiwiY2xvbmVSZWdFeHAiLCJyZWdleHAiLCJleGVjIiwibGFzdEluZGV4Iiwic3ltYm9sVmFsdWVPZiIsInZhbHVlT2YiLCJjbG9uZVN5bWJvbCIsInN5bWJvbCIsImNsb25lVHlwZWRBcnJheSIsInR5cGVkQXJyYXkiLCJpc05ldyIsIm5ld1ZhbHVlIiwiZ2V0U3ltYm9scyIsImdldFN5bWJvbHNJbiIsImNvcmVKc0RhdGEiLCJpdGVyYWJsZSIsIm5vb3AiLCJpc1BhcnRpYWwiLCJhcnJMZW5ndGgiLCJvdGhMZW5ndGgiLCJhcnJWYWx1ZSIsIm90aFZhbHVlIiwiY29tcGFyZWQiLCJvdGhJbmRleCIsIm1hcFRvQXJyYXkiLCJjb252ZXJ0Iiwib2JqUHJvcHMiLCJvYmpMZW5ndGgiLCJvdGhQcm9wcyIsInNraXBDdG9yIiwib2JqQ3RvciIsIm90aEN0b3IiLCJmcmVlR2xvYmFsIiwiZ2xvYmFsIiwiaXNLZXlhYmxlIiwiZ2V0TWFwRGF0YSIsImdldFZhbHVlIiwib3ZlckFyZyIsImdldFByb3RvdHlwZSIsImdldFByb3RvdHlwZU9mIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJpc093biIsInVubWFza2VkIiwic3R1YkFycmF5IiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJuYXRpdmVHZXRTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvbWlzZVRhZyIsImRhdGFWaWV3Q3RvclN0cmluZyIsIm1hcEN0b3JTdHJpbmciLCJwcm9taXNlQ3RvclN0cmluZyIsInNldEN0b3JTdHJpbmciLCJ3ZWFrTWFwQ3RvclN0cmluZyIsIkFycmF5QnVmZmVyIiwiQ3RvciIsImN0b3JTdHJpbmciLCJoYXNQYXRoIiwiaGFzRnVuYyIsInJzQXN0cmFsUmFuZ2UiLCJyc0NvbWJvTWFya3NSYW5nZSIsInJlQ29tYm9IYWxmTWFya3NSYW5nZSIsInJzQ29tYm9TeW1ib2xzUmFuZ2UiLCJyc0NvbWJvUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNaV0oiLCJyZUhhc1VuaWNvZGUiLCJoYXNVbmljb2RlIiwibmF0aXZlQ3JlYXRlIiwiSEFTSF9VTkRFRklORUQiLCJpbnB1dCIsInNwcmVhZGFibGVTeW1ib2wiLCJpc0NvbmNhdFNwcmVhZGFibGUiLCJNQVhfU0FGRV9JTlRFR0VSIiwicmVJc1VpbnQiLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwibWFza1NyY0tleSIsInVpZCIsIklFX1BST1RPIiwiYXJyYXlQcm90byIsIm1lbW9pemUiLCJNQVhfTUVNT0laRV9TSVpFIiwibWVtb2l6ZUNhcHBlZCIsImZyZWVQcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsImJpbmRpbmciLCJhcmciLCJuYXRpdmVNYXgiLCJtYXgiLCJvdGhlckFyZ3MiLCJmcmVlU2VsZiIsInNob3J0T3V0IiwiSE9UX0NPVU5UIiwiSE9UX1NQQU4iLCJuYXRpdmVOb3ciLCJEYXRlIiwibm93IiwiY291bnQiLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJyZW1haW5pbmciLCJwYWlycyIsInVuaWNvZGVTaXplIiwic3RyaW5nU2l6ZSIsInJlUHJvcE5hbWUiLCJyZUVzY2FwZUNoYXIiLCJjaGFyQ29kZUF0IiwibnVtYmVyIiwicXVvdGUiLCJzdWJTdHJpbmciLCJyc0FzdHJhbCIsInJzQ29tYm8iLCJyc0ZpdHoiLCJyc01vZGlmaWVyIiwicnNOb25Bc3RyYWwiLCJyc1JlZ2lvbmFsIiwicnNTdXJyUGFpciIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJyc1NlcSIsInJzU3ltYm9sIiwicmVVbmljb2RlIiwiZGVmYXVsdFZhbHVlIiwiaXNBcnJheUxpa2VPYmplY3QiLCJzdHViRmFsc2UiLCJuYXRpdmVJc0J1ZmZlciIsImFzeW5jVGFnIiwicHJveHlUYWciLCJub2RlSXNNYXAiLCJub2RlSXNTZXQiLCJub2RlSXNUeXBlZEFycmF5IiwiVkVSU0lPTiIsIkNPUkVfRVJST1JfVEVYVCIsIkZVTkNfRVJST1JfVEVYVCIsIlBMQUNFSE9MREVSIiwiV1JBUF9CSU5EX0ZMQUciLCJXUkFQX0JJTkRfS0VZX0ZMQUciLCJXUkFQX0NVUlJZX0JPVU5EX0ZMQUciLCJXUkFQX0NVUlJZX0ZMQUciLCJXUkFQX0NVUlJZX1JJR0hUX0ZMQUciLCJXUkFQX1BBUlRJQUxfRkxBRyIsIldSQVBfUEFSVElBTF9SSUdIVF9GTEFHIiwiV1JBUF9BUllfRkxBRyIsIldSQVBfUkVBUkdfRkxBRyIsIldSQVBfRkxJUF9GTEFHIiwiREVGQVVMVF9UUlVOQ19MRU5HVEgiLCJERUZBVUxUX1RSVU5DX09NSVNTSU9OIiwiTEFaWV9GSUxURVJfRkxBRyIsIkxBWllfTUFQX0ZMQUciLCJMQVpZX1dISUxFX0ZMQUciLCJNQVhfSU5URUdFUiIsIk5BTiIsIk1BWF9BUlJBWV9MRU5HVEgiLCJNQVhfQVJSQVlfSU5ERVgiLCJIQUxGX01BWF9BUlJBWV9MRU5HVEgiLCJ3cmFwRmxhZ3MiLCJkb21FeGNUYWciLCJ3ZWFrU2V0VGFnIiwicmVFbXB0eVN0cmluZ0xlYWRpbmciLCJyZUVtcHR5U3RyaW5nTWlkZGxlIiwicmVFbXB0eVN0cmluZ1RyYWlsaW5nIiwicmVFc2NhcGVkSHRtbCIsInJlVW5lc2NhcGVkSHRtbCIsInJlSGFzRXNjYXBlZEh0bWwiLCJyZUhhc1VuZXNjYXBlZEh0bWwiLCJyZUVzY2FwZSIsInJlRXZhbHVhdGUiLCJyZUludGVycG9sYXRlIiwicmVIYXNSZWdFeHBDaGFyIiwicmVUcmltIiwicmVUcmltU3RhcnQiLCJyZVRyaW1FbmQiLCJyZVdyYXBDb21tZW50IiwicmVXcmFwRGV0YWlscyIsInJlU3BsaXREZXRhaWxzIiwicmVBc2NpaVdvcmQiLCJyZUVzVGVtcGxhdGUiLCJyZUlzQmFkSGV4IiwicmVJc0JpbmFyeSIsInJlSXNPY3RhbCIsInJlTGF0aW4iLCJyZU5vTWF0Y2giLCJyZVVuZXNjYXBlZFN0cmluZyIsInJzRGluZ2JhdFJhbmdlIiwicnNMb3dlclJhbmdlIiwicnNNYXRoT3BSYW5nZSIsInJzTm9uQ2hhclJhbmdlIiwicnNQdW5jdHVhdGlvblJhbmdlIiwicnNTcGFjZVJhbmdlIiwicnNVcHBlclJhbmdlIiwicnNCcmVha1JhbmdlIiwicnNBcG9zIiwicnNCcmVhayIsInJzRGlnaXRzIiwicnNEaW5nYmF0IiwicnNMb3dlciIsInJzTWlzYyIsInJzVXBwZXIiLCJyc01pc2NMb3dlciIsInJzTWlzY1VwcGVyIiwicnNPcHRDb250ckxvd2VyIiwicnNPcHRDb250clVwcGVyIiwicnNPcmRMb3dlciIsInJzT3JkVXBwZXIiLCJyc0Vtb2ppIiwicmVBcG9zIiwicmVDb21ib01hcmsiLCJyZVVuaWNvZGVXb3JkIiwicmVIYXNVbmljb2RlV29yZCIsImNvbnRleHRQcm9wcyIsInRlbXBsYXRlQ291bnRlciIsImRlYnVycmVkTGV0dGVycyIsImh0bWxFc2NhcGVzIiwiaHRtbFVuZXNjYXBlcyIsInN0cmluZ0VzY2FwZXMiLCJmcmVlUGFyc2VGbG9hdCIsInBhcnNlRmxvYXQiLCJmcmVlUGFyc2VJbnQiLCJwYXJzZUludCIsIm5vZGVJc0FycmF5QnVmZmVyIiwiaXNBcnJheUJ1ZmZlciIsIm5vZGVJc0RhdGUiLCJpc0RhdGUiLCJub2RlSXNSZWdFeHAiLCJpc1JlZ0V4cCIsImFycmF5QWdncmVnYXRvciIsInNldHRlciIsImFycmF5RWFjaFJpZ2h0IiwiYXJyYXlFdmVyeSIsImFycmF5UmVkdWNlUmlnaHQiLCJhc2NpaVRvQXJyYXkiLCJhc2NpaVdvcmRzIiwiYmFzZUZpbmRLZXkiLCJiYXNlSW5kZXhPZldpdGgiLCJiYXNlTWVhbiIsImJhc2VTdW0iLCJiYXNlUHJvcGVydHlPZiIsImJhc2VTb3J0QnkiLCJjb21wYXJlciIsInNvcnQiLCJjdXJyZW50IiwiYmFzZVRvUGFpcnMiLCJjaGFyc1N0YXJ0SW5kZXgiLCJzdHJTeW1ib2xzIiwiY2hyU3ltYm9scyIsImNoYXJzRW5kSW5kZXgiLCJjb3VudEhvbGRlcnMiLCJwbGFjZWhvbGRlciIsImRlYnVyckxldHRlciIsImVzY2FwZUh0bWxDaGFyIiwiZXNjYXBlU3RyaW5nQ2hhciIsImNociIsImhhc1VuaWNvZGVXb3JkIiwiaXRlcmF0b3JUb0FycmF5IiwiaXRlcmF0b3IiLCJuZXh0IiwiZG9uZSIsInJlcGxhY2VIb2xkZXJzIiwic2V0VG9QYWlycyIsInN0cmljdExhc3RJbmRleE9mIiwic3RyaW5nVG9BcnJheSIsInVuaWNvZGVUb0FycmF5IiwidW5lc2NhcGVIdG1sQ2hhciIsInVuaWNvZGVXb3JkcyIsInJ1bkluQ29udGV4dCIsImNvbnRleHQiLCJkZWZhdWx0cyIsInBpY2siLCJpZENvdW50ZXIiLCJvYmplY3RDdG9yU3RyaW5nIiwib2xkRGFzaCIsInN5bUl0ZXJhdG9yIiwiY3R4Q2xlYXJUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiY3R4Tm93IiwiY3R4U2V0VGltZW91dCIsInNldFRpbWVvdXQiLCJuYXRpdmVDZWlsIiwiY2VpbCIsIm5hdGl2ZUZsb29yIiwiZmxvb3IiLCJuYXRpdmVJc0Zpbml0ZSIsImlzRmluaXRlIiwibmF0aXZlSm9pbiIsIm5hdGl2ZU1pbiIsIm5hdGl2ZVBhcnNlSW50IiwibmF0aXZlUmFuZG9tIiwicmFuZG9tIiwibmF0aXZlUmV2ZXJzZSIsIm1ldGFNYXAiLCJyZWFsTmFtZXMiLCJMYXp5V3JhcHBlciIsIkxvZGFzaFdyYXBwZXIiLCJ3cmFwcGVyQ2xvbmUiLCJiYXNlTG9kYXNoIiwiY2hhaW5BbGwiLCJfX3dyYXBwZWRfXyIsIl9fYWN0aW9uc19fIiwiX19jaGFpbl9fIiwiX19pbmRleF9fIiwiX192YWx1ZXNfXyIsInRlbXBsYXRlU2V0dGluZ3MiLCJfX2Rpcl9fIiwiX19maWx0ZXJlZF9fIiwiX19pdGVyYXRlZXNfXyIsIl9fdGFrZUNvdW50X18iLCJfX3ZpZXdzX18iLCJsYXp5Q2xvbmUiLCJsYXp5UmV2ZXJzZSIsImxhenlWYWx1ZSIsImRpciIsImlzUmlnaHQiLCJ2aWV3IiwiZ2V0VmlldyIsImVuZCIsIml0ZXJhdGVlcyIsIml0ZXJMZW5ndGgiLCJ0YWtlQ291bnQiLCJiYXNlV3JhcHBlclZhbHVlIiwiaXRlckluZGV4IiwiYXJyYXlTYW1wbGUiLCJiYXNlUmFuZG9tIiwiYXJyYXlTYW1wbGVTaXplIiwic2h1ZmZsZVNlbGYiLCJiYXNlQ2xhbXAiLCJhcnJheVNodWZmbGUiLCJhc3NpZ25NZXJnZVZhbHVlIiwiYmFzZUFnZ3JlZ2F0b3IiLCJiYXNlQXQiLCJwYXRocyIsInNraXAiLCJsb3dlciIsInVwcGVyIiwiYmFzZUNvbmZvcm1zIiwiYmFzZUNvbmZvcm1zVG8iLCJiYXNlRGVsYXkiLCJ3YWl0IiwiYmFzZURpZmZlcmVuY2UiLCJ2YWx1ZXNMZW5ndGgiLCJ2YWx1ZXNJbmRleCIsImJhc2VFYWNoUmlnaHQiLCJiYXNlRm9yT3duUmlnaHQiLCJiYXNlRXZlcnkiLCJiYXNlRXh0cmVtdW0iLCJiYXNlRmlsbCIsInRvSW50ZWdlciIsInRvTGVuZ3RoIiwiYmFzZUZvclJpZ2h0IiwiYmFzZUZ1bmN0aW9ucyIsImJhc2VHdCIsImJhc2VJblJhbmdlIiwiYmFzZUludGVyc2VjdGlvbiIsImFycmF5cyIsImNhY2hlcyIsIm1heExlbmd0aCIsIkluZmluaXR5IiwiYmFzZUludmVydGVyIiwiYmFzZUludm9rZSIsImxhc3QiLCJiYXNlSXNBcnJheUJ1ZmZlciIsImJhc2VJc0RhdGUiLCJiYXNlSXNSZWdFeHAiLCJiYXNlTHQiLCJiYXNlTWVyZ2UiLCJzcmNJbmRleCIsImJhc2VNZXJnZURlZXAiLCJzYWZlR2V0IiwibWVyZ2VGdW5jIiwiaXNUeXBlZCIsInRvUGxhaW5PYmplY3QiLCJiYXNlTnRoIiwiYmFzZU9yZGVyQnkiLCJvcmRlcnMiLCJnZXRJdGVyYXRlZSIsImNyaXRlcmlhIiwiY29tcGFyZU11bHRpcGxlIiwiYmFzZVBpY2siLCJiYXNlUGlja0J5IiwiYmFzZVNldCIsImJhc2VQdWxsQWxsIiwiYmFzZVB1bGxBdCIsImluZGV4ZXMiLCJwcmV2aW91cyIsImJhc2VVbnNldCIsImJhc2VSYW5nZSIsInN0ZXAiLCJiYXNlUmVwZWF0IiwiYmFzZVNhbXBsZSIsImJhc2VTYW1wbGVTaXplIiwibmVzdGVkIiwiYmFzZVNldERhdGEiLCJiYXNlU2h1ZmZsZSIsImJhc2VTbGljZSIsImJhc2VTb21lIiwiYmFzZVNvcnRlZEluZGV4IiwicmV0SGlnaGVzdCIsImxvdyIsImhpZ2giLCJtaWQiLCJiYXNlU29ydGVkSW5kZXhCeSIsInZhbElzTmFOIiwidmFsSXNOdWxsIiwidmFsSXNTeW1ib2wiLCJ2YWxJc1VuZGVmaW5lZCIsIm90aElzRGVmaW5lZCIsIm90aElzTnVsbCIsIm90aElzUmVmbGV4aXZlIiwib3RoSXNTeW1ib2wiLCJzZXRMb3ciLCJiYXNlU29ydGVkVW5pcSIsImJhc2VUb051bWJlciIsImJhc2VVcGRhdGUiLCJ1cGRhdGVyIiwiYmFzZVdoaWxlIiwiaXNEcm9wIiwiYWN0aW9ucyIsImFjdGlvbiIsImJhc2VYb3IiLCJiYXNlWmlwT2JqZWN0IiwiYXNzaWduRnVuYyIsInZhbHNMZW5ndGgiLCJjYXN0QXJyYXlMaWtlT2JqZWN0IiwiY2FzdFJlc3QiLCJjYXN0U2xpY2UiLCJpZCIsImNvbXBhcmVBc2NlbmRpbmciLCJ2YWxJc0RlZmluZWQiLCJ2YWxJc1JlZmxleGl2ZSIsIm9iakNyaXRlcmlhIiwib3RoQ3JpdGVyaWEiLCJvcmRlcnNMZW5ndGgiLCJjb21wb3NlQXJncyIsInBhcnRpYWxzIiwiaG9sZGVycyIsImlzQ3VycmllZCIsImFyZ3NJbmRleCIsImFyZ3NMZW5ndGgiLCJob2xkZXJzTGVuZ3RoIiwibGVmdEluZGV4IiwibGVmdExlbmd0aCIsInJhbmdlTGVuZ3RoIiwiaXNVbmN1cnJpZWQiLCJjb21wb3NlQXJnc1JpZ2h0IiwiaG9sZGVyc0luZGV4IiwicmlnaHRJbmRleCIsInJpZ2h0TGVuZ3RoIiwiY3JlYXRlQWdncmVnYXRvciIsImluaXRpYWxpemVyIiwiY3JlYXRlQXNzaWduZXIiLCJhc3NpZ25lciIsImd1YXJkIiwiaXNJdGVyYXRlZUNhbGwiLCJjcmVhdGVCaW5kIiwiaXNCaW5kIiwiY3JlYXRlQ3RvciIsIndyYXBwZXIiLCJjcmVhdGVDYXNlRmlyc3QiLCJtZXRob2ROYW1lIiwidHJhaWxpbmciLCJjcmVhdGVDb21wb3VuZGVyIiwid29yZHMiLCJkZWJ1cnIiLCJ0aGlzQmluZGluZyIsImNyZWF0ZUN1cnJ5IiwiYXJpdHkiLCJnZXRIb2xkZXIiLCJjcmVhdGVSZWN1cnJ5IiwiY3JlYXRlSHlicmlkIiwiY3JlYXRlRmluZCIsImZpbmRJbmRleEZ1bmMiLCJjcmVhdGVGbG93IiwiZmxhdFJlc3QiLCJmdW5jcyIsInByZXJlcSIsInRocnUiLCJnZXRGdW5jTmFtZSIsImZ1bmNOYW1lIiwiZ2V0RGF0YSIsImlzTGF6aWFibGUiLCJwbGFudCIsInBhcnRpYWxzUmlnaHQiLCJob2xkZXJzUmlnaHQiLCJhcmdQb3MiLCJhcnkiLCJpc0FyeSIsImlzQmluZEtleSIsImlzRmxpcCIsImhvbGRlcnNDb3VudCIsIm5ld0hvbGRlcnMiLCJyZW9yZGVyIiwiY3JlYXRlSW52ZXJ0ZXIiLCJ0b0l0ZXJhdGVlIiwiY3JlYXRlTWF0aE9wZXJhdGlvbiIsIm9wZXJhdG9yIiwiY3JlYXRlT3ZlciIsImFycmF5RnVuYyIsImNyZWF0ZVBhZGRpbmciLCJjaGFycyIsImNoYXJzTGVuZ3RoIiwiY3JlYXRlUGFydGlhbCIsImNyZWF0ZVJhbmdlIiwidG9GaW5pdGUiLCJjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uIiwidG9OdW1iZXIiLCJ3cmFwRnVuYyIsImlzQ3VycnkiLCJuZXdIb2xkZXJzUmlnaHQiLCJuZXdQYXJ0aWFscyIsIm5ld1BhcnRpYWxzUmlnaHQiLCJuZXdEYXRhIiwic2V0RGF0YSIsInNldFdyYXBUb1N0cmluZyIsImNyZWF0ZVJvdW5kIiwicHJlY2lzaW9uIiwicGFpciIsImNyZWF0ZVRvUGFpcnMiLCJjcmVhdGVXcmFwIiwibWVyZ2VEYXRhIiwiY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiIsImN1c3RvbURlZmF1bHRzTWVyZ2UiLCJjdXN0b21PbWl0Q2xvbmUiLCJmbGF0dGVuIiwib3RoZXJGdW5jIiwidHJhbnNmb3JtcyIsImdldFdyYXBEZXRhaWxzIiwiaW5zZXJ0V3JhcERldGFpbHMiLCJpc01hc2thYmxlIiwic3JjQml0bWFzayIsIm5ld0JpdG1hc2siLCJpc0NvbWJvIiwib2xkQXJyYXkiLCJ1cGRhdGVXcmFwRGV0YWlscyIsInJhbmQiLCJjaHVuayIsImNvbXBhY3QiLCJkaWZmZXJlbmNlIiwiZGlmZmVyZW5jZUJ5IiwiZGlmZmVyZW5jZVdpdGgiLCJkcm9wIiwiZHJvcFJpZ2h0IiwiZHJvcFJpZ2h0V2hpbGUiLCJkcm9wV2hpbGUiLCJmaWxsIiwiZmluZEluZGV4IiwiZmluZExhc3RJbmRleCIsImZsYXR0ZW5EZWVwIiwiZmxhdHRlbkRlcHRoIiwiZnJvbVBhaXJzIiwiaGVhZCIsImluaXRpYWwiLCJpbnRlcnNlY3Rpb24iLCJtYXBwZWQiLCJpbnRlcnNlY3Rpb25CeSIsImludGVyc2VjdGlvbldpdGgiLCJzZXBhcmF0b3IiLCJsYXN0SW5kZXhPZiIsIm50aCIsInB1bGwiLCJwdWxsQWxsIiwicHVsbEFsbEJ5IiwicHVsbEFsbFdpdGgiLCJwdWxsQXQiLCJyZW1vdmUiLCJzb3J0ZWRJbmRleCIsInNvcnRlZEluZGV4QnkiLCJzb3J0ZWRJbmRleE9mIiwic29ydGVkTGFzdEluZGV4Iiwic29ydGVkTGFzdEluZGV4QnkiLCJzb3J0ZWRMYXN0SW5kZXhPZiIsInNvcnRlZFVuaXEiLCJzb3J0ZWRVbmlxQnkiLCJ0YWlsIiwidGFrZSIsInRha2VSaWdodCIsInRha2VSaWdodFdoaWxlIiwidGFrZVdoaWxlIiwidW5pb25CeSIsInVuaW9uV2l0aCIsInVuaXEiLCJ1bmlxQnkiLCJ1bmlxV2l0aCIsInVuemlwIiwiZ3JvdXAiLCJ1bnppcFdpdGgiLCJ3aXRob3V0IiwieG9yIiwieG9yQnkiLCJ4b3JXaXRoIiwiemlwIiwiemlwT2JqZWN0IiwiemlwT2JqZWN0RGVlcCIsInppcFdpdGgiLCJjaGFpbiIsInRhcCIsImludGVyY2VwdG9yIiwid3JhcHBlckF0Iiwid3JhcHBlckNoYWluIiwid3JhcHBlckNvbW1pdCIsIndyYXBwZXJOZXh0IiwidG9BcnJheSIsIndyYXBwZXJUb0l0ZXJhdG9yIiwid3JhcHBlclBsYW50Iiwid3JhcHBlclJldmVyc2UiLCJ3cmFwcGVkIiwid3JhcHBlclZhbHVlIiwiY291bnRCeSIsImV2ZXJ5IiwiZmluZCIsImZpbmRMYXN0IiwiZmxhdE1hcCIsImZsYXRNYXBEZWVwIiwiZmxhdE1hcERlcHRoIiwiZm9yRWFjaFJpZ2h0IiwiZ3JvdXBCeSIsImludm9rZU1hcCIsImtleUJ5Iiwib3JkZXJCeSIsInBhcnRpdGlvbiIsInJlZHVjZVJpZ2h0IiwicmVqZWN0IiwibmVnYXRlIiwic2FtcGxlIiwic2FtcGxlU2l6ZSIsInNodWZmbGUiLCJzb21lIiwic29ydEJ5IiwiYWZ0ZXIiLCJiZWZvcmUiLCJiaW5kS2V5IiwiY3VycnkiLCJjdXJyeVJpZ2h0IiwiZGVib3VuY2UiLCJsYXN0QXJncyIsImxhc3RUaGlzIiwibWF4V2FpdCIsInRpbWVySWQiLCJsYXN0Q2FsbFRpbWUiLCJsYXN0SW52b2tlVGltZSIsImxlYWRpbmciLCJtYXhpbmciLCJpbnZva2VGdW5jIiwibGVhZGluZ0VkZ2UiLCJ0aW1lckV4cGlyZWQiLCJyZW1haW5pbmdXYWl0IiwidGltZVNpbmNlTGFzdENhbGwiLCJ0aW1lU2luY2VMYXN0SW52b2tlIiwidGltZVdhaXRpbmciLCJzaG91bGRJbnZva2UiLCJ0cmFpbGluZ0VkZ2UiLCJjYW5jZWwiLCJmbHVzaCIsImRlYm91bmNlZCIsImlzSW52b2tpbmciLCJkZWZlciIsImRlbGF5IiwiZmxpcCIsInJlc29sdmVyIiwibWVtb2l6ZWQiLCJDYWNoZSIsIm92ZXJBcmdzIiwiZnVuY3NMZW5ndGgiLCJwYXJ0aWFsIiwicGFydGlhbFJpZ2h0IiwicmVhcmciLCJyZXN0Iiwic3ByZWFkIiwidGhyb3R0bGUiLCJ1bmFyeSIsIndyYXAiLCJjYXN0QXJyYXkiLCJjbG9uZVdpdGgiLCJjbG9uZURlZXBXaXRoIiwiY29uZm9ybXNUbyIsImd0IiwiZ3RlIiwiaXNFbGVtZW50IiwiaXNFcXVhbCIsImlzRXF1YWxXaXRoIiwiaXNJbnRlZ2VyIiwiaXNNYXRjaCIsImlzTWF0Y2hXaXRoIiwiaXNOYU4iLCJpc051bWJlciIsImlzTmF0aXZlIiwiaXNOdWxsIiwiaXNOaWwiLCJpc1NhZmVJbnRlZ2VyIiwiaXNXZWFrTWFwIiwiaXNXZWFrU2V0IiwibHQiLCJsdGUiLCJzaWduIiwicmVtYWluZGVyIiwiaXNCaW5hcnkiLCJ0b1NhZmVJbnRlZ2VyIiwiYXNzaWduIiwiYXNzaWduSW4iLCJhc3NpZ25JbldpdGgiLCJhc3NpZ25XaXRoIiwiYXQiLCJwcm9wZXJ0aWVzIiwicHJvcHNJbmRleCIsInByb3BzTGVuZ3RoIiwiZGVmYXVsdHNEZWVwIiwibWVyZ2VXaXRoIiwiZmluZEtleSIsImZpbmRMYXN0S2V5IiwiZm9ySW4iLCJmb3JJblJpZ2h0IiwiZm9yT3duUmlnaHQiLCJmdW5jdGlvbnMiLCJmdW5jdGlvbnNJbiIsImludmVydCIsImludmVydEJ5IiwiaW52b2tlIiwibWFwS2V5cyIsIm1hcFZhbHVlcyIsIm1lcmdlIiwib21pdCIsIm9taXRCeSIsInBpY2tCeSIsInNldFdpdGgiLCJ0b1BhaXJzIiwidG9QYWlyc0luIiwiaXNBcnJMaWtlIiwidW5zZXQiLCJ1cGRhdGUiLCJ1cGRhdGVXaXRoIiwidmFsdWVzSW4iLCJjbGFtcCIsImluUmFuZ2UiLCJmbG9hdGluZyIsInRlbXAiLCJjYW1lbENhc2UiLCJ3b3JkIiwidG9Mb3dlckNhc2UiLCJjYXBpdGFsaXplIiwidXBwZXJGaXJzdCIsImVuZHNXaXRoIiwidGFyZ2V0IiwicG9zaXRpb24iLCJlc2NhcGUiLCJlc2NhcGVSZWdFeHAiLCJrZWJhYkNhc2UiLCJsb3dlckNhc2UiLCJsb3dlckZpcnN0IiwicGFkIiwic3RyTGVuZ3RoIiwicGFkRW5kIiwicGFkU3RhcnQiLCJyYWRpeCIsInJlcGVhdCIsInNuYWtlQ2FzZSIsImxpbWl0Iiwic3RhcnRDYXNlIiwic3RhcnRzV2l0aCIsInRlbXBsYXRlIiwic2V0dGluZ3MiLCJpbXBvcnRzIiwiaW1wb3J0c0tleXMiLCJpbXBvcnRzVmFsdWVzIiwiaXNFc2NhcGluZyIsImlzRXZhbHVhdGluZyIsImludGVycG9sYXRlIiwicmVEZWxpbWl0ZXJzIiwiZXZhbHVhdGUiLCJzb3VyY2VVUkwiLCJlc2NhcGVWYWx1ZSIsImludGVycG9sYXRlVmFsdWUiLCJlc1RlbXBsYXRlVmFsdWUiLCJldmFsdWF0ZVZhbHVlIiwidmFyaWFibGUiLCJhdHRlbXB0IiwidG9Mb3dlciIsInRvVXBwZXIiLCJ0b1VwcGVyQ2FzZSIsInRyaW0iLCJ0cmltRW5kIiwidHJpbVN0YXJ0IiwidHJ1bmNhdGUiLCJvbWlzc2lvbiIsInNlYXJjaCIsInN1YnN0cmluZyIsIm5ld0VuZCIsInVuZXNjYXBlIiwidXBwZXJDYXNlIiwiYmluZEFsbCIsIm1ldGhvZE5hbWVzIiwiY29uZCIsImNvbmZvcm1zIiwiZGVmYXVsdFRvIiwiZmxvdyIsImZsb3dSaWdodCIsIm1hdGNoZXMiLCJtYXRjaGVzUHJvcGVydHkiLCJtZXRob2QiLCJtZXRob2RPZiIsIm5vQ29uZmxpY3QiLCJudGhBcmciLCJvdmVyIiwib3ZlckV2ZXJ5Iiwib3ZlclNvbWUiLCJwcm9wZXJ0eU9mIiwicmFuZ2UiLCJyYW5nZVJpZ2h0Iiwic3R1Yk9iamVjdCIsInN0dWJTdHJpbmciLCJzdHViVHJ1ZSIsInRvUGF0aCIsInVuaXF1ZUlkIiwicHJlZml4IiwiYXVnZW5kIiwiYWRkZW5kIiwiZGl2aWRlIiwiZGl2aWRlbmQiLCJkaXZpc29yIiwibWF4QnkiLCJtZWFuIiwibWVhbkJ5IiwibWluQnkiLCJtdWx0aXBseSIsIm11bHRpcGxpZXIiLCJtdWx0aXBsaWNhbmQiLCJyb3VuZCIsInN1YnRyYWN0IiwibWludWVuZCIsInN1YnRyYWhlbmQiLCJzdW0iLCJzdW1CeSIsImVudHJpZXNJbiIsImV4dGVuZCIsImV4dGVuZFdpdGgiLCJlYWNoUmlnaHQiLCJmaXJzdCIsImlzRmlsdGVyIiwidGFrZU5hbWUiLCJkcm9wTmFtZSIsImNoZWNrSXRlcmF0ZWUiLCJpc1Rha2VyIiwibG9kYXNoRnVuYyIsInJldFVud3JhcHBlZCIsImlzTGF6eSIsInVzZUxhenkiLCJpc0h5YnJpZCIsImlzVW53cmFwcGVkIiwib25seUxhenkiLCJjaGFpbk5hbWUiLCJjb21taXQiLCJ0b0pTT04iLCJkZWZpbmUiLCJVTUQiLCJkZWZpbml0aW9uIiwiJEFNRCQiLCJERUYiLCJidWlsdEluUHJvcCIsImN5Y2xlIiwic2NoZWR1bGluZ19xdWV1ZSIsIlRvU3RyaW5nIiwidGltZXIiLCJzZXRJbW1lZGlhdGUiLCJjb25maWciLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsIlF1ZXVlIiwiSXRlbSIsImRyYWluIiwiZiIsInNjaGVkdWxlIiwiaXNUaGVuYWJsZSIsIm8iLCJfdGhlbiIsIm9fdHlwZSIsIm5vdGlmeSIsIm5vdGlmeUlzb2xhdGVkIiwic3RhdGUiLCJzdWNjZXNzIiwiZmFpbHVyZSIsInJldCIsIm1zZyIsInByb21pc2UiLCJ0cmlnZ2VyZWQiLCJkZWZfd3JhcHBlciIsIk1ha2VEZWZXcmFwcGVyIiwiJHJlc29sdmUkIiwiJHJlamVjdCQiLCJpdGVyYXRlUHJvbWlzZXMiLCJDb25zdHJ1Y3RvciIsInJlamVjdGVyIiwiaWR4IiwiSUlGRSIsIiRyZXNvbHZlciQiLCJNYWtlRGVmIiwiZXhlY3V0b3IiLCJfX05QT19fIiwiZXh0cmFjdENoYWluIiwiJGNhdGNoJCIsInB1YmxpY1Jlc29sdmUiLCJwdWJsaWNSZWplY3QiLCJQcm9taXNlUHJvdG90eXBlIiwiUHJvbWlzZSRyZXNvbHZlIiwiUHJvbWlzZSRyZWplY3QiLCJQcm9taXNlJGFsbCIsIm1zZ3MiLCJQcm9taXNlJHJhY2UiLCJzdXBwb3J0ZWRMb2FkZXJzIiwiZmlsZSIsImh0dHAiLCJodHRwcyIsImRlZmF1bHRMb2FkZXIiLCJpbXBvcnRTY3JpcHRzIiwiZ2V0U2NoZW1lIiwiZ2V0TG9hZGVyIiwic2NoZW1lIiwibG9hZGVyIiwicHJvY2Vzc2VkIiwidW5zdXBwb3J0ZWRFcnJvciIsImdldEJhc2UiLCJyZXF1ZXN0Iiwic3VwcG9ydGVkSHR0cE1ldGhvZHMiLCJyZWFsTWV0aG9kIiwicmVhbFJlcXVlc3QiLCJtYWtlUmVxdWVzdCIsInJlcSIsImVycjIiLCJwcmVwYXJlUmVxdWVzdCIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiZGVmYXVsdENsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwicnVuIiwibmV4dFRpY2siLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbnMiLCJhZGRMaXN0ZW5lciIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJjaGRpciIsInVtYXNrIiwic2VwIiwibWF4S2V5cyIsImtzdHIiLCJ2c3RyIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwieHMiLCJzdHJpbmdpZnlQcmltaXRpdmUiLCJvYmplY3RLZXlzIiwia3MiLCJlbmNvZGVVUklDb21wb25lbnQiLCJkZWNvZGUiLCJlbmNvZGUiLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsInJlZ2lzdGVySW1tZWRpYXRlIiwidGFzayIsImNsZWFySW1tZWRpYXRlIiwiaGFuZGxlIiwicnVuSWZQcmVzZW50IiwiaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24iLCJjYW5Vc2VQb3N0TWVzc2FnZSIsInBvc3RNZXNzYWdlIiwicG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyIsIm9sZE9uTWVzc2FnZSIsIm9ubWVzc2FnZSIsImluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uIiwibWVzc2FnZVByZWZpeCIsIm9uR2xvYmFsTWVzc2FnZSIsImF0dGFjaEV2ZW50IiwiaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjaGFubmVsIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInBvcnQyIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsImh0bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JpcHQiLCJjcmVhdGVFbGVtZW50Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsImlzRXh0ZW5kZWRMZW5ndGhQYXRoIiwiaGFzTm9uQXNjaWkiLCJBZ2VudCIsIl9kZWZhdWx0cyIsIl9zZXREZWZhdWx0cyIsImNvbnNvbGUiLCJ3YXJuIiwiUmVxdWVzdEJhc2UiLCJSZXNwb25zZUJhc2UiLCJSZXF1ZXN0IiwiZ2V0WEhSIiwiWE1MSHR0cFJlcXVlc3QiLCJwcm90b2NvbCIsIkFjdGl2ZVhPYmplY3QiLCJzIiwicHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIiLCJzdWJrZXkiLCJzZXJpYWxpemVPYmplY3QiLCJwYXJzZVN0cmluZyIsInN0ciIsInBvcyIsInhtbCIsInVybGVuY29kZWQiLCJwYXJzZUhlYWRlciIsImxpbmVzIiwiZmllbGRzIiwibGluZSIsImZpZWxkIiwiaXNKU09OIiwibWltZSIsIlJlc3BvbnNlIiwieGhyIiwicmVzcG9uc2VUeXBlIiwicmVzcG9uc2VUZXh0Iiwic3RhdHVzVGV4dCIsInN0YXR1cyIsIl9zZXRTdGF0dXNQcm9wZXJ0aWVzIiwiaGVhZGVyIiwiaGVhZGVycyIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsImdldFJlc3BvbnNlSGVhZGVyIiwiX3NldEhlYWRlclByb3BlcnRpZXMiLCJfcmVzcG9uc2VUeXBlIiwiYm9keSIsInJlc3BvbnNlIiwiX3BhcnNlQm9keSIsIl9wYXJzZXIiLCJ0b0Vycm9yIiwiX3F1ZXJ5IiwiX2hlYWRlciIsIm9yaWdpbmFsIiwicmF3UmVzcG9uc2UiLCJzdGF0dXNDb2RlIiwibmV3X2VyciIsIl9pc1Jlc3BvbnNlT0siLCJjdXN0b21fZXJyIiwiYWNjZXB0IiwiYXV0aCIsInVzZXIiLCJwYXNzIiwiYnRvYSIsImVuY29kZXIiLCJfYXV0aCIsImF0dGFjaCIsIl9kYXRhIiwiX2dldEZvcm1EYXRhIiwiYXBwZW5kIiwiX2Zvcm1EYXRhIiwiRm9ybURhdGEiLCJfc2hvdWxkUmV0cnkiLCJfcmV0cnkiLCJfY2FsbGJhY2siLCJfbWF4UmV0cmllcyIsInJldHJpZXMiLCJfcmV0cmllcyIsImNyb3NzRG9tYWluRXJyb3IiLCJjcm9zc0RvbWFpbiIsImNhIiwiYWdlbnQiLCJwaXBlIiwiX2lzSG9zdCIsIl9lbmRDYWxsZWQiLCJfZmluYWxpemVRdWVyeVN0cmluZyIsIl9lbmQiLCJfc2V0VGltZW91dHMiLCJyZWFkeVN0YXRlIiwiX3Jlc3BvbnNlVGltZW91dFRpbWVyIiwidGltZWRvdXQiLCJfYWJvcnRlZCIsImhhbmRsZVByb2dyZXNzIiwiZGlyZWN0aW9uIiwidG90YWwiLCJwZXJjZW50IiwibG9hZGVkIiwib25wcm9ncmVzcyIsInVwbG9hZCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJvcGVuIiwiX3dpdGhDcmVkZW50aWFscyIsIndpdGhDcmVkZW50aWFscyIsImNvbnRlbnRUeXBlIiwiX3NlcmlhbGl6ZXIiLCJzZXRSZXF1ZXN0SGVhZGVyIiwic2VuZCIsImRlbCIsInBhdGNoIiwicG9zdCIsInB1dCIsIl9jbGVhclRpbWVvdXQiLCJfdGltZXIiLCJfdGltZW91dCIsIl9yZXNwb25zZVRpbWVvdXQiLCJvcHRpb24iLCJkZWFkbGluZSIsInJldHJ5IiwiX3JldHJ5Q2FsbGJhY2siLCJFUlJPUl9DT0RFUyIsIm92ZXJyaWRlIiwiY29kZSIsIl9mdWxsZmlsbGVkUHJvbWlzZSIsImlubmVyUmVzb2x2ZSIsImlubmVyUmVqZWN0IiwidXNlIiwib2siLCJfb2tDYWxsYmFjayIsImdldEhlYWRlciIsImFib3J0IiwiYmFzZTY0RW5jb2RlciIsInJlZGlyZWN0cyIsIl9tYXhSZWRpcmVjdHMiLCJtYXhSZXNwb25zZVNpemUiLCJfbWF4UmVzcG9uc2VTaXplIiwiaXNPYmoiLCJzb3J0UXVlcnkiLCJfc29ydCIsInF1ZXJ5QXJyIiwiX2FwcGVuZFF1ZXJ5U3RyaW5nIiwidHJhY2UiLCJfdGltZW91dEVycm9yIiwicmVhc29uIiwiZXJybm8iLCJ1dGlscyIsImN0IiwicGFyYW1zIiwibGlua3MiLCJsaW5rIiwicGFyc2VMaW5rcyIsInN0YXR1c1R5cGUiLCJpbmZvIiwicmVkaXJlY3QiLCJjbGllbnRFcnJvciIsInNlcnZlckVycm9yIiwiY3JlYXRlZCIsImFjY2VwdGVkIiwibm9Db250ZW50IiwiYmFkUmVxdWVzdCIsInVuYXV0aG9yaXplZCIsIm5vdEFjY2VwdGFibGUiLCJmb3JiaWRkZW4iLCJub3RGb3VuZCIsInVucHJvY2Vzc2FibGVFbnRpdHkiLCJwYXJ0cyIsInJlbCIsImNsZWFuSGVhZGVyIiwiY2hhbmdlc09yaWdpbiIsInNjb3BlIiwiVGltZW91dCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImNsb3NlIiwiY2xlYXJGbiIsIl9pZCIsIl9jbGVhckZuIiwidW5yZWYiLCJlbnJvbGwiLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJhY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0Iiwic2V0cyIsInhsIiwiQUxQSEEkJCIsIkNSJCIsIkRJR0lUJCQiLCJEUVVPVEUkJCIsIkhFWERJRyQkIiwiU1AkJCIsIlBDVF9FTkNPREVEJCIsInN1YmV4cCIsIlNVQl9ERUxJTVMkJCIsIlJFU0VSVkVEJCQiLCJVQ1NDSEFSJCQiLCJpc0lSSSIsIlNDSEVNRSQiLCJVU0VSSU5GTyQiLCJERUNfT0NURVQkIiwiREVDX09DVEVUX1JFTEFYRUQkIiwiSDE2JCIsIkxTMzIkIiwiSVBWNkFERFJFU1MxJCIsIlpPTkVJRCQiLCJVTlJFU0VSVkVEJCQiLCJJUFY2QUREUkVTUyQiLCJJUF9MSVRFUkFMJCIsIklQVjZBRERSWl9SRUxBWEVEJCIsIkhPU1QkIiwiUE9SVCQiLCJBVVRIT1JJVFkkIiwiUENIQVIkIiwiU0VHTUVOVCQiLCJTRUdNRU5UX05aJCIsIlNFR01FTlRfTlpfTkMkIiwiUEFUSF9BQkVNUFRZJCIsIlBBVEhfQUJTT0xVVEUkIiwiUEFUSCQiLCJRVUVSWSQiLCJGUkFHTUVOVCQiLCJISUVSX1BBUlQkIiwiVVJJJCIsIlJFTEFUSVZFX1BBUlQkIiwiUkVMQVRJVkUkIiwiVVJJX1JFRkVSRU5DRSQiLCJBQlNPTFVURV9VUkkkIiwiR0VORVJJQ19SRUYkIiwiUkVMQVRJVkVfUkVGJCIsIkFCU09MVVRFX1JFRiQiLCJTQU1FRE9DX1JFRiQiLCJBVVRIT1JJVFlfUkVGJCIsImJ1aWxkRXhwcyIsIm1heEludCIsImJhc2UiLCJ0TWluIiwidE1heCIsInNrZXciLCJkYW1wIiwiaW5pdGlhbEJpYXMiLCJpbml0aWFsTiIsImRlbGltaXRlciIsInJlZ2V4UHVueWNvZGUiLCJyZWdleE5vbkFTQ0lJIiwicmVnZXhTZXBhcmF0b3JzIiwiZXJyb3JzIiwiYmFzZU1pbnVzVE1pbiIsInN0cmluZ0Zyb21DaGFyQ29kZSIsImxhYmVscyIsImVuY29kZWQiLCJvdXRwdXQiLCJjb3VudGVyIiwiZXh0cmEiLCJ1Y3MyZW5jb2RlIiwiYmFzaWNUb0RpZ2l0IiwiY29kZVBvaW50IiwiZGlnaXRUb0Jhc2ljIiwiZGlnaXQiLCJmbGFnIiwiYWRhcHQiLCJmaXJzdFRpbWUiLCJkZWx0YSIsImlucHV0TGVuZ3RoIiwiYmlhcyIsImJhc2ljIiwib2xkaSIsInQiLCJiYXNlTWludXNUIiwib3V0IiwidWNzMmRlY29kZSIsImN1cnJlbnRWYWx1ZSIsImJhc2ljTGVuZ3RoIiwiaGFuZGxlZENQQ291bnQiLCJtIiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwicSIsInFNaW51c1QiLCJ0b1VuaWNvZGUiLCJ0b0FTQ0lJIiwicHVueWNvZGUiLCJTQ0hFTUVTIiwiYyIsIm5ld1N0ciIsImlsIiwiYzIiLCJjMyIsImRlY29kZVVucmVzZXJ2ZWQiLCJkZWNTdHIiLCJwY3REZWNDaGFycyIsImhvc3QiLCJhZGRyZXNzIiwiem9uZSIsImZpcnN0RmllbGRzIiwibGFzdEZpZWxkcyIsImlzTGFzdEZpZWxkSVB2NEFkZHJlc3MiLCJmaWVsZENvdW50IiwibGFzdEZpZWxkc1N0YXJ0IiwiX25vcm1hbGl6ZUlQdjQiLCJhbGxaZXJvRmllbGRzIiwibGFzdExvbmdlc3QiLCJsb25nZXN0WmVyb0ZpZWxkcyIsImIiLCJhIiwibmV3SG9zdCIsIm5ld0ZpcnN0IiwibmV3TGFzdCIsIlVSSV9QQVJTRSIsIk5PX01BVENIX0lTX1VOREVGSU5FRCIsInVyaVN0cmluZyIsIl9ub3JtYWxpemVJUHY2Iiwic2NoZW1lSGFuZGxlciIsInVyaVRva2VucyIsIiQyIiwiUkRTMSIsIlJEUzIiLCJSRFMzIiwiUkRTNSIsImltIiwiYXV0aG9yaXR5IiwiX3JlY29tcG9zZUF1dGhvcml0eSIsInJlbW92ZURvdFNlZ21lbnRzIiwic2tpcE5vcm1hbGl6YXRpb24iLCJyZWxhdGl2ZSIsInNjaGVtZWxlc3NPcHRpb25zIiwicmVzb2x2ZUNvbXBvbmVudHMiLCJ0eXBlT2YiLCJ1cmlBIiwiVVJJX1BST1RPQ09MIiwiSVJJX1BST1RPQ09MIiwiaGFuZGxlciIsIk8iLCJBVEVYVCQkIiwiUVRFWFQkJCIsIlZDSEFSJCQiLCJTT01FX0RFTElNUyQkIiwiVU5SRVNFUlZFRCIsIlBDVF9FTkNPREVEIiwiTk9UX0xPQ0FMX1BBUlQiLCJOT1RfSEZOQU1FIiwiTk9UX0hGVkFMVUUiLCJtYWlsdG9Db21wb25lbnRzIiwidG8iLCJ1bmtub3duSGVhZGVycyIsImhmaWVsZHMiLCJoZmllbGQiLCJ0b0FkZHJzIiwidW5lc2NhcGVDb21wb25lbnQiLCJhZGRyIiwidG9BZGRyIiwiYXRJZHgiLCJsb2NhbFBhcnQiLCJkb21haW4iLCJVUk5fUEFSU0UiLCJ1cm5Db21wb25lbnRzIiwibmlkIiwibnNzIiwidXJuU2NoZW1lIiwidXJpQ29tcG9uZW50cyIsIlVVSUQiLCJ1dWlkQ29tcG9uZW50cyIsIm1haWx0byIsInVybiIsInV1aWQiLCJ3ZWJwYWNrUG9seWZpbGwiLCJkZXByZWNhdGUiLCJlbnVtZXJhYmxlIiwibm9ybWFsaXplQXJyYXkiLCJhbGxvd0Fib3ZlUm9vdCIsInVwIiwidW5zaGlmdCIsInJlc29sdmVkUGF0aCIsInJlc29sdmVkQWJzb2x1dGUiLCJwIiwibm9ybWFsaXplIiwidHJhaWxpbmdTbGFzaCIsImZyb20iLCJmcm9tUGFydHMiLCJ0b1BhcnRzIiwic2FtZVBhcnRzTGVuZ3RoIiwib3V0cHV0UGFydHMiLCJoYXNSb290IiwibWF0Y2hlZFNsYXNoIiwiYmFzZW5hbWUiLCJleHQiLCJleHRuYW1lIiwic3RhcnREb3QiLCJzdGFydFBhcnQiLCJwcmVEb3RTdGF0ZSJdLCJtYXBwaW5ncyI6Ijs7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JhOztBQUViLElBQUlBLENBQUMsR0FBR0MsbUJBQU8sQ0FBQywrQ0FBRCxDQUFmOztBQUNBLElBQUlDLEVBQUUsR0FBR0QsbUJBQU8sQ0FBQyxrREFBRCxDQUFoQjs7QUFDQSxJQUFJRSxJQUFJLEdBQUdGLG1CQUFPLENBQUMs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QyxFQUFvQztBQUNoQyxRQUFJOHpDLENBQUMsQ0FBQzJGLEVBQUUsQ0FBQ3o1QyxDQUFELENBQUgsRUFBUUEsQ0FBUixFQUFXeTVDLEVBQVgsQ0FBTCxFQUFxQjdqRCxHQUFHLENBQUN4QixJQUFKLENBQVNxbEQsRUFBRSxDQUFDejVDLENBQUQsQ0FBWDtBQUN4Qjs7QUFDRCxTQUFPcEssR0FBUDtBQUNILEMsQ0FFRDs7O0FBQ0EsSUFBSXNJLE1BQU0sR0FBRyxLQUFLQSxNQUFMLENBQVksQ0FBQyxDQUFiLE1BQW9CLEdBQXBCLEdBQ1AsVUFBVWsvQyxHQUFWLEVBQWVqaUMsS0FBZixFQUFzQjlhLEdBQXRCLEVBQTJCO0FBQUUsU0FBTys4QyxHQUFHLENBQUNsL0MsTUFBSixDQUFXaWQsS0FBWCxFQUFrQjlhLEdBQWxCLENBQVA7QUFBK0IsQ0FEckQsR0FFUCxVQUFVKzhDLEdBQVYsRUFBZWppQyxLQUFmLEVBQXNCOWEsR0FBdEIsRUFBMkI7QUFDekIsTUFBSThhLEtBQUssR0FBRyxDQUFaLEVBQWVBLEtBQUssR0FBR2lpQyxHQUFHLENBQUN4cUQsTUFBSixHQUFhdW9CLEtBQXJCO0FBQ2YsU0FBT2lpQyxHQUFHLENBQUNsL0MsTUFBSixDQUFXaWQsS0FBWCxFQUFrQjlhLEdBQWxCLENBQVA7QUFDSCxDQUxMLEMiLCJmaWxlIjoianNvbi1yZWZzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9pbmRleC5qc1wiKTtcbiIsIi8qXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgSmVyZW15IFdoaXRsb2NrXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgZ2wgPSByZXF1aXJlKCdncmFwaGxpYicpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgUGF0aExvYWRlciA9IHJlcXVpcmUoJ3BhdGgtbG9hZGVyJyk7XG52YXIgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xudmFyIHNsYXNoID0gcmVxdWlyZSgnc2xhc2gnKTtcbnZhciBVUkkgPSByZXF1aXJlKCd1cmktanMnKTtcblxudmFyIGJhZFB0clRva2VuUmVnZXggPSAvfig/OlteMDFdfCQpL2c7XG52YXIgcmVtb3RlQ2FjaGUgPSB7fTtcbnZhciByZW1vdGVUeXBlcyA9IFsncmVsYXRpdmUnLCAncmVtb3RlJ107XG52YXIgcmVtb3RlVXJpVHlwZXMgPSBbJ2Fic29sdXRlJywgJ3VyaSddO1xudmFyIHVyaURldGFpbHNDYWNoZSA9IHt9O1xuXG4vLyBMb2FkIHByb21pc2VzIHBvbHlmaWxsIGlmIG5lY2Vzc2FyeVxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnKSB7XG4gIHJlcXVpcmUoJ25hdGl2ZS1wcm9taXNlLW9ubHknKTtcbn1cblxuLyogSW50ZXJuYWwgRnVuY3Rpb25zICovXG5cbmZ1bmN0aW9uIGNvbWJpbmVRdWVyeVBhcmFtcyAocXMxLCBxczIpIHtcbiAgdmFyIGNvbWJpbmVkID0ge307XG5cbiAgZnVuY3Rpb24gbWVyZ2VRdWVyeVBhcmFtcyAob2JqKSB7XG4gICAgXy5mb3JPd24ob2JqLCBmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICAgIGNvbWJpbmVkW2tleV0gPSB2YWw7XG4gICAgfSk7XG4gIH1cblxuICBtZXJnZVF1ZXJ5UGFyYW1zKHFzLnBhcnNlKHFzMSB8fCAnJykpO1xuICBtZXJnZVF1ZXJ5UGFyYW1zKHFzLnBhcnNlKHFzMiB8fCAnJykpO1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhjb21iaW5lZCkubGVuZ3RoID09PSAwID8gdW5kZWZpbmVkIDogcXMuc3RyaW5naWZ5KGNvbWJpbmVkKTtcbn1cblxuZnVuY3Rpb24gY29tYmluZVVSSXMgKHUxLCB1Mikge1xuICAvLyBDb252ZXJ0IFdpbmRvd3MgcGF0aHNcbiAgaWYgKF8uaXNTdHJpbmcodTEpKSB7XG4gICAgdTEgPSBzbGFzaCh1MSk7XG4gIH1cblxuICBpZiAoXy5pc1N0cmluZyh1MikpIHtcbiAgICB1MiA9IHNsYXNoKHUyKTtcbiAgfVxuXG4gIHZhciB1MkRldGFpbHMgPSBwYXJzZVVSSShfLmlzVW5kZWZpbmVkKHUyKSA/ICcnIDogdTIpO1xuICB2YXIgdTFEZXRhaWxzO1xuICB2YXIgY29tYmluZWREZXRhaWxzO1xuXG4gIGlmIChyZW1vdGVVcmlUeXBlcy5pbmRleE9mKHUyRGV0YWlscy5yZWZlcmVuY2UpID4gLTEpIHtcbiAgICBjb21iaW5lZERldGFpbHMgPSB1MkRldGFpbHM7XG4gIH0gZWxzZSB7XG4gICAgdTFEZXRhaWxzID0gXy5pc1VuZGVmaW5lZCh1MSkgPyB1bmRlZmluZWQgOiBwYXJzZVVSSSh1MSk7XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQodTFEZXRhaWxzKSkge1xuICAgICAgY29tYmluZWREZXRhaWxzID0gdTFEZXRhaWxzO1xuXG4gICAgICAvLyBKb2luIHRoZSBwYXRoc1xuICAgICAgY29tYmluZWREZXRhaWxzLnBhdGggPSBzbGFzaChwYXRoLmpvaW4odTFEZXRhaWxzLnBhdGgsIHUyRGV0YWlscy5wYXRoKSk7XG5cbiAgICAgIC8vIEpvaW4gcXVlcnkgcGFyYW1ldGVyc1xuICAgICAgY29tYmluZWREZXRhaWxzLnF1ZXJ5ID0gY29tYmluZVF1ZXJ5UGFyYW1zKHUxRGV0YWlscy5xdWVyeSwgdTJEZXRhaWxzLnF1ZXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tYmluZWREZXRhaWxzID0gdTJEZXRhaWxzO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSB0aGUgZnJhZ21lbnRcbiAgY29tYmluZWREZXRhaWxzLmZyYWdtZW50ID0gdW5kZWZpbmVkO1xuXG4gIC8vIEZvciByZWxhdGl2ZSBVUklzLCBhZGQgYmFjayB0aGUgJy4uJyBzaW5jZSBpdCB3YXMgcmVtb3ZlZCBhYm92ZVxuICByZXR1cm4gKHJlbW90ZVVyaVR5cGVzLmluZGV4T2YoY29tYmluZWREZXRhaWxzLnJlZmVyZW5jZSkgPT09IC0xICYmXG4gICAgICAgICAgY29tYmluZWREZXRhaWxzLnBhdGguaW5kZXhPZignLi4vJykgPT09IDAgPyAnLi4vJyA6ICcnKSArIFVSSS5zZXJpYWxpemUoY29tYmluZWREZXRhaWxzKTtcbn1cblxuZnVuY3Rpb24gZmluZEFuY2VzdG9ycyAob2JqLCBwYXRoKSB7XG4gIHZhciBhbmNlc3RvcnMgPSBbXTtcbiAgdmFyIG5vZGU7XG5cbiAgaWYgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgIG5vZGUgPSBvYmo7XG5cbiAgICBwYXRoLnNsaWNlKDAsIHBhdGgubGVuZ3RoIC0gMSkuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XG4gICAgICBpZiAoc2VnIGluIG5vZGUpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVbc2VnXTtcblxuICAgICAgICBhbmNlc3RvcnMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBhbmNlc3RvcnM7XG59XG5cbmZ1bmN0aW9uIGlzUmVtb3RlIChyZWZEZXRhaWxzKSB7XG4gIHJldHVybiByZW1vdGVUeXBlcy5pbmRleE9mKGdldFJlZlR5cGUocmVmRGV0YWlscykpID4gLTE7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWQgKHJlZkRldGFpbHMpIHtcbiAgcmV0dXJuIF8uaXNVbmRlZmluZWQocmVmRGV0YWlscy5lcnJvcikgJiYgcmVmRGV0YWlscy50eXBlICE9PSAnaW52YWxpZCc7XG59XG5cbmZ1bmN0aW9uIGZpbmRWYWx1ZSAob2JqLCBwYXRoKSB7XG4gIHZhciB2YWx1ZSA9IG9iajtcblxuICAvLyBVc2luZyB0aGlzIG1hbnVhbCBhcHByb2FjaCBpbnN0ZWFkIG9mIF8uZ2V0IHNpbmNlIHdlIGhhdmUgdG8gZGVjb2RlVVJJIHRoZSBzZWdtZW50c1xuICBwYXRoLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xuICAgIGlmIChzZWcgaW4gdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVbc2VnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ0pTT04gUG9pbnRlciBwb2ludHMgdG8gbWlzc2luZyBsb2NhdGlvbjogJyArIHBhdGhUb1B0cihwYXRoKSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldEV4dHJhUmVmS2V5cyAocmVmKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhyZWYpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleSAhPT0gJyRyZWYnO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVmVHlwZSAocmVmRGV0YWlscykge1xuICB2YXIgdHlwZTtcblxuICAvLyBDb252ZXJ0IHRoZSBVUkkgcmVmZXJlbmNlIHRvIG9uZSBvZiBvdXIgdHlwZXNcbiAgc3dpdGNoIChyZWZEZXRhaWxzLnVyaURldGFpbHMucmVmZXJlbmNlKSB7XG4gIGNhc2UgJ2Fic29sdXRlJzpcbiAgY2FzZSAndXJpJzpcbiAgICB0eXBlID0gJ3JlbW90ZSc7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3NhbWUtZG9jdW1lbnQnOlxuICAgIHR5cGUgPSAnbG9jYWwnO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHR5cGUgPSByZWZEZXRhaWxzLnVyaURldGFpbHMucmVmZXJlbmNlO1xuICB9XG5cbiAgcmV0dXJuIHR5cGU7XG59XG5cbmZ1bmN0aW9uIGdldFJlbW90ZURvY3VtZW50ICh1cmwsIG9wdGlvbnMpIHtcbiAgdmFyIGNhY2hlRW50cnkgPSByZW1vdGVDYWNoZVt1cmxdO1xuICB2YXIgYWxsVGFza3MgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgdmFyIGxvYWRlck9wdGlvbnMgPSBfLmNsb25lRGVlcChvcHRpb25zLmxvYWRlck9wdGlvbnMgfHwge30pO1xuXG4gIGlmIChfLmlzVW5kZWZpbmVkKGNhY2hlRW50cnkpKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gY29udGVudCBwcm9jZXNzb3IsIGRlZmF1bHQgdG8gcHJvY2Vzc2luZyB0aGUgcmF3IHJlc3BvbnNlIGFzIEpTT05cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChsb2FkZXJPcHRpb25zLnByb2Nlc3NDb250ZW50KSkge1xuICAgICAgbG9hZGVyT3B0aW9ucy5wcm9jZXNzQ29udGVudCA9IGZ1bmN0aW9uIChyZXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgSlNPTi5wYXJzZShyZXMudGV4dCkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBBdHRlbXB0IHRvIGxvYWQgdGhlIHJlc291cmNlIHVzaW5nIHBhdGgtbG9hZGVyXG4gICAgYWxsVGFza3MgPSBQYXRoTG9hZGVyLmxvYWQoZGVjb2RlVVJJKHVybCksIGxvYWRlck9wdGlvbnMpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBjYWNoZVxuICAgIGFsbFRhc2tzID0gYWxsVGFza3NcbiAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgcmVtb3RlQ2FjaGVbdXJsXSA9IHtcbiAgICAgICAgICB2YWx1ZTogcmVzXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZW1vdGVDYWNoZVt1cmxdID0ge1xuICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgfTtcblxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZXR1cm4gdGhlIGNhY2hlZCB2ZXJzaW9uXG4gICAgYWxsVGFza3MgPSBhbGxUYXNrcy50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfLmlzRXJyb3IoY2FjaGVFbnRyeS5lcnJvcikpIHtcbiAgICAgICAgdGhyb3cgY2FjaGVFbnRyeS5lcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjYWNoZUVudHJ5LnZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gUmV0dXJuIGEgY2xvbmVkIHZlcnNpb24gdG8gYXZvaWQgdXBkYXRpbmcgdGhlIGNhY2hlXG4gIGFsbFRhc2tzID0gYWxsVGFza3MudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgcmV0dXJuIF8uY2xvbmVEZWVwKHJlcyk7XG4gIH0pO1xuXG4gIHJldHVybiBhbGxUYXNrcztcbn1cblxuZnVuY3Rpb24gaXNSZWZMaWtlIChvYmosIHRocm93V2l0aERldGFpbHMpIHtcbiAgdmFyIHJlZkxpa2UgPSB0cnVlO1xuXG4gIHRyeSB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3Qob2JqKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvYmogaXMgbm90IGFuIE9iamVjdCcpO1xuICAgIH0gZWxzZSBpZiAoIV8uaXNTdHJpbmcob2JqLiRyZWYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29iai4kcmVmIGlzIG5vdCBhIFN0cmluZycpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHRocm93V2l0aERldGFpbHMpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICByZWZMaWtlID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcmVmTGlrZTtcbn1cblxuZnVuY3Rpb24gbWFrZUFic29sdXRlIChsb2NhdGlvbikge1xuICBpZiAobG9jYXRpb24uaW5kZXhPZignOi8vJykgPT09IC0xICYmICFwYXRoLmlzQWJzb2x1dGUobG9jYXRpb24pKSB7XG4gICAgcmV0dXJuIHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCBsb2NhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxvY2F0aW9uO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VSZWZGaWx0ZXIgKG9wdGlvbnMpIHtcbiAgdmFyIHJlZkZpbHRlcjtcbiAgdmFyIHZhbGlkVHlwZXM7XG5cbiAgaWYgKF8uaXNBcnJheShvcHRpb25zLmZpbHRlcikgfHwgXy5pc1N0cmluZyhvcHRpb25zLmZpbHRlcikpIHtcbiAgICB2YWxpZFR5cGVzID0gXy5pc1N0cmluZyhvcHRpb25zLmZpbHRlcikgPyBbb3B0aW9ucy5maWx0ZXJdIDogb3B0aW9ucy5maWx0ZXI7XG4gICAgcmVmRmlsdGVyID0gZnVuY3Rpb24gKHJlZkRldGFpbHMpIHtcbiAgICAgIC8vIENoZWNrIHRoZSBleGFjdCB0eXBlIG9yIGZvciBpbnZhbGlkIFVSSXMsIGNoZWNrIGl0cyBvcmlnaW5hbCB0eXBlXG4gICAgICByZXR1cm4gdmFsaWRUeXBlcy5pbmRleE9mKHJlZkRldGFpbHMudHlwZSkgPiAtMSB8fCB2YWxpZFR5cGVzLmluZGV4T2YoZ2V0UmVmVHlwZShyZWZEZXRhaWxzKSkgPiAtMTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKF8uaXNGdW5jdGlvbihvcHRpb25zLmZpbHRlcikpIHtcbiAgICByZWZGaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgfSBlbHNlIGlmIChfLmlzVW5kZWZpbmVkKG9wdGlvbnMuZmlsdGVyKSkge1xuICAgIHJlZkZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHJlZkRldGFpbHMsIHBhdGgpIHtcbiAgICByZXR1cm4gKHJlZkRldGFpbHMudHlwZSAhPT0gJ2ludmFsaWQnIHx8IG9wdGlvbnMuaW5jbHVkZUludmFsaWQgPT09IHRydWUpICYmIHJlZkZpbHRlcihyZWZEZXRhaWxzLCBwYXRoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZVN1YkRvY1BhdGggKG9wdGlvbnMpIHtcbiAgdmFyIHN1YkRvY1BhdGg7XG5cbiAgaWYgKF8uaXNBcnJheShvcHRpb25zLnN1YkRvY1BhdGgpKSB7XG4gICAgc3ViRG9jUGF0aCA9IG9wdGlvbnMuc3ViRG9jUGF0aDtcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKG9wdGlvbnMuc3ViRG9jUGF0aCkpIHtcbiAgICBzdWJEb2NQYXRoID0gcGF0aEZyb21QdHIob3B0aW9ucy5zdWJEb2NQYXRoKTtcbiAgfSBlbHNlIGlmIChfLmlzVW5kZWZpbmVkKG9wdGlvbnMuc3ViRG9jUGF0aCkpIHtcbiAgICBzdWJEb2NQYXRoID0gW107XG4gIH1cblxuICByZXR1cm4gc3ViRG9jUGF0aDtcbn1cblxuZnVuY3Rpb24gbWFya01pc3NpbmcgKHJlZkRldGFpbHMsIGVycikge1xuICByZWZEZXRhaWxzLmVycm9yID0gZXJyLm1lc3NhZ2U7XG4gIHJlZkRldGFpbHMubWlzc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVVJJICh1cmkpIHtcbiAgLy8gV2UgZGVjb2RlIGZpcnN0IHRvIGF2b2lkIGRvdWJseSBlbmNvZGluZ1xuICByZXR1cm4gVVJJLnBhcnNlKHVyaSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUmVmTW9kZWwgKGRvY3VtZW50LCBvcHRpb25zLCBtZXRhZGF0YSkge1xuICB2YXIgYWxsVGFza3MgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgdmFyIHN1YkRvY1B0ciA9IHBhdGhUb1B0cihvcHRpb25zLnN1YkRvY1BhdGgpO1xuICB2YXIgYWJzTG9jYXRpb24gPSBtYWtlQWJzb2x1dGUob3B0aW9ucy5sb2NhdGlvbik7XG4gIHZhciByZWxhdGl2ZUJhc2UgPSBwYXRoLmRpcm5hbWUob3B0aW9ucy5sb2NhdGlvbik7XG4gIHZhciBkb2NEZXBLZXkgPSBhYnNMb2NhdGlvbiArIHN1YkRvY1B0cjtcbiAgdmFyIHJlZnM7XG4gIHZhciByT3B0aW9ucztcblxuICAvLyBTdG9yZSB0aGUgZG9jdW1lbnQgaW4gdGhlIG1ldGFkYXRhIGlmIG5lY2Vzc2FyeVxuICBpZiAoXy5pc1VuZGVmaW5lZChtZXRhZGF0YS5kb2NzW2Fic0xvY2F0aW9uXSkpIHtcbiAgICBtZXRhZGF0YS5kb2NzW2Fic0xvY2F0aW9uXSA9IGRvY3VtZW50O1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgYXJlIG5vIGRlcGVuZGVuY2llcyBzdG9yZWQgZm9yIHRoZSBsb2NhdGlvbitzdWJEb2NQYXRoLCB3ZSd2ZSBuZXZlciBzZWVuIGl0IGJlZm9yZSBhbmQgd2lsbCBwcm9jZXNzIGl0XG4gIGlmIChfLmlzVW5kZWZpbmVkKG1ldGFkYXRhLmRlcHNbZG9jRGVwS2V5XSkpIHtcbiAgICBtZXRhZGF0YS5kZXBzW2RvY0RlcEtleV0gPSB7fTtcblxuICAgIC8vIEZpbmQgdGhlIHJlZmVyZW5jZXMgYmFzZWQgb24gdGhlIG9wdGlvbnNcbiAgICByZWZzID0gZmluZFJlZnMoZG9jdW1lbnQsIG9wdGlvbnMpO1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSByZWZlcmVuY2VzIGFuZCBwcm9jZXNzXG4gICAgXy5mb3JPd24ocmVmcywgZnVuY3Rpb24gKHJlZkRldGFpbHMsIHJlZlB0cikge1xuICAgICAgdmFyIHJlZktleSA9IG1ha2VBYnNvbHV0ZShvcHRpb25zLmxvY2F0aW9uKSArIHJlZlB0cjtcbiAgICAgIHZhciByZWZkS2V5ID0gcmVmRGV0YWlscy5yZWZkSWQgPSBkZWNvZGVVUkkobWFrZUFic29sdXRlKGlzUmVtb3RlKHJlZkRldGFpbHMpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21iaW5lVVJJcyhyZWxhdGl2ZUJhc2UsIHJlZkRldGFpbHMudXJpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhdGlvbikgKyAnIycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlZkRldGFpbHMudXJpLmluZGV4T2YoJyMnKSA+IC0xID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZkRldGFpbHMudXJpLnNwbGl0KCcjJylbMV0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJycpKTtcblxuICAgICAgLy8gUmVjb3JkIHJlZmVyZW5jZSBtZXRhZGF0YVxuICAgICAgbWV0YWRhdGEucmVmc1tyZWZLZXldID0gcmVmRGV0YWlscztcblxuICAgICAgLy8gRG8gbm90IHByb2Nlc3MgaW52YWxpZCByZWZlcmVuY2VzXG4gICAgICBpZiAoIWlzVmFsaWQocmVmRGV0YWlscykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBSZWNvcmQgdGhlIGZ1bGx5LXF1YWxpZmllZCBVUklcbiAgICAgIHJlZkRldGFpbHMuZnFVUkkgPSByZWZkS2V5O1xuXG4gICAgICAvLyBSZWNvcmQgZGVwZW5kZW5jeSAocmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50J3Mgc3ViLWRvY3VtZW50IHBhdGgpXG4gICAgICBtZXRhZGF0YS5kZXBzW2RvY0RlcEtleV1bcmVmUHRyID09PSBzdWJEb2NQdHIgPyAnIycgOiByZWZQdHIucmVwbGFjZShzdWJEb2NQdHIgKyAnLycsICcjLycpXSA9IHJlZmRLZXk7XG5cbiAgICAgIC8vIERvIG5vdCBwcm9jZXNzIGRpcmVjdGx5LWNpcmN1bGFyIHJlZmVyZW5jZXMgKHRvIGFuIGFuY2VzdG9yIG9yIHNlbGYpXG4gICAgICBpZiAocmVmS2V5LmluZGV4T2YocmVmZEtleSArICcvJykgPT09IDAgfHwgcmVmS2V5ID09PSByZWZkS2V5KSB7XG4gICAgICAgIHJlZkRldGFpbHMuY2lyY3VsYXIgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlcGFyZSB0aGUgb3B0aW9ucyBmb3Igc3Vic2VxdWVudCBwcm9jZXNzRG9jdW1lbnQgY2FsbHNcbiAgICAgIHJPcHRpb25zID0gXy5jbG9uZURlZXAob3B0aW9ucyk7XG5cbiAgICAgIHJPcHRpb25zLnN1YkRvY1BhdGggPSBfLmlzVW5kZWZpbmVkKHJlZkRldGFpbHMudXJpRGV0YWlscy5mcmFnbWVudCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoRnJvbVB0cihkZWNvZGVVUkkocmVmRGV0YWlscy51cmlEZXRhaWxzLmZyYWdtZW50KSk7XG5cbiAgICAgIC8vIFJlc29sdmUgdGhlIHJlZmVyZW5jZVxuICAgICAgaWYgKGlzUmVtb3RlKHJlZkRldGFpbHMpKSB7XG4gICAgICAgIC8vIERlbGV0ZSBmaWx0ZXIub3B0aW9ucyBiZWNhdXNlIGFsbCByZW1vdGUgcmVmZXJlbmNlcyBzaG91bGQgYmUgZnVsbHkgcmVzb2x2ZWRcbiAgICAgICAgZGVsZXRlIHJPcHRpb25zLmZpbHRlcjtcbiAgICAgICAgLy8gVGhlIG5ldyBsb2NhdGlvbiBiZWluZyByZWZlcmVuY2VkXG4gICAgICAgIHJPcHRpb25zLmxvY2F0aW9uID0gcmVmZEtleS5zcGxpdCgnIycpWzBdO1xuXG4gICAgICAgIGFsbFRhc2tzID0gYWxsVGFza3NcbiAgICAgICAgICAudGhlbihmdW5jdGlvbiAobk1ldGFkYXRhLCBuT3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHJBYnNMb2NhdGlvbiA9IG1ha2VBYnNvbHV0ZShuT3B0aW9ucy5sb2NhdGlvbik7XG4gICAgICAgICAgICAgIHZhciByRG9jID0gbk1ldGFkYXRhLmRvY3NbckFic0xvY2F0aW9uXTtcblxuICAgICAgICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChyRG9jKSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgbm8gY2FjaGUgc28gd2UgbXVzdCByZXRyaWV2ZSB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmVtb3RlRG9jdW1lbnQockFic0xvY2F0aW9uLCBuT3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSByZXNwb25zZSBpbiB0aGUgZG9jdW1lbnQgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbk1ldGFkYXRhLmRvY3NbckFic0xvY2F0aW9uXSA9IGVycjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGVycm9yIHRvIGFsbG93IHRoZSBzdWJzZXF1ZW50IGB0aGVuYCB0byBoYW5kbGUgYm90aCBlcnJvcnMgYW5kIHN1Y2Nlc3Nlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IHJldHJpZXZlZCAob3IgYXR0ZW1wdGVkIHRvKSB0aGUgZG9jdW1lbnQgYW5kIHNob3VsZCB1c2UgdGhlIGNhY2hlZCB2ZXJzaW9uIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIG1ldGFkYXRhIHNpbmNlIGl0IGNvdWxkIGFscmVhZHkgYmUgcHJvY2Vzc2VkIHNvbWUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByRG9jO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfShtZXRhZGF0YSwgck9wdGlvbnMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbFRhc2tzID0gYWxsVGFza3NcbiAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFByb2Nlc3MgdGhlIHJlbW90ZSBkb2N1bWVudCBvciB0aGUgcmVmZXJlbmNlZCBwb3J0aW9uIG9mIHRoZSBsb2NhbCBkb2N1bWVudFxuICAgICAgYWxsVGFza3MgPSBhbGxUYXNrc1xuICAgICAgICAudGhlbihmdW5jdGlvbiAobk1ldGFkYXRhLCBuT3B0aW9ucywgblJlZkRldGFpbHMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRvYykge1xuICAgICAgICAgICAgaWYgKF8uaXNFcnJvcihkb2MpKSB7XG4gICAgICAgICAgICAgIG1hcmtNaXNzaW5nKG5SZWZEZXRhaWxzLCBkb2MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gV3JhcHBlZCBpbiBhIHRyeS9jYXRjaCBzaW5jZSBmaW5kUmVmcyB0aHJvd3NcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRSZWZNb2RlbChkb2MsIG5PcHRpb25zLCBuTWV0YWRhdGEpXG4gICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBtYXJrTWlzc2luZyhuUmVmRGV0YWlscywgZXJyKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBtYXJrTWlzc2luZyhuUmVmRGV0YWlscywgZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0obWV0YWRhdGEsIHJPcHRpb25zLCByZWZEZXRhaWxzKSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gYWxsVGFza3M7XG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlIChvYmosIHJlZlBhdGgsIHZhbHVlKSB7XG4gIGZpbmRWYWx1ZShvYmosIHJlZlBhdGguc2xpY2UoMCwgcmVmUGF0aC5sZW5ndGggLSAxKSlbcmVmUGF0aFtyZWZQYXRoLmxlbmd0aCAtIDFdXSA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiB3YWxrIChhbmNlc3RvcnMsIG5vZGUsIHBhdGgsIGZuKSB7XG4gIHZhciBwcm9jZXNzQ2hpbGRyZW4gPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIHdhbGtJdGVtIChpdGVtLCBzZWdtZW50KSB7XG4gICAgcGF0aC5wdXNoKHNlZ21lbnQpO1xuICAgIHdhbGsoYW5jZXN0b3JzLCBpdGVtLCBwYXRoLCBmbik7XG4gICAgcGF0aC5wb3AoKTtcbiAgfVxuXG4gIC8vIENhbGwgdGhlIGl0ZXJhdGVlXG4gIGlmIChfLmlzRnVuY3Rpb24oZm4pKSB7XG4gICAgcHJvY2Vzc0NoaWxkcmVuID0gZm4oYW5jZXN0b3JzLCBub2RlLCBwYXRoKTtcbiAgfVxuXG4gIC8vIFdlIGRvIG5vdCBwcm9jZXNzIGNpcmN1bGFyIG9iamVjdHMgYWdhaW5cbiAgaWYgKGFuY2VzdG9ycy5pbmRleE9mKG5vZGUpID09PSAtMSkge1xuICAgIGFuY2VzdG9ycy5wdXNoKG5vZGUpO1xuXG4gICAgaWYgKHByb2Nlc3NDaGlsZHJlbiAhPT0gZmFsc2UpIHtcbiAgICAgIGlmIChfLmlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgbm9kZS5mb3JFYWNoKGZ1bmN0aW9uIChtZW1iZXIsIGluZGV4KSB7XG4gICAgICAgICAgd2Fsa0l0ZW0obWVtYmVyLCBpbmRleC50b1N0cmluZygpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3Qobm9kZSkpIHtcbiAgICAgICAgXy5mb3JPd24obm9kZSwgZnVuY3Rpb24gKGNOb2RlLCBrZXkpIHtcbiAgICAgICAgICB3YWxrSXRlbShjTm9kZSwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYW5jZXN0b3JzLnBvcCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9ucyAob3B0aW9ucywgb2JqKSB7XG4gIHZhciBsb2NhdGlvblBhcnRzO1xuICB2YXIgc2hvdWxkRGVjb2RlO1xuXG4gIGlmIChfLmlzVW5kZWZpbmVkKG9wdGlvbnMpKSB7XG4gICAgLy8gRGVmYXVsdCB0byBhbiBlbXB0eSBvcHRpb25zIG9iamVjdFxuICAgIG9wdGlvbnMgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDbG9uZSB0aGUgb3B0aW9ucyBzbyB3ZSBkbyBub3QgYWx0ZXIgdGhlIG9uZXMgcGFzc2VkIGluXG4gICAgb3B0aW9ucyA9IF8uY2xvbmVEZWVwKG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCFfLmlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIE9iamVjdCcpO1xuICB9IGVsc2UgaWYgKCFfLmlzVW5kZWZpbmVkKG9wdGlvbnMucmVzb2x2ZUNpcmN1bGFycykgJiZcbiAgICAgICAgICAgICAhXy5pc0Jvb2xlYW4ob3B0aW9ucy5yZXNvbHZlQ2lyY3VsYXJzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMucmVzb2x2ZUNpcmN1bGFycyBtdXN0IGJlIGEgQm9vbGVhbicpO1xuICB9IGVsc2UgaWYgKCFfLmlzVW5kZWZpbmVkKG9wdGlvbnMuZmlsdGVyKSAmJlxuICAgICAgICAgICAgICFfLmlzQXJyYXkob3B0aW9ucy5maWx0ZXIpICYmXG4gICAgICAgICAgICAgIV8uaXNGdW5jdGlvbihvcHRpb25zLmZpbHRlcikgJiZcbiAgICAgICAgICAgICAhXy5pc1N0cmluZyhvcHRpb25zLmZpbHRlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLmZpbHRlciBtdXN0IGJlIGFuIEFycmF5LCBhIEZ1bmN0aW9uIG9mIGEgU3RyaW5nJyk7XG4gIH0gZWxzZSBpZiAoIV8uaXNVbmRlZmluZWQob3B0aW9ucy5pbmNsdWRlSW52YWxpZCkgJiZcbiAgICAgICAgICAgICAhXy5pc0Jvb2xlYW4ob3B0aW9ucy5pbmNsdWRlSW52YWxpZCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLmluY2x1ZGVJbnZhbGlkIG11c3QgYmUgYSBCb29sZWFuJyk7XG4gIH0gZWxzZSBpZiAoIV8uaXNVbmRlZmluZWQob3B0aW9ucy5sb2NhdGlvbikgJiZcbiAgICAgICAgICAgICAhXy5pc1N0cmluZyhvcHRpb25zLmxvY2F0aW9uKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMubG9jYXRpb24gbXVzdCBiZSBhIFN0cmluZycpO1xuICB9IGVsc2UgaWYgKCFfLmlzVW5kZWZpbmVkKG9wdGlvbnMucmVmUHJlUHJvY2Vzc29yKSAmJlxuICAgICAgICAgICAgICFfLmlzRnVuY3Rpb24ob3B0aW9ucy5yZWZQcmVQcm9jZXNzb3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5yZWZQcmVQcm9jZXNzb3IgbXVzdCBiZSBhIEZ1bmN0aW9uJyk7XG4gIH0gZWxzZSBpZiAoIV8uaXNVbmRlZmluZWQob3B0aW9ucy5yZWZQb3N0UHJvY2Vzc29yKSAmJlxuICAgICAgICAgICAgICFfLmlzRnVuY3Rpb24ob3B0aW9ucy5yZWZQb3N0UHJvY2Vzc29yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMucmVmUG9zdFByb2Nlc3NvciBtdXN0IGJlIGEgRnVuY3Rpb24nKTtcbiAgfSBlbHNlIGlmICghXy5pc1VuZGVmaW5lZChvcHRpb25zLnN1YkRvY1BhdGgpICYmXG4gICAgICAgICAgICAgIV8uaXNBcnJheShvcHRpb25zLnN1YkRvY1BhdGgpICYmXG4gICAgICAgICAgICAgIWlzUHRyKG9wdGlvbnMuc3ViRG9jUGF0aCkpIHtcbiAgICAvLyBJZiBhIHBvaW50ZXIgaXMgcHJvdmlkZWQsIHRocm93IGFuIGVycm9yIGlmIGl0J3Mgbm90IHRoZSBwcm9wZXIgdHlwZVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuc3ViRG9jUGF0aCBtdXN0IGJlIGFuIEFycmF5IG9mIHBhdGggc2VnbWVudHMgb3IgYSB2YWxpZCBKU09OIFBvaW50ZXInKTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgdG8gZmFsc2UgZm9yIGFsbG93aW5nIGNpcmN1bGFyc1xuICBpZiAoXy5pc1VuZGVmaW5lZChvcHRpb25zLnJlc29sdmVDaXJjdWxhcnMpKSB7XG4gICAgb3B0aW9ucy5yZXNvbHZlQ2lyY3VsYXJzID0gZmFsc2U7XG4gIH1cblxuICBvcHRpb25zLmZpbHRlciA9IG1ha2VSZWZGaWx0ZXIob3B0aW9ucyk7XG5cbiAgLy8gb3B0aW9ucy5sb2NhdGlvbiBpcyBub3Qgb2ZmaWNpYWxseSBzdXBwb3J0ZWQgeWV0IGJ1dCB3aWxsIGJlIHdoZW4gSXNzdWUgODggaXMgY29tcGxldGVcbiAgaWYgKF8uaXNVbmRlZmluZWQob3B0aW9ucy5sb2NhdGlvbikpIHtcbiAgICBvcHRpb25zLmxvY2F0aW9uID0gbWFrZUFic29sdXRlKCcuL3Jvb3QuanNvbicpO1xuICB9XG5cbiAgbG9jYXRpb25QYXJ0cyA9IG9wdGlvbnMubG9jYXRpb24uc3BsaXQoJyMnKTtcblxuICAvLyBJZiBvcHRpb25zLmxvY2F0aW9uIGNvbnRhaW5zIGEgZnJhZ21lbnQsIHR1cm4gaXQgaW50byBhbiBvcHRpb25zLnN1YkRvY1BhdGhcbiAgaWYgKGxvY2F0aW9uUGFydHMubGVuZ3RoID4gMSkge1xuICAgIG9wdGlvbnMuc3ViRG9jUGF0aCA9ICcjJyArIGxvY2F0aW9uUGFydHNbMV07XG4gIH1cblxuICBzaG91bGREZWNvZGUgPSBkZWNvZGVVUkkob3B0aW9ucy5sb2NhdGlvbikgPT09IG9wdGlvbnMubG9jYXRpb247XG5cbiAgLy8gSnVzdCB0byBiZSBzYWZlLCByZW1vdmUgYW55IGFjY2lkZW50YWwgZnJhZ21lbnQgYXMgaXQgd291bGQgYnJlYWsgdGhpbmdzXG4gIG9wdGlvbnMubG9jYXRpb24gPSBjb21iaW5lVVJJcyhvcHRpb25zLmxvY2F0aW9uLCB1bmRlZmluZWQpO1xuXG4gIC8vIElmIHRoZSBsb2NhdGlvbiB3YXMgbm90IGVuY29kZWQsIG1la2Ugc3VyZSBpdCdzIG5vdCB3aGVuIHdlIGdldCBpdCBiYWNrIChJc3N1ZSAjMTM4KVxuICBpZiAoc2hvdWxkRGVjb2RlKSB7XG4gICAgb3B0aW9ucy5sb2NhdGlvbiA9IGRlY29kZVVSSShvcHRpb25zLmxvY2F0aW9uKTtcbiAgfVxuXG4gIC8vIFNldCB0aGUgc3ViRG9jUGF0aCB0byBhdm9pZCBldmVyeW9uZSBlbHNlIGhhdmluZyB0byBjb21wdXRlIGl0XG4gIG9wdGlvbnMuc3ViRG9jUGF0aCA9IG1ha2VTdWJEb2NQYXRoKG9wdGlvbnMpO1xuXG4gIGlmICghXy5pc1VuZGVmaW5lZChvYmopKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZpbmRWYWx1ZShvYmosIG9wdGlvbnMuc3ViRG9jUGF0aCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlLnJlcGxhY2UoJ0pTT04gUG9pbnRlcicsICdvcHRpb25zLnN1YkRvY1BhdGgnKTtcblxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVQYXRoIChwYXRoKSB7XG4gIGlmICghXy5pc0FycmF5KHBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0aCBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gIH1cblxuICByZXR1cm4gcGF0aC5tYXAoZnVuY3Rpb24gKHNlZykge1xuICAgIGlmICghXy5pc1N0cmluZyhzZWcpKSB7XG4gICAgICBzZWcgPSBKU09OLnN0cmluZ2lmeShzZWcpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWcucmVwbGFjZSgvfjEvZywgJy8nKS5yZXBsYWNlKC9+MC9nLCAnficpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlUGF0aCAocGF0aCkge1xuICBpZiAoIV8uaXNBcnJheShwYXRoKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhdGggbXVzdCBiZSBhbiBhcnJheScpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGgubWFwKGZ1bmN0aW9uIChzZWcpIHtcbiAgICBpZiAoIV8uaXNTdHJpbmcoc2VnKSkge1xuICAgICAgc2VnID0gSlNPTi5zdHJpbmdpZnkoc2VnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VnLnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZmluZFJlZnMgKG9iaiwgb3B0aW9ucykge1xuICB2YXIgcmVmcyA9IHt9O1xuXG4gIC8vIFZhbGlkYXRlIHRoZSBwcm92aWRlZCBkb2N1bWVudFxuICBpZiAoIV8uaXNBcnJheShvYmopICYmICFfLmlzT2JqZWN0KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvYmogbXVzdCBiZSBhbiBBcnJheSBvciBhbiBPYmplY3QnKTtcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIG9wdGlvbnNcbiAgb3B0aW9ucyA9IHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zLCBvYmopO1xuXG4gIC8vIFdhbGsgdGhlIGRvY3VtZW50IChvciBzdWIgZG9jdW1lbnQpIGFuZCBmaW5kIGFsbCBKU09OIFJlZmVyZW5jZXNcbiAgd2FsayhmaW5kQW5jZXN0b3JzKG9iaiwgb3B0aW9ucy5zdWJEb2NQYXRoKSxcbiAgICAgICBmaW5kVmFsdWUob2JqLCBvcHRpb25zLnN1YkRvY1BhdGgpLFxuICAgICAgIF8uY2xvbmVEZWVwKG9wdGlvbnMuc3ViRG9jUGF0aCksXG4gICAgICAgZnVuY3Rpb24gKGFuY2VzdG9ycywgbm9kZSwgcGF0aCkge1xuICAgICAgICAgdmFyIHByb2Nlc3NDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgICB2YXIgcmVmRGV0YWlscztcbiAgICAgICAgIHZhciByZWZQdHI7XG5cbiAgICAgICAgIGlmIChpc1JlZkxpa2Uobm9kZSkpIHtcbiAgICAgICAgICAgLy8gUHJlLXByb2Nlc3MgdGhlIG5vZGUgd2hlbiBuZWNlc3NhcnlcbiAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKG9wdGlvbnMucmVmUHJlUHJvY2Vzc29yKSkge1xuICAgICAgICAgICAgIG5vZGUgPSBvcHRpb25zLnJlZlByZVByb2Nlc3NvcihfLmNsb25lRGVlcChub2RlKSwgcGF0aCk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICByZWZEZXRhaWxzID0gZ2V0UmVmRGV0YWlscyhub2RlKTtcblxuICAgICAgICAgICAvLyBQb3N0LXByb2Nlc3MgdGhlIHJlZmVyZW5jZSBkZXRhaWxzXG4gICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChvcHRpb25zLnJlZlBvc3RQcm9jZXNzb3IpKSB7XG4gICAgICAgICAgICAgcmVmRGV0YWlscyA9IG9wdGlvbnMucmVmUG9zdFByb2Nlc3NvcihyZWZEZXRhaWxzLCBwYXRoKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIGlmIChvcHRpb25zLmZpbHRlcihyZWZEZXRhaWxzLCBwYXRoKSkge1xuICAgICAgICAgICAgIHJlZlB0ciA9IHBhdGhUb1B0cihwYXRoKTtcblxuICAgICAgICAgICAgIHJlZnNbcmVmUHRyXSA9IHJlZkRldGFpbHM7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICAvLyBXaGVuZXZlciBhIEpTT04gUmVmZXJlbmNlIGhhcyBleHRyYSBjaGlsZHJlbiwgaXRzIGNoaWxkcmVuIHNob3VsZCBub3QgYmUgcHJvY2Vzc2VkLlxuICAgICAgICAgICAvLyAgIFNlZTogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGJyeWFuLXp5cC1qc29uLXJlZi0wMyNzZWN0aW9uLTNcbiAgICAgICAgICAgaWYgKGdldEV4dHJhUmVmS2V5cyhub2RlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgcHJvY2Vzc0NoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIHByb2Nlc3NDaGlsZHJlbjtcbiAgICAgICB9KTtcblxuICByZXR1cm4gcmVmcztcbn1cblxuZnVuY3Rpb24gZmluZFJlZnNBdCAobG9jYXRpb24sIG9wdGlvbnMpIHtcbiAgdmFyIGFsbFRhc2tzID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgYWxsVGFza3MgPSBhbGxUYXNrc1xuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBwcm92aWRlZCBsb2NhdGlvblxuICAgICAgaWYgKCFfLmlzU3RyaW5nKGxvY2F0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsb2NhdGlvbiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBsb2NhdGlvbiB0byB0aGUgb3B0aW9ucyBmb3IgcHJvY2Vzc2luZy92YWxpZGF0aW9uXG4gICAgICAgIG9wdGlvbnMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgIH1cblxuICAgICAgLy8gVmFsaWRhdGUgb3B0aW9uc1xuICAgICAgb3B0aW9ucyA9IHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgcmV0dXJuIGdldFJlbW90ZURvY3VtZW50KG9wdGlvbnMubG9jYXRpb24sIG9wdGlvbnMpO1xuICAgIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgdmFyIGNhY2hlRW50cnkgPSBfLmNsb25lRGVlcChyZW1vdGVDYWNoZVtvcHRpb25zLmxvY2F0aW9uXSk7XG4gICAgICB2YXIgY09wdGlvbnMgPSBfLmNsb25lRGVlcChvcHRpb25zKTtcblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQoY2FjaGVFbnRyeS5yZWZzKSkge1xuICAgICAgICAvLyBEbyBub3QgZmlsdGVyIGFueSByZWZlcmVuY2VzIHNvIHRoZSBjYWNoZSBpcyBjb21wbGV0ZVxuICAgICAgICBkZWxldGUgY09wdGlvbnMuZmlsdGVyO1xuICAgICAgICBkZWxldGUgY09wdGlvbnMuc3ViRG9jUGF0aDtcblxuICAgICAgICBjT3B0aW9ucy5pbmNsdWRlSW52YWxpZCA9IHRydWU7XG5cbiAgICAgICAgcmVtb3RlQ2FjaGVbb3B0aW9ucy5sb2NhdGlvbl0ucmVmcyA9IGZpbmRSZWZzKHJlcywgY09wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdGhlIGZpbHRlciBvcHRpb25zIGJhY2tcbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChvcHRpb25zLmZpbHRlcikpIHtcbiAgICAgICAgY09wdGlvbnMuZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgd2lsbCB1c2UgdGhlIGNhY2hlIHNvIGRvbid0IHdvcnJ5IGFib3V0IGNhbGxpbmcgaXQgdHdpY2VcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZnM6IGZpbmRSZWZzKHJlcywgY09wdGlvbnMpLFxuICAgICAgICB2YWx1ZTogcmVzXG4gICAgICB9O1xuICAgIH0pO1xuXG4gIHJldHVybiBhbGxUYXNrcztcbn1cblxuZnVuY3Rpb24gZ2V0UmVmRGV0YWlscyAob2JqKSB7XG4gIHZhciBkZXRhaWxzID0ge1xuICAgIGRlZjogXy5jbG9uZURlZXAob2JqKVxuICB9O1xuICB2YXIgY2FjaGVLZXk7XG4gIHZhciBleHRyYUtleXM7XG4gIHZhciB1cmlEZXRhaWxzO1xuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyB3aWxsIHRocm93IHNvIHRoZSByZXN1bHQgZG9lc24ndCBtYXR0ZXJcbiAgICBpc1JlZkxpa2Uob2JqLCB0cnVlKTtcblxuICAgIGNhY2hlS2V5ID0gb2JqLiRyZWY7XG4gICAgdXJpRGV0YWlscyA9IHVyaURldGFpbHNDYWNoZVtjYWNoZUtleV07XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh1cmlEZXRhaWxzKSkge1xuICAgICAgdXJpRGV0YWlscyA9IHVyaURldGFpbHNDYWNoZVtjYWNoZUtleV0gPSBwYXJzZVVSSShjYWNoZUtleSk7XG4gICAgfVxuXG4gICAgZGV0YWlscy51cmkgPSBjYWNoZUtleTtcbiAgICBkZXRhaWxzLnVyaURldGFpbHMgPSB1cmlEZXRhaWxzO1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQodXJpRGV0YWlscy5lcnJvcikpIHtcbiAgICAgIGRldGFpbHMudHlwZSA9IGdldFJlZlR5cGUoZGV0YWlscyk7XG5cbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBKU09OIFBvaW50ZXJcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChbJyMnLCAnLyddLmluZGV4T2YoY2FjaGVLZXlbMF0pID4gLTEpIHtcbiAgICAgICAgICBpc1B0cihjYWNoZUtleSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FjaGVLZXkuaW5kZXhPZignIycpID4gLTEpIHtcbiAgICAgICAgICBpc1B0cih1cmlEZXRhaWxzLmZyYWdtZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGRldGFpbHMuZXJyb3IgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgZGV0YWlscy50eXBlID0gJ2ludmFsaWQnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhaWxzLmVycm9yID0gZGV0YWlscy51cmlEZXRhaWxzLmVycm9yO1xuICAgICAgZGV0YWlscy50eXBlID0gJ2ludmFsaWQnO1xuICAgIH1cblxuICAgIC8vIElkZW50aWZ5IHdhcm5pbmdcbiAgICBleHRyYUtleXMgPSBnZXRFeHRyYVJlZktleXMob2JqKTtcblxuICAgIGlmIChleHRyYUtleXMubGVuZ3RoID4gMCkge1xuICAgICAgZGV0YWlscy53YXJuaW5nID0gJ0V4dHJhIEpTT04gUmVmZXJlbmNlIHByb3BlcnRpZXMgd2lsbCBiZSBpZ25vcmVkOiAnICsgZXh0cmFLZXlzLmpvaW4oJywgJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZXRhaWxzLmVycm9yID0gZXJyLm1lc3NhZ2U7XG4gICAgZGV0YWlscy50eXBlID0gJ2ludmFsaWQnO1xuICB9XG5cbiAgcmV0dXJuIGRldGFpbHM7XG59XG5cbmZ1bmN0aW9uIGlzUHRyIChwdHIsIHRocm93V2l0aERldGFpbHMpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGZpcnN0Q2hhcjtcblxuICB0cnkge1xuICAgIGlmIChfLmlzU3RyaW5nKHB0cikpIHtcbiAgICAgIGlmIChwdHIgIT09ICcnKSB7XG4gICAgICAgIGZpcnN0Q2hhciA9IHB0ci5jaGFyQXQoMCk7XG5cbiAgICAgICAgaWYgKFsnIycsICcvJ10uaW5kZXhPZihmaXJzdENoYXIpID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHRyIG11c3Qgc3RhcnQgd2l0aCBhIC8gb3IgIy8nKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaXJzdENoYXIgPT09ICcjJyAmJiBwdHIgIT09ICcjJyAmJiBwdHIuY2hhckF0KDEpICE9PSAnLycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B0ciBtdXN0IHN0YXJ0IHdpdGggYSAvIG9yICMvJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocHRyLm1hdGNoKGJhZFB0clRva2VuUmVnZXgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwdHIgaGFzIGludmFsaWQgdG9rZW4ocyknKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B0ciBpcyBub3QgYSBTdHJpbmcnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0aHJvd1dpdGhEZXRhaWxzID09PSB0cnVlKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZDtcbn1cblxuZnVuY3Rpb24gaXNSZWYgKG9iaiwgdGhyb3dXaXRoRGV0YWlscykge1xuICByZXR1cm4gaXNSZWZMaWtlKG9iaiwgdGhyb3dXaXRoRGV0YWlscykgJiYgZ2V0UmVmRGV0YWlscyhvYmopLnR5cGUgIT09ICdpbnZhbGlkJztcbn1cblxuZnVuY3Rpb24gcGF0aEZyb21QdHIgKHB0cikge1xuICB0cnkge1xuICAgIGlzUHRyKHB0ciwgdHJ1ZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHRyIG11c3QgYmUgYSBKU09OIFBvaW50ZXI6ICcgKyBlcnIubWVzc2FnZSk7XG4gIH1cblxuICB2YXIgc2VnbWVudHMgPSBwdHIuc3BsaXQoJy8nKTtcblxuICAvLyBSZW1vdmUgdGhlIGZpcnN0IHNlZ21lbnRcbiAgc2VnbWVudHMuc2hpZnQoKTtcblxuICByZXR1cm4gZGVjb2RlUGF0aChzZWdtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHBhdGhUb1B0ciAocGF0aCwgaGFzaFByZWZpeCkge1xuICBpZiAoIV8uaXNBcnJheShwYXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGF0aCBtdXN0IGJlIGFuIEFycmF5Jyk7XG4gIH1cblxuICAvLyBFbmNvZGUgZWFjaCBzZWdtZW50IGFuZCByZXR1cm5cbiAgcmV0dXJuIChoYXNoUHJlZml4ICE9PSBmYWxzZSA/ICcjJyA6ICcnKSArIChwYXRoLmxlbmd0aCA+IDAgPyAnLycgOiAnJykgKyBlbmNvZGVQYXRoKHBhdGgpLmpvaW4oJy8nKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJlZnMgKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYWxsVGFza3MgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICBhbGxUYXNrcyA9IGFsbFRhc2tzXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIGRvY3VtZW50XG4gICAgICBpZiAoIV8uaXNBcnJheShvYmopICYmICFfLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2JqIG11c3QgYmUgYW4gQXJyYXkgb3IgYW4gT2JqZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZhbGlkYXRlIG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgPSB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucywgb2JqKTtcblxuICAgICAgLy8gQ2xvbmUgdGhlIGlucHV0IHNvIHdlIGRvIG5vdCBhbHRlciBpdFxuICAgICAgb2JqID0gXy5jbG9uZURlZXAob2JqKTtcbiAgICB9KVxuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtZXRhZGF0YSA9IHtcbiAgICAgICAgZGVwczoge30sIC8vIFRvIGF2b2lkIHByb2Nlc3NpbmcgdGhlIHNhbWUgcmVmZXJuZWNlIHR3aWNlLCBhbmQgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZSBpZGVudGlmaWNhdGlvblxuICAgICAgICBkb2NzOiB7fSwgLy8gQ2FjaGUgdG8gYXZvaWQgcHJvY2Vzc2luZyB0aGUgc2FtZSBkb2N1bWVudCBtb3JlIHRoYW4gb25jZVxuICAgICAgICByZWZzOiB7fSAvLyBSZWZlcmVuY2UgbG9jYXRpb25zIGFuZCB0aGVpciBtZXRhZGF0YVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGJ1aWxkUmVmTW9kZWwob2JqLCBvcHRpb25zLCBtZXRhZGF0YSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgdmFyIGFsbFJlZnMgPSB7fTtcbiAgICAgIHZhciBjaXJjdWxhclBhdGhzID0gW107XG4gICAgICB2YXIgY2lyY3VsYXJzID0gW107XG4gICAgICB2YXIgZGVwR3JhcGggPSBuZXcgZ2wuR3JhcGgoKTtcbiAgICAgIHZhciBmdWxsTG9jYXRpb24gPSBtYWtlQWJzb2x1dGUob3B0aW9ucy5sb2NhdGlvbik7XG4gICAgICB2YXIgcmVmc1Jvb3QgPSBmdWxsTG9jYXRpb24gKyBwYXRoVG9QdHIob3B0aW9ucy5zdWJEb2NQYXRoKTtcbiAgICAgIHZhciByZWxhdGl2ZUJhc2UgPSBwYXRoLmRpcm5hbWUoZnVsbExvY2F0aW9uKTtcblxuICAgICAgLy8gSWRlbnRpZnkgY2lyY3VsYXJzXG5cbiAgICAgIC8vIEFkZCBub2RlcyBmaXJzdFxuICAgICAgT2JqZWN0LmtleXMocmVzdWx0cy5kZXBzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGRlcEdyYXBoLnNldE5vZGUobm9kZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkIGVkZ2VzXG4gICAgICBfLmZvck93bihyZXN1bHRzLmRlcHMsIGZ1bmN0aW9uIChwcm9wcywgbm9kZSkge1xuICAgICAgICBfLmZvck93bihwcm9wcywgZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICAgIGRlcEdyYXBoLnNldEVkZ2Uobm9kZSwgZGVwKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgY2lyY3VsYXJQYXRocyA9IGdsLmFsZy5maW5kQ3ljbGVzKGRlcEdyYXBoKTtcblxuICAgICAgLy8gQ3JlYXRlIGEgdW5pcXVlIGxpc3Qgb2YgY2lyY3VsYXJzXG4gICAgICBjaXJjdWxhclBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcGF0aC5mb3JFYWNoKGZ1bmN0aW9uIChzZWcpIHtcbiAgICAgICAgICBpZiAoY2lyY3VsYXJzLmluZGV4T2Yoc2VnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNpcmN1bGFycy5wdXNoKHNlZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJZGVudGlmeSBjaXJjdWxhcnNcbiAgICAgIF8uZm9yT3duKHJlc3VsdHMuZGVwcywgZnVuY3Rpb24gKHByb3BzLCBub2RlKSB7XG4gICAgICAgIF8uZm9yT3duKHByb3BzLCBmdW5jdGlvbiAoZGVwLCBwcm9wKSB7XG4gICAgICAgICAgdmFyIGlzQ2lyY3VsYXIgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgcmVmUHRyID0gbm9kZSArIHByb3Auc2xpY2UoMSk7XG4gICAgICAgICAgdmFyIHJlZkRldGFpbHMgPSByZXN1bHRzLnJlZnNbbm9kZSArIHByb3Auc2xpY2UoMSldO1xuICAgICAgICAgIHZhciByZW1vdGUgPSBpc1JlbW90ZShyZWZEZXRhaWxzKTtcbiAgICAgICAgICB2YXIgcGF0aEluZGV4O1xuXG4gICAgICAgICAgaWYgKGNpcmN1bGFycy5pbmRleE9mKGRlcCkgPiAtMSkge1xuICAgICAgICAgICAgLy8gRmlndXJlIG91dCBpZiB0aGUgY2lyY3VsYXIgaXMgcGFydCBvZiBhIGNpcmN1bGFyIGNoYWluIG9yIGp1c3QgYSByZWZlcmVuY2UgdG8gYSBjaXJjdWxhclxuICAgICAgICAgICAgY2lyY3VsYXJQYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICAgIC8vIFNob3J0IGNpcmN1aXRcbiAgICAgICAgICAgICAgaWYgKGlzQ2lyY3VsYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwYXRoSW5kZXggPSBwYXRoLmluZGV4T2YoZGVwKTtcblxuICAgICAgICAgICAgICBpZiAocGF0aEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBlYWNoIHBhdGggc2VnbWVudCB0byBzZWUgaWYgdGhlIHJlZmVyZW5jZSBsb2NhdGlvbiBpcyBiZW5lYXRoIG9uZSBvZiBpdHMgc2VnbWVudHNcbiAgICAgICAgICAgICAgICBwYXRoLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xuICAgICAgICAgICAgICAgICAgLy8gU2hvcnQgY2lyY3VpdFxuICAgICAgICAgICAgICAgICAgaWYgKGlzQ2lyY3VsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAocmVmUHRyLmluZGV4T2Yoc2VnICsgJy8nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIGxvY2FsLCBtYXJrIGl0IGFzIGNpcmN1bGFyIGJ1dCBpZiBpdCdzIGEgcmVtb3RlIHJlZmVyZW5jZSwgb25seSBtYXJrIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIGNpcmN1bGFyIGlmIHRoZSBtYXRjaGluZyBwYXRoIGlzIHRoZSBsYXN0IHBhdGggc2VnbWVudCBvciBpdHMgbWF0Y2ggaXMgbm90IHRvIGEgZG9jdW1lbnQgcm9vdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlbW90ZSB8fCBwYXRoSW5kZXggPT09IHBhdGgubGVuZ3RoIC0gMSB8fCBkZXBbZGVwLmxlbmd0aCAtIDFdICE9PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpc0NpcmN1bGFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNDaXJjdWxhcikge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGFsbCByZWZlcmVuY2VzIGFuZCByZWZlcmVuY2UgZGV0YWlsc1xuICAgICAgICAgICAgcmVmRGV0YWlscy5jaXJjdWxhciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZXNvbHZlIHRoZSByZWZlcmVuY2VzIGluIHJldmVyc2Ugb3JkZXIgc2luY2UgdGhlIGN1cnJlbnQgb3JkZXIgaXMgdG9wLWRvd25cbiAgICAgIF8uZm9yT3duKE9iamVjdC5rZXlzKHJlc3VsdHMuZGVwcykucmV2ZXJzZSgpLCBmdW5jdGlvbiAocGFyZW50UHRyKSB7XG4gICAgICAgIHZhciBkZXBzID0gcmVzdWx0cy5kZXBzW3BhcmVudFB0cl07XG4gICAgICAgIHZhciBwUHRyUGFydHMgPSBwYXJlbnRQdHIuc3BsaXQoJyMnKTtcbiAgICAgICAgdmFyIHBEb2N1bWVudCA9IHJlc3VsdHMuZG9jc1twUHRyUGFydHNbMF1dO1xuICAgICAgICB2YXIgcFB0clBhdGggPSBwYXRoRnJvbVB0cihwUHRyUGFydHNbMV0pO1xuXG4gICAgICAgIF8uZm9yT3duKGRlcHMsIGZ1bmN0aW9uIChkZXAsIHByb3ApIHtcbiAgICAgICAgICB2YXIgZGVwUGFydHMgPSBkZXAuc3BsaXQoJyMnKTtcbiAgICAgICAgICB2YXIgZERvY3VtZW50ID0gcmVzdWx0cy5kb2NzW2RlcFBhcnRzWzBdXTtcbiAgICAgICAgICB2YXIgZFB0clBhdGggPSBwUHRyUGF0aC5jb25jYXQocGF0aEZyb21QdHIocHJvcCkpO1xuICAgICAgICAgIHZhciByZWZEZXRhaWxzID0gcmVzdWx0cy5yZWZzW3BQdHJQYXJ0c1swXSArIHBhdGhUb1B0cihkUHRyUGF0aCldO1xuXG4gICAgICAgICAgLy8gUmVzb2x2ZSByZWZlcmVuY2UgaWYgdmFsaWRcbiAgICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChyZWZEZXRhaWxzLmVycm9yKSAmJiBfLmlzVW5kZWZpbmVkKHJlZkRldGFpbHMubWlzc2luZykpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5yZXNvbHZlQ2lyY3VsYXJzICYmIHJlZkRldGFpbHMuY2lyY3VsYXIpIHtcbiAgICAgICAgICAgICAgcmVmRGV0YWlscy52YWx1ZSA9IF8uY2xvbmVEZWVwKHJlZkRldGFpbHMuZGVmKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVmRGV0YWlscy52YWx1ZSA9IGZpbmRWYWx1ZShkRG9jdW1lbnQsIHBhdGhGcm9tUHRyKGRlcFBhcnRzWzFdKSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIG1hcmtNaXNzaW5nKHJlZkRldGFpbHMsIGVycik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIGF0IHRoZSByb290IG9mIHRoZSBkb2N1bWVudCwgcmVwbGFjZSB0aGUgZG9jdW1lbnQgaW4gdGhlIGNhY2hlLiAgT3RoZXJ3aXNlLCByZXBsYWNlXG4gICAgICAgICAgICAgIC8vIHRoZSB2YWx1ZSBpbiB0aGUgYXBwcm9wcmlhdGUgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50IGNhY2hlLlxuICAgICAgICAgICAgICBpZiAocFB0clBhcnRzWzFdID09PSAnJyAmJiBwcm9wID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLmRvY3NbcFB0clBhcnRzWzBdXSA9IHJlZkRldGFpbHMudmFsdWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VmFsdWUocERvY3VtZW50LCBkUHRyUGF0aCwgcmVmRGV0YWlscy52YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIHdhbGtSZWZzIChyb290LCByZWZQdHIsIHJlZlBhdGgpIHtcbiAgICAgICAgdmFyIHJlZlB0clBhcnRzID0gcmVmUHRyLnNwbGl0KCcjJyk7XG4gICAgICAgIHZhciByZWZEZXRhaWxzID0gcmVzdWx0cy5yZWZzW3JlZlB0cl07XG4gICAgICAgIHZhciByZWZEZXBzO1xuXG4gICAgICAgIC8vIFJlY29yZCB0aGUgcmVmZXJlbmNlIChyZWxhdGl2ZSB0byB0aGUgcm9vdCBkb2N1bWVudCB1bmxlc3MgdGhlIHJlZmVyZW5jZSBpcyBpbiB0aGUgcm9vdCBkb2N1bWVudClcbiAgICAgICAgYWxsUmVmc1tyZWZQdHJQYXJ0c1swXSA9PT0gb3B0aW9ucy5sb2NhdGlvbiA/XG4gICAgICAgICAgICAgICAgICAnIycgKyByZWZQdHJQYXJ0c1sxXSA6XG4gICAgICAgICAgICAgICAgICBwYXRoVG9QdHIob3B0aW9ucy5zdWJEb2NQYXRoLmNvbmNhdChyZWZQYXRoKSldID0gcmVmRGV0YWlscztcblxuICAgICAgICAvLyBEbyBub3Qgd2FsayBpbnZhbGlkIHJlZmVyZW5jZXNcbiAgICAgICAgaWYgKHJlZkRldGFpbHMuY2lyY3VsYXIgfHwgIWlzVmFsaWQocmVmRGV0YWlscykpIHtcbiAgICAgICAgICAvLyBTYW5pdGl6ZSBlcnJvcnNcbiAgICAgICAgICBpZiAoIXJlZkRldGFpbHMuY2lyY3VsYXIgJiYgcmVmRGV0YWlscy5lcnJvcikge1xuICAgICAgICAgICAgLy8gVGhlIHdheSB3ZSB1c2UgZmluZFJlZnMgbm93IHJlc3VsdHMgaW4gYW4gZXJyb3IgdGhhdCBkb2Vzbid0IG1hdGNoIHRoZSBleHBlY3RhdGlvblxuICAgICAgICAgICAgcmVmRGV0YWlscy5lcnJvciA9IHJlZkRldGFpbHMuZXJyb3IucmVwbGFjZSgnb3B0aW9ucy5zdWJEb2NQYXRoJywgJ0pTT04gUG9pbnRlcicpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGVycm9yIHRvIHVzZSB0aGUgYXBwcm9wcmlhdGUgSlNPTiBQb2ludGVyXG4gICAgICAgICAgICBpZiAocmVmRGV0YWlscy5lcnJvci5pbmRleE9mKCcjJykgPiAtMSkge1xuICAgICAgICAgICAgICByZWZEZXRhaWxzLmVycm9yID0gcmVmRGV0YWlscy5lcnJvci5yZXBsYWNlKHJlZkRldGFpbHMudXJpLnN1YnN0cihyZWZEZXRhaWxzLnVyaS5pbmRleE9mKCcjJykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZkRldGFpbHMudXJpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVwb3J0IGVycm9ycyBvcGVuaW5nIGZpbGVzIGFzIEpTT04gUG9pbnRlciBlcnJvcnNcbiAgICAgICAgICAgIGlmIChyZWZEZXRhaWxzLmVycm9yLmluZGV4T2YoJ0VOT0VOVDonKSA9PT0gMCB8fCByZWZEZXRhaWxzLmVycm9yLmluZGV4T2YoJ05vdCBGb3VuZCcpID09PSAwKSB7XG4gICAgICAgICAgICAgIHJlZkRldGFpbHMuZXJyb3IgPSAnSlNPTiBQb2ludGVyIHBvaW50cyB0byBtaXNzaW5nIGxvY2F0aW9uOiAnICsgcmVmRGV0YWlscy51cmk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVmRGVwcyA9IHJlc3VsdHMuZGVwc1tyZWZEZXRhaWxzLnJlZmRJZF07XG5cbiAgICAgICAgaWYgKHJlZkRldGFpbHMucmVmZElkLmluZGV4T2Yocm9vdCkgIT09IDApIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhyZWZEZXBzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB3YWxrUmVmcyhyZWZEZXRhaWxzLnJlZmRJZCwgcmVmRGV0YWlscy5yZWZkSWQgKyBwcm9wLnN1YnN0cigxKSwgcmVmUGF0aC5jb25jYXQocGF0aEZyb21QdHIocHJvcCkpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2Ugb25seSBwcm9jZXNzIGEgZG9jdW1lbnQgKG9yIHN1YiBkb2N1bWVudCkgYW5kIGVhY2ggcmVmZXJlbmNlIG9uY2UgZXZlci4gIFRoaXMgbWVhbnNcbiAgICAgIC8vIHRoYXQgaWYgd2Ugd2FudCB0byBwcm92aWRlIHRoZSBmdWxsIHBpY3R1cmUgYXMgdG8gd2hhdCBwYXRocyBpbiB0aGUgcmVzb2x2ZWQgZG9jdW1lbnQgd2VyZSBjcmVhdGVkIGFzIGEgcmVzdWx0XG4gICAgICAvLyBvZiBhIHJlZmVyZW5jZSwgd2UgaGF2ZSB0byB0YWtlIG91ciBmdWxseS1xdWFsaWZpZWQgcmVmZXJlbmNlIGxvY2F0aW9ucyBhbmQgZXhwYW5kIHRoZW0gdG8gYmUgYWxsIGxvY2FsIGJhc2VkXG4gICAgICAvLyBvbiB0aGUgb3JpZ2luYWwgZG9jdW1lbnQuXG4gICAgICBPYmplY3Qua2V5cyhyZXN1bHRzLnJlZnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZlB0cikge1xuICAgICAgICB2YXIgcmVmRGV0YWlscyA9IHJlc3VsdHMucmVmc1tyZWZQdHJdO1xuICAgICAgICB2YXIgZnFVUklTZWdtZW50cztcbiAgICAgICAgdmFyIHVyaVNlZ21lbnRzO1xuXG4gICAgICAgIC8vIE1ha2UgYWxsIGZ1bGx5LXF1YWxpZmllZCByZWZlcmVuY2UgVVJJcyByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgcm9vdCAoaWYgbmVjZXNzYXJ5KS4gIFRoaXMgc3RlcCBpcyBkb25lIGhlcmVcbiAgICAgICAgLy8gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgaW5zdGVhZCBvZiBiZWxvdyB3aGVuIHRoZSBvZmZpY2lhbCBzYW5pdGl6YXRpb24gcHJvY2VzcyBydW5zLlxuICAgICAgICBpZiAocmVmRGV0YWlscy50eXBlICE9PSAnaW52YWxpZCcpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIHRyYWlsaW5nIGhhc2ggZnJvbSBkb2N1bWVudCByb290IHJlZmVyZW5jZXMgaWYgdGhleSB3ZXJlbid0IGluIHRoZSBvcmlnaW5hbCBVUklcbiAgICAgICAgICBpZiAocmVmRGV0YWlscy5mcVVSSVtyZWZEZXRhaWxzLmZxVVJJLmxlbmd0aCAtIDFdID09PSAnIycgJiZcbiAgICAgICAgICAgICAgICByZWZEZXRhaWxzLnVyaVtyZWZEZXRhaWxzLnVyaS5sZW5ndGggLSAxXSAhPT0gJyMnKSB7XG4gICAgICAgICAgICByZWZEZXRhaWxzLmZxVVJJID0gcmVmRGV0YWlscy5mcVVSSS5zdWJzdHIoMCwgcmVmRGV0YWlscy5mcVVSSS5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmcVVSSVNlZ21lbnRzID0gcmVmRGV0YWlscy5mcVVSSS5zcGxpdCgnLycpO1xuICAgICAgICAgIHVyaVNlZ21lbnRzID0gcmVmRGV0YWlscy51cmkuc3BsaXQoJy8nKTtcblxuICAgICAgICAgIC8vIFRoZSBmdWxseS1xdWFsaWZpZWQgVVJJIGlzIHVuZW5jb2RlZCBzbyB0byBrZWVwIHRoZSBvcmlnaW5hbCBmb3JtYXR0aW5nIG9mIHRoZSBVUkkgKGVuY29kZWQgdnMuIHVuZW5jb2RlZCksXG4gICAgICAgICAgLy8gd2UgbmVlZCB0byByZXBsYWNlIGVhY2ggVVJJIHNlZ21lbnQgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgICAgICBfLnRpbWVzKHVyaVNlZ21lbnRzLmxlbmd0aCAtIDEsIGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICB2YXIgblNlZyA9IHVyaVNlZ21lbnRzW3VyaVNlZ21lbnRzLmxlbmd0aCAtIHRpbWUgLSAxXTtcbiAgICAgICAgICAgIHZhciBwU2VnID0gdXJpU2VnbWVudHNbdXJpU2VnbWVudHMubGVuZ3RoIC0gdGltZV07XG4gICAgICAgICAgICB2YXIgZnFTZWdJbmRleCA9IGZxVVJJU2VnbWVudHMubGVuZ3RoIC0gdGltZSAtIDE7XG5cbiAgICAgICAgICAgIGlmIChuU2VnID09PSAnLicgfHwgblNlZyA9PT0gJy4uJyB8fCBwU2VnID09PSAnLi4nKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnFVUklTZWdtZW50c1tmcVNlZ0luZGV4XSA9IG5TZWc7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZWZEZXRhaWxzLmZxVVJJID0gZnFVUklTZWdtZW50cy5qb2luKCcvJyk7XG5cbiAgICAgICAgICAvLyBNYWtlIHRoZSBmdWxseS1xdWFsaWZpZWQgVVJJcyByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgcm9vdFxuICAgICAgICAgIGlmIChyZWZEZXRhaWxzLmZxVVJJLmluZGV4T2YoZnVsbExvY2F0aW9uKSA9PT0gMCkge1xuICAgICAgICAgICAgcmVmRGV0YWlscy5mcVVSSSA9IHJlZkRldGFpbHMuZnFVUkkucmVwbGFjZShmdWxsTG9jYXRpb24sICcnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlZkRldGFpbHMuZnFVUkkuaW5kZXhPZihyZWxhdGl2ZUJhc2UpID09PSAwKSB7XG4gICAgICAgICAgICByZWZEZXRhaWxzLmZxVVJJID0gcmVmRGV0YWlscy5mcVVSSS5yZXBsYWNlKHJlbGF0aXZlQmFzZSwgJycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZWZEZXRhaWxzLmZxVVJJWzBdID09PSAnLycpIHtcbiAgICAgICAgICAgIHJlZkRldGFpbHMuZnFVUkkgPSAnLicgKyByZWZEZXRhaWxzLmZxVVJJO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byBwcm9jZXNzIHJlZmVyZW5jZXMgZm91bmQgYXQgb3IgYmVuZWF0aCB0aGUgcHJvdmlkZWQgZG9jdW1lbnQgYW5kIHN1Yi1kb2N1bWVudCBwYXRoXG4gICAgICAgIGlmIChyZWZQdHIuaW5kZXhPZihyZWZzUm9vdCkgIT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3YWxrUmVmcyhyZWZzUm9vdCwgcmVmUHRyLCBwYXRoRnJvbVB0cihyZWZQdHIuc3Vic3RyKHJlZnNSb290Lmxlbmd0aCkpKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTYW5pdGl6ZSB0aGUgcmVmZXJlbmNlIGRldGFpbHNcbiAgICAgIF8uZm9yT3duKGFsbFJlZnMsIGZ1bmN0aW9uIChyZWZEZXRhaWxzLCByZWZQdHIpIHtcbiAgICAgICAgLy8gRGVsZXRlIHRoZSByZWZlcmVuY2UgaWQgdXNlZCBmb3IgZGVwZW5kZW5jeSB0cmFja2luZyBhbmQgY2lyY3VsYXIgaWRlbnRpZmljYXRpb25cbiAgICAgICAgZGVsZXRlIHJlZkRldGFpbHMucmVmZElkO1xuXG4gICAgICAgIC8vIEZvciBsb2NhbGx5LWNpcmN1bGFyIHJlZmVyZW5jZXMsIHVwZGF0ZSB0aGUgJHJlZiB0byBiZSBmdWxseSBxdWFsaWZpZWQgKElzc3VlICMxNzUpXG4gICAgICAgIGlmIChyZWZEZXRhaWxzLmNpcmN1bGFyICYmIHJlZkRldGFpbHMudHlwZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgIHJlZkRldGFpbHMudmFsdWUuJHJlZiA9IHJlZkRldGFpbHMuZnFVUkk7XG5cbiAgICAgICAgICBzZXRWYWx1ZShyZXN1bHRzLmRvY3NbZnVsbExvY2F0aW9uXSwgcGF0aEZyb21QdHIocmVmUHRyKSwgcmVmRGV0YWlscy52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUbyBhdm9pZCB0aGUgZXJyb3IgbWVzc2FnZSBiZWluZyBVUkkgZW5jb2RlZC9kZWNvZGVkIGJ5IG1pc3Rha2UsIHJlcGxhY2UgdGhlIGN1cnJlbnQgSlNPTiBQb2ludGVyIHdpdGggdGhlXG4gICAgICAgIC8vIHZhbHVlIGluIHRoZSBKU09OIFJlZmVyZW5jZSBkZWZpbml0aW9uLlxuICAgICAgICBpZiAocmVmRGV0YWlscy5taXNzaW5nKSB7XG4gICAgICAgICAgcmVmRGV0YWlscy5lcnJvciA9IHJlZkRldGFpbHMuZXJyb3Iuc3BsaXQoJzogJylbMF0gKyAnOiAnICsgcmVmRGV0YWlscy5kZWYuJHJlZjtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZnM6IGFsbFJlZnMsXG4gICAgICAgIHJlc29sdmVkOiByZXN1bHRzLmRvY3NbZnVsbExvY2F0aW9uXVxuICAgICAgfTtcbiAgICB9KTtcblxuICByZXR1cm4gYWxsVGFza3M7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVSZWZzQXQgKGxvY2F0aW9uLCBvcHRpb25zKSB7XG4gIHZhciBhbGxUYXNrcyA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gIGFsbFRhc2tzID0gYWxsVGFza3NcbiAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBWYWxpZGF0ZSB0aGUgcHJvdmlkZWQgbG9jYXRpb25cbiAgICAgIGlmICghXy5pc1N0cmluZyhsb2NhdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbG9jYXRpb24gbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIC8vIEFkZCB0aGUgbG9jYXRpb24gdG8gdGhlIG9wdGlvbnMgZm9yIHByb2Nlc3NpbmcvdmFsaWRhdGlvblxuICAgICAgICBvcHRpb25zLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICB9XG5cbiAgICAgIC8vIFZhbGlkYXRlIG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgPSB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgIHJldHVybiBnZXRSZW1vdGVEb2N1bWVudChvcHRpb25zLmxvY2F0aW9uLCBvcHRpb25zKTtcbiAgICB9KVxuICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHJldHVybiByZXNvbHZlUmVmcyhyZXMsIG9wdGlvbnMpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMyKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlZnM6IHJlczIucmVmcyxcbiAgICAgICAgICAgIHJlc29sdmVkOiByZXMyLnJlc29sdmVkLFxuICAgICAgICAgICAgdmFsdWU6IHJlc1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gIHJldHVybiBhbGxUYXNrcztcbn1cblxuLyoqXG4gKiBWYXJpb3VzIHV0aWxpdGllcyBmb3IgSlNPTiBSZWZlcmVuY2VzICooaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGJyeWFuLXp5cC1qc29uLXJlZi0wMykqIGFuZFxuICogSlNPTiBQb2ludGVycyAqKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxKSouXG4gKlxuICogQG1vZHVsZSBqc29uLXJlZnNcbiAqL1xuXG4vKipcbiAqIEEgbnVtYmVyIG9mIGZ1bmN0aW9ucyBleHBvcnRlZCBiZWxvdyBhcmUgdXNlZCB3aXRoaW4gdGhlIGV4cG9ydGVkIGZ1bmN0aW9ucy4gIFR5cGljYWxseSwgSSB3b3VsZCB1c2UgYSBmdW5jdGlvblxuICogZGVjbGFyYXRpb24gXyh3aXRoIGRvY3VtZW5hdGlvbilfIGFib3ZlIGFuZCB0aGVuIGp1c3QgZXhwb3J0IGEgcmVmZXJlbmNlIHRvIHRoZSBmdW5jdGlvbiBidXQgZHVlIHRvIGEgYnVnIGluIEpTRG9jXG4gKiAoaHR0cHM6Ly9naXRodWIuY29tL2pzZG9jMy9qc2RvYy9pc3N1ZXMvNjc5KSwgdGhpcyBicmVha3MgdGhlIGdlbmVyYXRlZCBBUEkgZG9jdW1lbnRhdGlvbiBhbmQgVHlwZVNjcmlwdFxuICogZGVjbGFyYXRpb25zLiAgU28gdGhhdCdzIHdoeSBlYWNoIGBtb2R1bGUuZXhwb3J0c2AgYmVsb3cgYmFzaWNhbGx5IGp1c3Qgd3JhcHMgYSBjYWxsIHRvIHRoZSBmdW5jdGlvbiBkZWNsYXJhdGlvbi5cbiAqL1xuXG4gLyoqXG4gKiBDbGVhcnMgdGhlIGludGVybmFsIGNhY2hlIG9mIHJlbW90ZSBkb2N1bWVudHMsIHJlZmVyZW5jZSBkZXRhaWxzLCBldGMuXG4gKi9cbm1vZHVsZS5leHBvcnRzLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJlbW90ZUNhY2hlID0ge307XG59O1xuXG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIHBhdGggc2VnbWVudHMgYW5kIGRlY29kZXMgdGhlIEpTT04gUG9pbnRlciB0b2tlbnMgaW4gdGhlbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRoIC0gVGhlIGFycmF5IG9mIHBhdGggc2VnbWVudHNcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IHRoZSBhcnJheSBvZiBwYXRoIHNlZ21lbnRzIHdpdGggdGhlaXIgSlNPTiBQb2ludGVyIHRva2VucyBkZWNvZGVkXG4gKlxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBwYXRoIGlzIG5vdCBhbiBgQXJyYXlgXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDEjc2VjdGlvbi0zfVxuICovXG5tb2R1bGUuZXhwb3J0cy5kZWNvZGVQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgcmV0dXJuIGRlY29kZVBhdGgocGF0aCk7XG59O1xuXG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIHBhdGggc2VnbWVudHMgYW5kIGVuY29kZXMgdGhlIHNwZWNpYWwgSlNPTiBQb2ludGVyIGNoYXJhY3RlcnMgaW4gdGhlbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRoIC0gVGhlIGFycmF5IG9mIHBhdGggc2VnbWVudHNcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IHRoZSBhcnJheSBvZiBwYXRoIHNlZ21lbnRzIHdpdGggdGhlaXIgSlNPTiBQb2ludGVyIHRva2VucyBlbmNvZGVkXG4gKlxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBwYXRoIGlzIG5vdCBhbiBgQXJyYXlgXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDEjc2VjdGlvbi0zfVxuICovXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGVQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgcmV0dXJuIGVuY29kZVBhdGgocGF0aCk7XG59O1xuXG4vKipcbiAqIEZpbmRzIEpTT04gUmVmZXJlbmNlcyBkZWZpbmVkIHdpdGhpbiB0aGUgcHJvdmlkZWQgYXJyYXkvb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBvYmogLSBUaGUgc3RydWN0dXJlIHRvIGZpbmQgSlNPTiBSZWZlcmVuY2VzIHdpdGhpblxuICogQHBhcmFtIHttb2R1bGU6anNvbi1yZWZzLkpzb25SZWZzT3B0aW9uc30gW29wdGlvbnNdIC0gVGhlIEpzb25SZWZzIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpqc29uLXJlZnMuVW5yZXNvbHZlZFJlZkRldGFpbHN8dW5kZWZpbmVkPn0gYW4gb2JqZWN0IHdob3NlIGtleXMgYXJlIEpTT04gUG9pbnRlcnNcbiAqICooZnJhZ21lbnQgdmVyc2lvbikqIHRvIHdoZXJlIHRoZSBKU09OIFJlZmVyZW5jZSBpcyBkZWZpbmVkIGFuZCB3aG9zZSB2YWx1ZXMgYXJlIHtAbGluayBVbnJlc29sdmVkUmVmRGV0YWlsc30uXG4gKlxuICogQHRocm93cyB7RXJyb3J9IHdoZW4gdGhlIGlucHV0IGFyZ3VtZW50cyBmYWlsIHZhbGlkYXRpb24gb3IgaWYgYG9wdGlvbnMuc3ViRG9jUGF0aGAgcG9pbnRzIHRvIGFuIGludmFsaWQgbG9jYXRpb25cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRmluZGluZyBhbGwgdmFsaWQgcmVmZXJlbmNlc1xuICogdmFyIGFsbFJlZnMgPSBKc29uUmVmcy5maW5kUmVmcyhvYmopO1xuICogLy8gRmluZGluZyBhbGwgcmVtb3RlIHJlZmVyZW5jZXNcbiAqIHZhciByZW1vdGVSZWZzID0gSnNvblJlZnMuZmluZFJlZnMob2JqLCB7ZmlsdGVyOiBbJ3JlbGF0aXZlJywgJ3JlbW90ZSddfSk7XG4gKiAvLyBGaW5kaW5nIGFsbCBpbnZhbGlkIHJlZmVyZW5jZXNcbiAqIHZhciBpbnZhbGlkUmVmcyA9IEpzb25SZWZzLmZpbmRSZWZzKG9iaiwge2ZpbHRlcjogJ2ludmFsaWQnLCBpbmNsdWRlSW52YWxpZDogdHJ1ZX0pO1xuICovXG5tb2R1bGUuZXhwb3J0cy5maW5kUmVmcyA9IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZpbmRSZWZzKG9iaiwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEZpbmRzIEpTT04gUmVmZXJlbmNlcyBkZWZpbmVkIHdpdGhpbiB0aGUgZG9jdW1lbnQgYXQgdGhlIHByb3ZpZGVkIGxvY2F0aW9uLlxuICpcbiAqIFRoaXMgQVBJIGlzIGlkZW50aWNhbCB0byB7QGxpbmsgZmluZFJlZnN9IGV4Y2VwdCB0aGlzIEFQSSB3aWxsIHJldHJpZXZlIGEgcmVtb3RlIGRvY3VtZW50IGFuZCB0aGVuXG4gKiByZXR1cm4gdGhlIHJlc3VsdCBvZiB7QGxpbmsgZmluZFJlZnN9IG9uIHRoZSByZXRyaWV2ZWQgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIC0gVGhlIGxvY2F0aW9uIHRvIHJldHJpZXZlICooQ2FuIGJlIHJlbGF0aXZlIG9yIGFic29sdXRlLCBqdXN0IG1ha2Ugc3VyZSB5b3UgbG9vayBhdCB0aGVcbiAqIHtAbGluayBtb2R1bGU6anNvbi1yZWZzLkpzb25SZWZzT3B0aW9uc3xvcHRpb25zIGRvY3VtZW50YXRpb259IHRvIHNlZSBob3cgcmVsYXRpdmUgcmVmZXJlbmNlcyBhcmUgaGFuZGxlZC4pKlxuICogQHBhcmFtIHttb2R1bGU6anNvbi1yZWZzLkpzb25SZWZzT3B0aW9uc30gW29wdGlvbnNdIC0gVGhlIEpzb25SZWZzIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxtb2R1bGU6anNvbi1yZWZzLlJldHJpZXZlZFJlZnNSZXN1bHRzPn0gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYVxuICoge0BsaW5rIG1vZHVsZTpqc29uLXJlZnMuUmV0cmlldmVkUmVmc1Jlc3VsdHN9IGFuZCByZWplY3RzIHdpdGggYW4gYEVycm9yYCB3aGVuIHRoZSBpbnB1dCBhcmd1bWVudHMgZmFpbCB2YWxpZGF0aW9uLFxuICogd2hlbiBgb3B0aW9ucy5zdWJEb2NQYXRoYCBwb2ludHMgdG8gYW4gaW52YWxpZCBsb2NhdGlvbiBvciB3aGVuIHRoZSBsb2NhdGlvbiBhcmd1bWVudCBwb2ludHMgdG8gYW4gdW5sb2FkYWJsZVxuICogcmVzb3VyY2VcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRXhhbXBsZSB0aGF0IG9ubHkgcmVzb2x2ZXMgcmVmZXJlbmNlcyB3aXRoaW4gYSBzdWIgZG9jdW1lbnRcbiAqIEpzb25SZWZzLmZpbmRSZWZzQXQoJ2h0dHA6Ly9wZXRzdG9yZS5zd2FnZ2VyLmlvL3YyL3N3YWdnZXIuanNvbicsIHtcbiAqICAgICBzdWJEb2NQYXRoOiAnIy9kZWZpbml0aW9ucydcbiAqICAgfSlcbiAqICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICogICAgICAvLyBEbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzcG9uc2VcbiAqICAgICAgLy9cbiAqICAgICAgLy8gcmVzLnJlZnM6IEpTT04gUmVmZXJlbmNlIGxvY2F0aW9ucyBhbmQgZGV0YWlsc1xuICogICAgICAvLyByZXMudmFsdWU6IFRoZSByZXRyaWV2ZWQgZG9jdW1lbnRcbiAqICAgfSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKGVyci5zdGFjayk7XG4gKiAgIH0pO1xuICovXG5tb2R1bGUuZXhwb3J0cy5maW5kUmVmc0F0ID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBvcHRpb25zKSB7XG4gIHJldHVybiBmaW5kUmVmc0F0KGxvY2F0aW9uLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgSlNPTiBSZWZlcmVuY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIFRoZSBKU09OIFJlZmVyZW5jZSBkZWZpbml0aW9uXG4gKlxuICogQHJldHVybnMge21vZHVsZTpqc29uLXJlZnMuVW5yZXNvbHZlZFJlZkRldGFpbHN9IHRoZSBkZXRhaWxlZCBpbmZvcm1hdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cy5nZXRSZWZEZXRhaWxzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gZ2V0UmVmRGV0YWlscyhvYmopO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGFyZ3VtZW50IHJlcHJlc2VudHMgYSBKU09OIFBvaW50ZXIuXG4gKlxuICogQSBzdHJpbmcgaXMgYSBKU09OIFBvaW50ZXIgaWYgdGhlIGZvbGxvd2luZyBhcmUgYWxsIHRydWU6XG4gKlxuICogICAqIFRoZSBzdHJpbmcgaXMgb2YgdHlwZSBgU3RyaW5nYFxuICogICAqIFRoZSBzdHJpbmcgbXVzdCBiZSBlbXB0eSwgYCNgIG9yIHN0YXJ0IHdpdGggYSBgL2Agb3IgYCMvYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdHIgLSBUaGUgc3RyaW5nIHRvIGNoZWNrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt0aHJvd1dpdGhEZXRhaWxzPWZhbHNlXSAtIFdoZXRoZXIgb3Igbm90IHRvIHRocm93IGFuIGBFcnJvcmAgd2l0aCB0aGUgZGV0YWlscyBhcyB0byB3aHkgdGhlIHZhbHVlXG4gKiBwcm92aWRlZCBpcyBpbnZhbGlkXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIGNoZWNrXG4gKlxuICogQHRocm93cyB7ZXJyb3J9IHdoZW4gdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGludmFsaWQgYW5kIHRoZSBgdGhyb3dXaXRoRGV0YWlsc2AgYXJndW1lbnQgaXMgYHRydWVgXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDEjc2VjdGlvbi0zfVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTZXBhcmF0aW5nIHRoZSBkaWZmZXJlbnQgd2F5cyB0byBpbnZva2UgaXNQdHIgZm9yIGRlbW9uc3RyYXRpb24gcHVycG9zZXNcbiAqIGlmIChpc1B0cihzdHIpKSB7XG4gKiAgIC8vIEhhbmRsZSBhIHZhbGlkIEpTT04gUG9pbnRlclxuICogfSBlbHNlIHtcbiAqICAgLy8gR2V0IHRoZSByZWFzb24gYXMgdG8gd2h5IHRoZSB2YWx1ZSBpcyBub3QgYSBKU09OIFBvaW50ZXIgc28geW91IGNhbiBmaXgvcmVwb3J0IGl0XG4gKiAgIHRyeSB7XG4gKiAgICAgaXNQdHIoc3RyLCB0cnVlKTtcbiAqICAgfSBjYXRjaCAoZXJyKSB7XG4gKiAgICAgLy8gVGhlIGVycm9yIG1lc3NhZ2UgY29udGFpbnMgdGhlIGRldGFpbHMgYXMgdG8gd2h5IHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBub3QgYSBKU09OIFBvaW50ZXJcbiAqICAgfVxuICogfVxuICovXG5tb2R1bGUuZXhwb3J0cy5pc1B0ciA9IGZ1bmN0aW9uIChwdHIsIHRocm93V2l0aERldGFpbHMpIHtcbiAgcmV0dXJuIGlzUHRyKHB0ciwgdGhyb3dXaXRoRGV0YWlscyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgYXJndW1lbnQgcmVwcmVzZW50cyBhIEpTT04gUmVmZXJlbmNlLlxuICpcbiAqIEFuIG9iamVjdCBpcyBhIEpTT04gUmVmZXJlbmNlIG9ubHkgaWYgdGhlIGZvbGxvd2luZyBhcmUgYWxsIHRydWU6XG4gKlxuICogICAqIFRoZSBvYmplY3QgaXMgb2YgdHlwZSBgT2JqZWN0YFxuICogICAqIFRoZSBvYmplY3QgaGFzIGEgYCRyZWZgIHByb3BlcnR5XG4gKiAgICogVGhlIGAkcmVmYCBwcm9wZXJ0eSBpcyBhIHZhbGlkIFVSSSAqKFdlIGRvIG5vdCByZXF1aXJlIDEwMCUgc3RyaWN0IFVSSXMgYW5kIHdpbGwgaGFuZGxlIHVuZXNjYXBlZCBzcGVjaWFsXG4gKiAgICAgY2hhcmFjdGVycy4pKlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSBUaGUgb2JqZWN0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt0aHJvd1dpdGhEZXRhaWxzPWZhbHNlXSAtIFdoZXRoZXIgb3Igbm90IHRvIHRocm93IGFuIGBFcnJvcmAgd2l0aCB0aGUgZGV0YWlscyBhcyB0byB3aHkgdGhlIHZhbHVlXG4gKiBwcm92aWRlZCBpcyBpbnZhbGlkXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIGNoZWNrXG4gKlxuICogQHRocm93cyB7ZXJyb3J9IHdoZW4gdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGludmFsaWQgYW5kIHRoZSBgdGhyb3dXaXRoRGV0YWlsc2AgYXJndW1lbnQgaXMgYHRydWVgXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGJyeWFuLXp5cC1qc29uLXJlZi0wMyNzZWN0aW9uLTN9XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFNlcGFyYXRpbmcgdGhlIGRpZmZlcmVudCB3YXlzIHRvIGludm9rZSBpc1JlZiBmb3IgZGVtb25zdHJhdGlvbiBwdXJwb3Nlc1xuICogaWYgKGlzUmVmKG9iaikpIHtcbiAqICAgLy8gSGFuZGxlIGEgdmFsaWQgSlNPTiBSZWZlcmVuY2VcbiAqIH0gZWxzZSB7XG4gKiAgIC8vIEdldCB0aGUgcmVhc29uIGFzIHRvIHdoeSB0aGUgdmFsdWUgaXMgbm90IGEgSlNPTiBSZWZlcmVuY2Ugc28geW91IGNhbiBmaXgvcmVwb3J0IGl0XG4gKiAgIHRyeSB7XG4gKiAgICAgaXNSZWYoc3RyLCB0cnVlKTtcbiAqICAgfSBjYXRjaCAoZXJyKSB7XG4gKiAgICAgLy8gVGhlIGVycm9yIG1lc3NhZ2UgY29udGFpbnMgdGhlIGRldGFpbHMgYXMgdG8gd2h5IHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBub3QgYSBKU09OIFJlZmVyZW5jZVxuICogICB9XG4gKiB9XG4gKi9cbm1vZHVsZS5leHBvcnRzLmlzUmVmID0gZnVuY3Rpb24gKG9iaiwgdGhyb3dXaXRoRGV0YWlscykge1xuICByZXR1cm4gaXNSZWYob2JqLCB0aHJvd1dpdGhEZXRhaWxzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBwYXRoIHNlZ21lbnRzIGZvciB0aGUgcHJvdmlkZWQgSlNPTiBQb2ludGVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdHIgLSBUaGUgSlNPTiBQb2ludGVyXG4gKlxuICogQHJldHVybnMge3N0cmluZ1tdfSB0aGUgcGF0aCBzZWdtZW50c1xuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgcHJvdmlkZWQgYHB0cmAgYXJndW1lbnQgaXMgbm90IGEgSlNPTiBQb2ludGVyXG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhdGhGcm9tUHRyID0gZnVuY3Rpb24gKHB0cikge1xuICByZXR1cm4gcGF0aEZyb21QdHIocHRyKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIEpTT04gUG9pbnRlciBmb3IgdGhlIHByb3ZpZGVkIGFycmF5IG9mIHBhdGggc2VnbWVudHMuXG4gKlxuICogKipOb3RlOioqIElmIGEgcGF0aCBzZWdtZW50IGluIGBwYXRoYCBpcyBub3QgYSBgU3RyaW5nYCwgaXQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gb25lIHVzaW5nIGBKU09OLnN0cmluZ2lmeWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aCAtIFRoZSBhcnJheSBvZiBwYXRoIHNlZ21lbnRzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtoYXNoUHJlZml4PXRydWVdIC0gV2hldGhlciBvciBub3QgY3JlYXRlIGEgaGFzaC1wcmVmaXhlZCBKU09OIFBvaW50ZXJcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgY29ycmVzcG9uZGluZyBKU09OIFBvaW50ZXJcbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGBwYXRoYCBhcmd1bWVudCBpcyBub3QgYW4gYXJyYXlcbiAqL1xubW9kdWxlLmV4cG9ydHMucGF0aFRvUHRyID0gZnVuY3Rpb24gKHBhdGgsIGhhc2hQcmVmaXgpIHtcbiAgcmV0dXJuIHBhdGhUb1B0cihwYXRoLCBoYXNoUHJlZml4KTtcbn07XG5cbi8qKlxuICogRmluZHMgSlNPTiBSZWZlcmVuY2VzIGRlZmluZWQgd2l0aGluIHRoZSBwcm92aWRlZCBhcnJheS9vYmplY3QgYW5kIHJlc29sdmVzIHRoZW0uXG4gKlxuICogQHBhcmFtIHthcnJheXxvYmplY3R9IG9iaiAtIFRoZSBzdHJ1Y3R1cmUgdG8gZmluZCBKU09OIFJlZmVyZW5jZXMgd2l0aGluXG4gKiBAcGFyYW0ge21vZHVsZTpqc29uLXJlZnMuSnNvblJlZnNPcHRpb25zfSBbb3B0aW9uc10gLSBUaGUgSnNvblJlZnMgb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPG1vZHVsZTpqc29uLXJlZnMuUmVzb2x2ZWRSZWZzUmVzdWx0cz59IGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFcbiAqIHtAbGluayBtb2R1bGU6anNvbi1yZWZzLlJlc29sdmVkUmVmc1Jlc3VsdHN9IGFuZCByZWplY3RzIHdpdGggYW4gYEVycm9yYCB3aGVuIHRoZSBpbnB1dCBhcmd1bWVudHMgZmFpbCB2YWxpZGF0aW9uLFxuICogd2hlbiBgb3B0aW9ucy5zdWJEb2NQYXRoYCBwb2ludHMgdG8gYW4gaW52YWxpZCBsb2NhdGlvbiBvciB3aGVuIHRoZSBsb2NhdGlvbiBhcmd1bWVudCBwb2ludHMgdG8gYW4gdW5sb2FkYWJsZVxuICogcmVzb3VyY2VcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRXhhbXBsZSB0aGF0IG9ubHkgcmVzb2x2ZXMgcmVsYXRpdmUgYW5kIHJlbW90ZSByZWZlcmVuY2VzXG4gKiBKc29uUmVmcy5yZXNvbHZlUmVmcyhzd2FnZ2VyT2JqLCB7XG4gKiAgICAgZmlsdGVyOiBbJ3JlbGF0aXZlJywgJ3JlbW90ZSddXG4gKiAgIH0pXG4gKiAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAqICAgICAgLy8gRG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3BvbnNlXG4gKiAgICAgIC8vXG4gKiAgICAgIC8vIHJlcy5yZWZzOiBKU09OIFJlZmVyZW5jZSBsb2NhdGlvbnMgYW5kIGRldGFpbHNcbiAqICAgICAgLy8gcmVzLnJlc29sdmVkOiBUaGUgZG9jdW1lbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgSlNPTiBSZWZlcmVuY2VzIHJlc29sdmVkXG4gKiAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIuc3RhY2spO1xuICogICB9KTtcbiAqL1xubW9kdWxlLmV4cG9ydHMucmVzb2x2ZVJlZnMgPSBmdW5jdGlvbiAob2JqLCBvcHRpb25zKSB7XG4gIHJldHVybiByZXNvbHZlUmVmcyhvYmosIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyBKU09OIFJlZmVyZW5jZXMgZGVmaW5lZCB3aXRoaW4gdGhlIGRvY3VtZW50IGF0IHRoZSBwcm92aWRlZCBsb2NhdGlvbi5cbiAqXG4gKiBUaGlzIEFQSSBpcyBpZGVudGljYWwgdG8ge0BsaW5rIG1vZHVsZTpqc29uLXJlZnMucmVzb2x2ZVJlZnN9IGV4Y2VwdCB0aGlzIEFQSSB3aWxsIHJldHJpZXZlIGEgcmVtb3RlIGRvY3VtZW50IGFuZFxuICogdGhlbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB7QGxpbmsgbW9kdWxlOmpzb24tcmVmcy5yZXNvbHZlUmVmc30gb24gdGhlIHJldHJpZXZlZCBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gLSBUaGUgbG9jYXRpb24gdG8gcmV0cmlldmUgKihDYW4gYmUgcmVsYXRpdmUgb3IgYWJzb2x1dGUsIGp1c3QgbWFrZSBzdXJlIHlvdSBsb29rIGF0IHRoZVxuICoge0BsaW5rIG1vZHVsZTpqc29uLXJlZnMuSnNvblJlZnNPcHRpb25zfG9wdGlvbnMgZG9jdW1lbnRhdGlvbn0gdG8gc2VlIGhvdyByZWxhdGl2ZSByZWZlcmVuY2VzIGFyZSBoYW5kbGVkLikqXG4gKiBAcGFyYW0ge21vZHVsZTpqc29uLXJlZnMuSnNvblJlZnNPcHRpb25zfSBbb3B0aW9uc10gLSBUaGUgSnNvblJlZnMgb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPG1vZHVsZTpqc29uLXJlZnMuUmV0cmlldmVkUmVzb2x2ZWRSZWZzUmVzdWx0cz59IGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFcbiAqIHtAbGluayBtb2R1bGU6anNvbi1yZWZzLlJldHJpZXZlZFJlc29sdmVkUmVmc1Jlc3VsdHN9IGFuZCByZWplY3RzIHdpdGggYW4gYEVycm9yYCB3aGVuIHRoZSBpbnB1dCBhcmd1bWVudHMgZmFpbFxuICogdmFsaWRhdGlvbiwgd2hlbiBgb3B0aW9ucy5zdWJEb2NQYXRoYCBwb2ludHMgdG8gYW4gaW52YWxpZCBsb2NhdGlvbiBvciB3aGVuIHRoZSBsb2NhdGlvbiBhcmd1bWVudCBwb2ludHMgdG8gYW5cbiAqIHVubG9hZGFibGUgcmVzb3VyY2VcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRXhhbXBsZSB0aGF0IGxvYWRzIGEgSlNPTiBkb2N1bWVudCAoTm8gb3B0aW9ucy5sb2FkZXJPcHRpb25zLnByb2Nlc3NDb250ZW50IHJlcXVpcmVkKSBhbmQgcmVzb2x2ZXMgYWxsIHJlZmVyZW5jZXNcbiAqIEpzb25SZWZzLnJlc29sdmVSZWZzQXQoJy4vc3dhZ2dlci5qc29uJylcbiAqICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICogICAgICAvLyBEbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzcG9uc2VcbiAqICAgICAgLy9cbiAqICAgICAgLy8gcmVzLnJlZnM6IEpTT04gUmVmZXJlbmNlIGxvY2F0aW9ucyBhbmQgZGV0YWlsc1xuICogICAgICAvLyByZXMucmVzb2x2ZWQ6IFRoZSBkb2N1bWVudCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBKU09OIFJlZmVyZW5jZXMgcmVzb2x2ZWRcbiAqICAgICAgLy8gcmVzLnZhbHVlOiBUaGUgcmV0cmlldmVkIGRvY3VtZW50XG4gKiAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIuc3RhY2spO1xuICogICB9KTtcbiAqL1xubW9kdWxlLmV4cG9ydHMucmVzb2x2ZVJlZnNBdCA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgb3B0aW9ucykge1xuICByZXR1cm4gcmVzb2x2ZVJlZnNBdChsb2NhdGlvbiwgb3B0aW9ucyk7XG59O1xuIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIENocmlzIFBldHRpdHRcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGNvcHlyaWdodCBob2xkZXIgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzXG4gKiBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dFxuICogc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuICogQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAqIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAqIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEVcbiAqIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXG4gKiBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUlxuICogU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVJcbiAqIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksXG4gKiBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG52YXIgbGliID0gcmVxdWlyZShcIi4vbGliXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR3JhcGg6IGxpYi5HcmFwaCxcbiAganNvbjogcmVxdWlyZShcIi4vbGliL2pzb25cIiksXG4gIGFsZzogcmVxdWlyZShcIi4vbGliL2FsZ1wiKSxcbiAgdmVyc2lvbjogbGliLnZlcnNpb25cbn07XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcG9uZW50cztcblxuZnVuY3Rpb24gY29tcG9uZW50cyhnKSB7XG4gIHZhciB2aXNpdGVkID0ge307XG4gIHZhciBjbXB0cyA9IFtdO1xuICB2YXIgY21wdDtcblxuICBmdW5jdGlvbiBkZnModikge1xuICAgIGlmIChfLmhhcyh2aXNpdGVkLCB2KSkgcmV0dXJuO1xuICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuICAgIGNtcHQucHVzaCh2KTtcbiAgICBfLmVhY2goZy5zdWNjZXNzb3JzKHYpLCBkZnMpO1xuICAgIF8uZWFjaChnLnByZWRlY2Vzc29ycyh2KSwgZGZzKTtcbiAgfVxuXG4gIF8uZWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICBjbXB0ID0gW107XG4gICAgZGZzKHYpO1xuICAgIGlmIChjbXB0Lmxlbmd0aCkge1xuICAgICAgY21wdHMucHVzaChjbXB0KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjbXB0cztcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZnM7XG5cbi8qXG4gKiBBIGhlbHBlciB0aGF0IHByZWZvcm1zIGEgcHJlLSBvciBwb3N0LW9yZGVyIHRyYXZlcnNhbCBvbiB0aGUgaW5wdXQgZ3JhcGhcbiAqIGFuZCByZXR1cm5zIHRoZSBub2RlcyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIHZpc2l0ZWQuIElmIHRoZSBncmFwaCBpc1xuICogdW5kaXJlY3RlZCB0aGVuIHRoaXMgYWxnb3JpdGhtIHdpbGwgbmF2aWdhdGUgdXNpbmcgbmVpZ2hib3JzLiBJZiB0aGUgZ3JhcGhcbiAqIGlzIGRpcmVjdGVkIHRoZW4gdGhpcyBhbGdvcml0aG0gd2lsbCBuYXZpZ2F0ZSB1c2luZyBzdWNjZXNzb3JzLlxuICpcbiAqIE9yZGVyIG11c3QgYmUgb25lIG9mIFwicHJlXCIgb3IgXCJwb3N0XCIuXG4gKi9cbmZ1bmN0aW9uIGRmcyhnLCB2cywgb3JkZXIpIHtcbiAgaWYgKCFfLmlzQXJyYXkodnMpKSB7XG4gICAgdnMgPSBbdnNdO1xuICB9XG5cbiAgdmFyIG5hdmlnYXRpb24gPSAoZy5pc0RpcmVjdGVkKCkgPyBnLnN1Y2Nlc3NvcnMgOiBnLm5laWdoYm9ycykuYmluZChnKTtcblxuICB2YXIgYWNjID0gW107XG4gIHZhciB2aXNpdGVkID0ge307XG4gIF8uZWFjaCh2cywgZnVuY3Rpb24odikge1xuICAgIGlmICghZy5oYXNOb2RlKHYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHcmFwaCBkb2VzIG5vdCBoYXZlIG5vZGU6IFwiICsgdik7XG4gICAgfVxuXG4gICAgZG9EZnMoZywgdiwgb3JkZXIgPT09IFwicG9zdFwiLCB2aXNpdGVkLCBuYXZpZ2F0aW9uLCBhY2MpO1xuICB9KTtcbiAgcmV0dXJuIGFjYztcbn1cblxuZnVuY3Rpb24gZG9EZnMoZywgdiwgcG9zdG9yZGVyLCB2aXNpdGVkLCBuYXZpZ2F0aW9uLCBhY2MpIHtcbiAgaWYgKCFfLmhhcyh2aXNpdGVkLCB2KSkge1xuICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuXG4gICAgaWYgKCFwb3N0b3JkZXIpIHsgYWNjLnB1c2godik7IH1cbiAgICBfLmVhY2gobmF2aWdhdGlvbih2KSwgZnVuY3Rpb24odykge1xuICAgICAgZG9EZnMoZywgdywgcG9zdG9yZGVyLCB2aXNpdGVkLCBuYXZpZ2F0aW9uLCBhY2MpO1xuICAgIH0pO1xuICAgIGlmIChwb3N0b3JkZXIpIHsgYWNjLnB1c2godik7IH1cbiAgfVxufVxuIiwidmFyIGRpamtzdHJhID0gcmVxdWlyZShcIi4vZGlqa3N0cmFcIik7XG52YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZGlqa3N0cmFBbGw7XG5cbmZ1bmN0aW9uIGRpamtzdHJhQWxsKGcsIHdlaWdodEZ1bmMsIGVkZ2VGdW5jKSB7XG4gIHJldHVybiBfLnRyYW5zZm9ybShnLm5vZGVzKCksIGZ1bmN0aW9uKGFjYywgdikge1xuICAgIGFjY1t2XSA9IGRpamtzdHJhKGcsIHYsIHdlaWdodEZ1bmMsIGVkZ2VGdW5jKTtcbiAgfSwge30pO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIFByaW9yaXR5UXVldWUgPSByZXF1aXJlKFwiLi4vZGF0YS9wcmlvcml0eS1xdWV1ZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkaWprc3RyYTtcblxudmFyIERFRkFVTFRfV0VJR0hUX0ZVTkMgPSBfLmNvbnN0YW50KDEpO1xuXG5mdW5jdGlvbiBkaWprc3RyYShnLCBzb3VyY2UsIHdlaWdodEZuLCBlZGdlRm4pIHtcbiAgcmV0dXJuIHJ1bkRpamtzdHJhKGcsIFN0cmluZyhzb3VyY2UpLFxuICAgIHdlaWdodEZuIHx8IERFRkFVTFRfV0VJR0hUX0ZVTkMsXG4gICAgZWRnZUZuIHx8IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGcub3V0RWRnZXModik7IH0pO1xufVxuXG5mdW5jdGlvbiBydW5EaWprc3RyYShnLCBzb3VyY2UsIHdlaWdodEZuLCBlZGdlRm4pIHtcbiAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgdmFyIHBxID0gbmV3IFByaW9yaXR5UXVldWUoKTtcbiAgdmFyIHYsIHZFbnRyeTtcblxuICB2YXIgdXBkYXRlTmVpZ2hib3JzID0gZnVuY3Rpb24oZWRnZSkge1xuICAgIHZhciB3ID0gZWRnZS52ICE9PSB2ID8gZWRnZS52IDogZWRnZS53O1xuICAgIHZhciB3RW50cnkgPSByZXN1bHRzW3ddO1xuICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbihlZGdlKTtcbiAgICB2YXIgZGlzdGFuY2UgPSB2RW50cnkuZGlzdGFuY2UgKyB3ZWlnaHQ7XG5cbiAgICBpZiAod2VpZ2h0IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlqa3N0cmEgZG9lcyBub3QgYWxsb3cgbmVnYXRpdmUgZWRnZSB3ZWlnaHRzLiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgXCJCYWQgZWRnZTogXCIgKyBlZGdlICsgXCIgV2VpZ2h0OiBcIiArIHdlaWdodCk7XG4gICAgfVxuXG4gICAgaWYgKGRpc3RhbmNlIDwgd0VudHJ5LmRpc3RhbmNlKSB7XG4gICAgICB3RW50cnkuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgIHdFbnRyeS5wcmVkZWNlc3NvciA9IHY7XG4gICAgICBwcS5kZWNyZWFzZSh3LCBkaXN0YW5jZSk7XG4gICAgfVxuICB9O1xuXG4gIGcubm9kZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgZGlzdGFuY2UgPSB2ID09PSBzb3VyY2UgPyAwIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHJlc3VsdHNbdl0gPSB7IGRpc3RhbmNlOiBkaXN0YW5jZSB9O1xuICAgIHBxLmFkZCh2LCBkaXN0YW5jZSk7XG4gIH0pO1xuXG4gIHdoaWxlIChwcS5zaXplKCkgPiAwKSB7XG4gICAgdiA9IHBxLnJlbW92ZU1pbigpO1xuICAgIHZFbnRyeSA9IHJlc3VsdHNbdl07XG4gICAgaWYgKHZFbnRyeS5kaXN0YW5jZSA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBlZGdlRm4odikuZm9yRWFjaCh1cGRhdGVOZWlnaGJvcnMpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG52YXIgdGFyamFuID0gcmVxdWlyZShcIi4vdGFyamFuXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRDeWNsZXM7XG5cbmZ1bmN0aW9uIGZpbmRDeWNsZXMoZykge1xuICByZXR1cm4gXy5maWx0ZXIodGFyamFuKGcpLCBmdW5jdGlvbihjbXB0KSB7XG4gICAgcmV0dXJuIGNtcHQubGVuZ3RoID4gMSB8fCAoY21wdC5sZW5ndGggPT09IDEgJiYgZy5oYXNFZGdlKGNtcHRbMF0sIGNtcHRbMF0pKTtcbiAgfSk7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZmxveWRXYXJzaGFsbDtcblxudmFyIERFRkFVTFRfV0VJR0hUX0ZVTkMgPSBfLmNvbnN0YW50KDEpO1xuXG5mdW5jdGlvbiBmbG95ZFdhcnNoYWxsKGcsIHdlaWdodEZuLCBlZGdlRm4pIHtcbiAgcmV0dXJuIHJ1bkZsb3lkV2Fyc2hhbGwoZyxcbiAgICB3ZWlnaHRGbiB8fCBERUZBVUxUX1dFSUdIVF9GVU5DLFxuICAgIGVkZ2VGbiB8fCBmdW5jdGlvbih2KSB7IHJldHVybiBnLm91dEVkZ2VzKHYpOyB9KTtcbn1cblxuZnVuY3Rpb24gcnVuRmxveWRXYXJzaGFsbChnLCB3ZWlnaHRGbiwgZWRnZUZuKSB7XG4gIHZhciByZXN1bHRzID0ge307XG4gIHZhciBub2RlcyA9IGcubm9kZXMoKTtcblxuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICByZXN1bHRzW3ZdID0ge307XG4gICAgcmVzdWx0c1t2XVt2XSA9IHsgZGlzdGFuY2U6IDAgfTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcbiAgICAgIGlmICh2ICE9PSB3KSB7XG4gICAgICAgIHJlc3VsdHNbdl1bd10gPSB7IGRpc3RhbmNlOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlZGdlRm4odikuZm9yRWFjaChmdW5jdGlvbihlZGdlKSB7XG4gICAgICB2YXIgdyA9IGVkZ2UudiA9PT0gdiA/IGVkZ2UudyA6IGVkZ2UudjtcbiAgICAgIHZhciBkID0gd2VpZ2h0Rm4oZWRnZSk7XG4gICAgICByZXN1bHRzW3ZdW3ddID0geyBkaXN0YW5jZTogZCwgcHJlZGVjZXNzb3I6IHYgfTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgdmFyIHJvd0sgPSByZXN1bHRzW2tdO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgdmFyIHJvd0kgPSByZXN1bHRzW2ldO1xuICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihqKSB7XG4gICAgICAgIHZhciBpayA9IHJvd0lba107XG4gICAgICAgIHZhciBraiA9IHJvd0tbal07XG4gICAgICAgIHZhciBpaiA9IHJvd0lbal07XG4gICAgICAgIHZhciBhbHREaXN0YW5jZSA9IGlrLmRpc3RhbmNlICsga2ouZGlzdGFuY2U7XG4gICAgICAgIGlmIChhbHREaXN0YW5jZSA8IGlqLmRpc3RhbmNlKSB7XG4gICAgICAgICAgaWouZGlzdGFuY2UgPSBhbHREaXN0YW5jZTtcbiAgICAgICAgICBpai5wcmVkZWNlc3NvciA9IGtqLnByZWRlY2Vzc29yO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29tcG9uZW50czogcmVxdWlyZShcIi4vY29tcG9uZW50c1wiKSxcbiAgZGlqa3N0cmE6IHJlcXVpcmUoXCIuL2RpamtzdHJhXCIpLFxuICBkaWprc3RyYUFsbDogcmVxdWlyZShcIi4vZGlqa3N0cmEtYWxsXCIpLFxuICBmaW5kQ3ljbGVzOiByZXF1aXJlKFwiLi9maW5kLWN5Y2xlc1wiKSxcbiAgZmxveWRXYXJzaGFsbDogcmVxdWlyZShcIi4vZmxveWQtd2Fyc2hhbGxcIiksXG4gIGlzQWN5Y2xpYzogcmVxdWlyZShcIi4vaXMtYWN5Y2xpY1wiKSxcbiAgcG9zdG9yZGVyOiByZXF1aXJlKFwiLi9wb3N0b3JkZXJcIiksXG4gIHByZW9yZGVyOiByZXF1aXJlKFwiLi9wcmVvcmRlclwiKSxcbiAgcHJpbTogcmVxdWlyZShcIi4vcHJpbVwiKSxcbiAgdGFyamFuOiByZXF1aXJlKFwiLi90YXJqYW5cIiksXG4gIHRvcHNvcnQ6IHJlcXVpcmUoXCIuL3RvcHNvcnRcIilcbn07XG4iLCJ2YXIgdG9wc29ydCA9IHJlcXVpcmUoXCIuL3RvcHNvcnRcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBY3ljbGljO1xuXG5mdW5jdGlvbiBpc0FjeWNsaWMoZykge1xuICB0cnkge1xuICAgIHRvcHNvcnQoZyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIHRvcHNvcnQuQ3ljbGVFeGNlcHRpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbiIsInZhciBkZnMgPSByZXF1aXJlKFwiLi9kZnNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9zdG9yZGVyO1xuXG5mdW5jdGlvbiBwb3N0b3JkZXIoZywgdnMpIHtcbiAgcmV0dXJuIGRmcyhnLCB2cywgXCJwb3N0XCIpO1xufVxuIiwidmFyIGRmcyA9IHJlcXVpcmUoXCIuL2Rmc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwcmVvcmRlcjtcblxuZnVuY3Rpb24gcHJlb3JkZXIoZywgdnMpIHtcbiAgcmV0dXJuIGRmcyhnLCB2cywgXCJwcmVcIik7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG52YXIgR3JhcGggPSByZXF1aXJlKFwiLi4vZ3JhcGhcIik7XG52YXIgUHJpb3JpdHlRdWV1ZSA9IHJlcXVpcmUoXCIuLi9kYXRhL3ByaW9yaXR5LXF1ZXVlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByaW07XG5cbmZ1bmN0aW9uIHByaW0oZywgd2VpZ2h0RnVuYykge1xuICB2YXIgcmVzdWx0ID0gbmV3IEdyYXBoKCk7XG4gIHZhciBwYXJlbnRzID0ge307XG4gIHZhciBwcSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XG4gIHZhciB2O1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZU5laWdoYm9ycyhlZGdlKSB7XG4gICAgdmFyIHcgPSBlZGdlLnYgPT09IHYgPyBlZGdlLncgOiBlZGdlLnY7XG4gICAgdmFyIHByaSA9IHBxLnByaW9yaXR5KHcpO1xuICAgIGlmIChwcmkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGVkZ2VXZWlnaHQgPSB3ZWlnaHRGdW5jKGVkZ2UpO1xuICAgICAgaWYgKGVkZ2VXZWlnaHQgPCBwcmkpIHtcbiAgICAgICAgcGFyZW50c1t3XSA9IHY7XG4gICAgICAgIHBxLmRlY3JlYXNlKHcsIGVkZ2VXZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChnLm5vZGVDb3VudCgpID09PSAwKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIF8uZWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICBwcS5hZGQodiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICByZXN1bHQuc2V0Tm9kZSh2KTtcbiAgfSk7XG5cbiAgLy8gU3RhcnQgZnJvbSBhbiBhcmJpdHJhcnkgbm9kZVxuICBwcS5kZWNyZWFzZShnLm5vZGVzKClbMF0sIDApO1xuXG4gIHZhciBpbml0ID0gZmFsc2U7XG4gIHdoaWxlIChwcS5zaXplKCkgPiAwKSB7XG4gICAgdiA9IHBxLnJlbW92ZU1pbigpO1xuICAgIGlmIChfLmhhcyhwYXJlbnRzLCB2KSkge1xuICAgICAgcmVzdWx0LnNldEVkZ2UodiwgcGFyZW50c1t2XSk7XG4gICAgfSBlbHNlIGlmIChpbml0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBncmFwaCBpcyBub3QgY29ubmVjdGVkOiBcIiArIGcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbml0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBnLm5vZGVFZGdlcyh2KS5mb3JFYWNoKHVwZGF0ZU5laWdoYm9ycyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRhcmphbjtcblxuZnVuY3Rpb24gdGFyamFuKGcpIHtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciB2aXNpdGVkID0ge307IC8vIG5vZGUgaWQgLT4geyBvblN0YWNrLCBsb3dsaW5rLCBpbmRleCB9XG4gIHZhciByZXN1bHRzID0gW107XG5cbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICB2YXIgZW50cnkgPSB2aXNpdGVkW3ZdID0ge1xuICAgICAgb25TdGFjazogdHJ1ZSxcbiAgICAgIGxvd2xpbms6IGluZGV4LFxuICAgICAgaW5kZXg6IGluZGV4KytcbiAgICB9O1xuICAgIHN0YWNrLnB1c2godik7XG5cbiAgICBnLnN1Y2Nlc3NvcnModikuZm9yRWFjaChmdW5jdGlvbih3KSB7XG4gICAgICBpZiAoIV8uaGFzKHZpc2l0ZWQsIHcpKSB7XG4gICAgICAgIGRmcyh3KTtcbiAgICAgICAgZW50cnkubG93bGluayA9IE1hdGgubWluKGVudHJ5Lmxvd2xpbmssIHZpc2l0ZWRbd10ubG93bGluayk7XG4gICAgICB9IGVsc2UgaWYgKHZpc2l0ZWRbd10ub25TdGFjaykge1xuICAgICAgICBlbnRyeS5sb3dsaW5rID0gTWF0aC5taW4oZW50cnkubG93bGluaywgdmlzaXRlZFt3XS5pbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoZW50cnkubG93bGluayA9PT0gZW50cnkuaW5kZXgpIHtcbiAgICAgIHZhciBjbXB0ID0gW107XG4gICAgICB2YXIgdztcbiAgICAgIGRvIHtcbiAgICAgICAgdyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2aXNpdGVkW3ddLm9uU3RhY2sgPSBmYWxzZTtcbiAgICAgICAgY21wdC5wdXNoKHcpO1xuICAgICAgfSB3aGlsZSAodiAhPT0gdyk7XG4gICAgICByZXN1bHRzLnB1c2goY21wdCk7XG4gICAgfVxuICB9XG5cbiAgZy5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgIGlmICghXy5oYXModmlzaXRlZCwgdikpIHtcbiAgICAgIGRmcyh2KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHRzO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRvcHNvcnQ7XG50b3Bzb3J0LkN5Y2xlRXhjZXB0aW9uID0gQ3ljbGVFeGNlcHRpb247XG5cbmZ1bmN0aW9uIHRvcHNvcnQoZykge1xuICB2YXIgdmlzaXRlZCA9IHt9O1xuICB2YXIgc3RhY2sgPSB7fTtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICBmdW5jdGlvbiB2aXNpdChub2RlKSB7XG4gICAgaWYgKF8uaGFzKHN0YWNrLCBub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEN5Y2xlRXhjZXB0aW9uKCk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmhhcyh2aXNpdGVkLCBub2RlKSkge1xuICAgICAgc3RhY2tbbm9kZV0gPSB0cnVlO1xuICAgICAgdmlzaXRlZFtub2RlXSA9IHRydWU7XG4gICAgICBfLmVhY2goZy5wcmVkZWNlc3NvcnMobm9kZSksIHZpc2l0KTtcbiAgICAgIGRlbGV0ZSBzdGFja1tub2RlXTtcbiAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcbiAgICB9XG4gIH1cblxuICBfLmVhY2goZy5zaW5rcygpLCB2aXNpdCk7XG5cbiAgaWYgKF8uc2l6ZSh2aXNpdGVkKSAhPT0gZy5ub2RlQ291bnQoKSkge1xuICAgIHRocm93IG5ldyBDeWNsZUV4Y2VwdGlvbigpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIEN5Y2xlRXhjZXB0aW9uKCkge31cbkN5Y2xlRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpOyAvLyBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEVycm9yIHRvIHBhc3MgdGVzdGluZyIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcmlvcml0eVF1ZXVlO1xuXG4vKipcbiAqIEEgbWluLXByaW9yaXR5IHF1ZXVlIGRhdGEgc3RydWN0dXJlLiBUaGlzIGFsZ29yaXRobSBpcyBkZXJpdmVkIGZyb20gQ29ybWVuLFxuICogZXQgYWwuLCBcIkludHJvZHVjdGlvbiB0byBBbGdvcml0aG1zXCIuIFRoZSBiYXNpYyBpZGVhIG9mIGEgbWluLXByaW9yaXR5XG4gKiBxdWV1ZSBpcyB0aGF0IHlvdSBjYW4gZWZmaWNpZW50bHkgKGluIE8oMSkgdGltZSkgZ2V0IHRoZSBzbWFsbGVzdCBrZXkgaW5cbiAqIHRoZSBxdWV1ZS4gQWRkaW5nIGFuZCByZW1vdmluZyBlbGVtZW50cyB0YWtlcyBPKGxvZyBuKSB0aW1lLiBBIGtleSBjYW5cbiAqIGhhdmUgaXRzIHByaW9yaXR5IGRlY3JlYXNlZCBpbiBPKGxvZyBuKSB0aW1lLlxuICovXG5mdW5jdGlvbiBQcmlvcml0eVF1ZXVlKCkge1xuICB0aGlzLl9hcnIgPSBbXTtcbiAgdGhpcy5fa2V5SW5kaWNlcyA9IHt9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgcXVldWUuIFRha2VzIGBPKDEpYCB0aW1lLlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9hcnIubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZXlzIHRoYXQgYXJlIGluIHRoZSBxdWV1ZS4gVGFrZXMgYE8obilgIHRpbWUuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Fyci5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4geC5rZXk7IH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiAqKmtleSoqIGlzIGluIHRoZSBxdWV1ZSBhbmQgYGZhbHNlYCBpZiBub3QuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuICByZXR1cm4gXy5oYXModGhpcy5fa2V5SW5kaWNlcywga2V5KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcHJpb3JpdHkgZm9yICoqa2V5KiouIElmICoqa2V5KiogaXMgbm90IHByZXNlbnQgaW4gdGhlIHF1ZXVlXG4gKiB0aGVuIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgdW5kZWZpbmVkYC4gVGFrZXMgYE8oMSlgIHRpbWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGtleVxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5wcmlvcml0eSA9IGZ1bmN0aW9uKGtleSkge1xuICB2YXIgaW5kZXggPSB0aGlzLl9rZXlJbmRpY2VzW2tleV07XG4gIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycltpbmRleF0ucHJpb3JpdHk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUga2V5IGZvciB0aGUgbWluaW11bSBlbGVtZW50IGluIHRoaXMgcXVldWUuIElmIHRoZSBxdWV1ZSBpc1xuICogZW1wdHkgdGhpcyBmdW5jdGlvbiB0aHJvd3MgYW4gRXJyb3IuIFRha2VzIGBPKDEpYCB0aW1lLlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc2l6ZSgpID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUXVldWUgdW5kZXJmbG93XCIpO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJbMF0ua2V5O1xufTtcblxuLyoqXG4gKiBJbnNlcnRzIGEgbmV3IGtleSBpbnRvIHRoZSBwcmlvcml0eSBxdWV1ZS4gSWYgdGhlIGtleSBhbHJlYWR5IGV4aXN0cyBpblxuICogdGhlIHF1ZXVlIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgOyBvdGhlcndpc2UgaXQgd2lsbCByZXR1cm4gYHRydWVgLlxuICogVGFrZXMgYE8obilgIHRpbWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGtleSB0aGUga2V5IHRvIGFkZFxuICogQHBhcmFtIHtOdW1iZXJ9IHByaW9yaXR5IHRoZSBpbml0aWFsIHByaW9yaXR5IGZvciB0aGUga2V5XG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGtleSwgcHJpb3JpdHkpIHtcbiAgdmFyIGtleUluZGljZXMgPSB0aGlzLl9rZXlJbmRpY2VzO1xuICBrZXkgPSBTdHJpbmcoa2V5KTtcbiAgaWYgKCFfLmhhcyhrZXlJbmRpY2VzLCBrZXkpKSB7XG4gICAgdmFyIGFyciA9IHRoaXMuX2FycjtcbiAgICB2YXIgaW5kZXggPSBhcnIubGVuZ3RoO1xuICAgIGtleUluZGljZXNba2V5XSA9IGluZGV4O1xuICAgIGFyci5wdXNoKHtrZXk6IGtleSwgcHJpb3JpdHk6IHByaW9yaXR5fSk7XG4gICAgdGhpcy5fZGVjcmVhc2UoaW5kZXgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbmQgcmV0dXJucyB0aGUgc21hbGxlc3Qga2V5IGluIHRoZSBxdWV1ZS4gVGFrZXMgYE8obG9nIG4pYCB0aW1lLlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5yZW1vdmVNaW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc3dhcCgwLCB0aGlzLl9hcnIubGVuZ3RoIC0gMSk7XG4gIHZhciBtaW4gPSB0aGlzLl9hcnIucG9wKCk7XG4gIGRlbGV0ZSB0aGlzLl9rZXlJbmRpY2VzW21pbi5rZXldO1xuICB0aGlzLl9oZWFwaWZ5KDApO1xuICByZXR1cm4gbWluLmtleTtcbn07XG5cbi8qKlxuICogRGVjcmVhc2VzIHRoZSBwcmlvcml0eSBmb3IgKiprZXkqKiB0byAqKnByaW9yaXR5KiouIElmIHRoZSBuZXcgcHJpb3JpdHkgaXNcbiAqIGdyZWF0ZXIgdGhhbiB0aGUgcHJldmlvdXMgcHJpb3JpdHksIHRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvdyBhbiBFcnJvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0ga2V5IHRoZSBrZXkgZm9yIHdoaWNoIHRvIHJhaXNlIHByaW9yaXR5XG4gKiBAcGFyYW0ge051bWJlcn0gcHJpb3JpdHkgdGhlIG5ldyBwcmlvcml0eSBmb3IgdGhlIGtleVxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5kZWNyZWFzZSA9IGZ1bmN0aW9uKGtleSwgcHJpb3JpdHkpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fa2V5SW5kaWNlc1trZXldO1xuICBpZiAocHJpb3JpdHkgPiB0aGlzLl9hcnJbaW5kZXhdLnByaW9yaXR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTmV3IHByaW9yaXR5IGlzIGdyZWF0ZXIgdGhhbiBjdXJyZW50IHByaW9yaXR5LiBcIiArXG4gICAgICAgIFwiS2V5OiBcIiArIGtleSArIFwiIE9sZDogXCIgKyB0aGlzLl9hcnJbaW5kZXhdLnByaW9yaXR5ICsgXCIgTmV3OiBcIiArIHByaW9yaXR5KTtcbiAgfVxuICB0aGlzLl9hcnJbaW5kZXhdLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gIHRoaXMuX2RlY3JlYXNlKGluZGV4KTtcbn07XG5cblByaW9yaXR5UXVldWUucHJvdG90eXBlLl9oZWFwaWZ5ID0gZnVuY3Rpb24oaSkge1xuICB2YXIgYXJyID0gdGhpcy5fYXJyO1xuICB2YXIgbCA9IDIgKiBpO1xuICB2YXIgciA9IGwgKyAxO1xuICB2YXIgbGFyZ2VzdCA9IGk7XG4gIGlmIChsIDwgYXJyLmxlbmd0aCkge1xuICAgIGxhcmdlc3QgPSBhcnJbbF0ucHJpb3JpdHkgPCBhcnJbbGFyZ2VzdF0ucHJpb3JpdHkgPyBsIDogbGFyZ2VzdDtcbiAgICBpZiAociA8IGFyci5sZW5ndGgpIHtcbiAgICAgIGxhcmdlc3QgPSBhcnJbcl0ucHJpb3JpdHkgPCBhcnJbbGFyZ2VzdF0ucHJpb3JpdHkgPyByIDogbGFyZ2VzdDtcbiAgICB9XG4gICAgaWYgKGxhcmdlc3QgIT09IGkpIHtcbiAgICAgIHRoaXMuX3N3YXAoaSwgbGFyZ2VzdCk7XG4gICAgICB0aGlzLl9oZWFwaWZ5KGxhcmdlc3QpO1xuICAgIH1cbiAgfVxufTtcblxuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuX2RlY3JlYXNlID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgdmFyIGFyciA9IHRoaXMuX2FycjtcbiAgdmFyIHByaW9yaXR5ID0gYXJyW2luZGV4XS5wcmlvcml0eTtcbiAgdmFyIHBhcmVudDtcbiAgd2hpbGUgKGluZGV4ICE9PSAwKSB7XG4gICAgcGFyZW50ID0gaW5kZXggPj4gMTtcbiAgICBpZiAoYXJyW3BhcmVudF0ucHJpb3JpdHkgPCBwcmlvcml0eSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3N3YXAoaW5kZXgsIHBhcmVudCk7XG4gICAgaW5kZXggPSBwYXJlbnQ7XG4gIH1cbn07XG5cblByaW9yaXR5UXVldWUucHJvdG90eXBlLl9zd2FwID0gZnVuY3Rpb24oaSwgaikge1xuICB2YXIgYXJyID0gdGhpcy5fYXJyO1xuICB2YXIga2V5SW5kaWNlcyA9IHRoaXMuX2tleUluZGljZXM7XG4gIHZhciBvcmlnQXJySSA9IGFycltpXTtcbiAgdmFyIG9yaWdBcnJKID0gYXJyW2pdO1xuICBhcnJbaV0gPSBvcmlnQXJySjtcbiAgYXJyW2pdID0gb3JpZ0Fyckk7XG4gIGtleUluZGljZXNbb3JpZ0Fyckoua2V5XSA9IGk7XG4gIGtleUluZGljZXNbb3JpZ0Fyckkua2V5XSA9IGo7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYXBoO1xuXG52YXIgREVGQVVMVF9FREdFX05BTUUgPSBcIlxceDAwXCI7XG52YXIgR1JBUEhfTk9ERSA9IFwiXFx4MDBcIjtcbnZhciBFREdFX0tFWV9ERUxJTSA9IFwiXFx4MDFcIjtcblxuLy8gSW1wbGVtZW50YXRpb24gbm90ZXM6XG4vL1xuLy8gICogTm9kZSBpZCBxdWVyeSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBzdHJpbmcgaWRzIGZvciB0aGUgbm9kZXNcbi8vICAqIEVkZ2UgaWQgcXVlcnkgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gXCJlZGdlT2JqXCIsIGVkZ2Ugb2JqZWN0LCB0aGF0IGlzXG4vLyAgICBjb21wb3NlZCBvZiBlbm91Z2ggaW5mb3JtYXRpb24gdG8gdW5pcXVlbHkgaWRlbnRpZnkgYW4gZWRnZToge3YsIHcsIG5hbWV9LlxuLy8gICogSW50ZXJuYWxseSB3ZSB1c2UgYW4gXCJlZGdlSWRcIiwgYSBzdHJpbmdpZmllZCBmb3JtIG9mIHRoZSBlZGdlT2JqLCB0b1xuLy8gICAgcmVmZXJlbmNlIGVkZ2VzLiBUaGlzIGlzIGJlY2F1c2Ugd2UgbmVlZCBhIHBlcmZvcm1hbnQgd2F5IHRvIGxvb2sgdGhlc2Vcbi8vICAgIGVkZ2VzIHVwIGFuZCwgb2JqZWN0IHByb3BlcnRpZXMsIHdoaWNoIGhhdmUgc3RyaW5nIGtleXMsIGFyZSB0aGUgY2xvc2VzdFxuLy8gICAgd2UncmUgZ29pbmcgdG8gZ2V0IHRvIGEgcGVyZm9ybWFudCBoYXNodGFibGUgaW4gSmF2YVNjcmlwdC5cblxuZnVuY3Rpb24gR3JhcGgob3B0cykge1xuICB0aGlzLl9pc0RpcmVjdGVkID0gXy5oYXMob3B0cywgXCJkaXJlY3RlZFwiKSA/IG9wdHMuZGlyZWN0ZWQgOiB0cnVlO1xuICB0aGlzLl9pc011bHRpZ3JhcGggPSBfLmhhcyhvcHRzLCBcIm11bHRpZ3JhcGhcIikgPyBvcHRzLm11bHRpZ3JhcGggOiBmYWxzZTtcbiAgdGhpcy5faXNDb21wb3VuZCA9IF8uaGFzKG9wdHMsIFwiY29tcG91bmRcIikgPyBvcHRzLmNvbXBvdW5kIDogZmFsc2U7XG5cbiAgLy8gTGFiZWwgZm9yIHRoZSBncmFwaCBpdHNlbGZcbiAgdGhpcy5fbGFiZWwgPSB1bmRlZmluZWQ7XG5cbiAgLy8gRGVmYXVsdHMgdG8gYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgbm9kZVxuICB0aGlzLl9kZWZhdWx0Tm9kZUxhYmVsRm4gPSBfLmNvbnN0YW50KHVuZGVmaW5lZCk7XG5cbiAgLy8gRGVmYXVsdHMgdG8gYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgZWRnZVxuICB0aGlzLl9kZWZhdWx0RWRnZUxhYmVsRm4gPSBfLmNvbnN0YW50KHVuZGVmaW5lZCk7XG5cbiAgLy8gdiAtPiBsYWJlbFxuICB0aGlzLl9ub2RlcyA9IHt9O1xuXG4gIGlmICh0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgLy8gdiAtPiBwYXJlbnRcbiAgICB0aGlzLl9wYXJlbnQgPSB7fTtcblxuICAgIC8vIHYgLT4gY2hpbGRyZW5cbiAgICB0aGlzLl9jaGlsZHJlbiA9IHt9O1xuICAgIHRoaXMuX2NoaWxkcmVuW0dSQVBIX05PREVdID0ge307XG4gIH1cblxuICAvLyB2IC0+IGVkZ2VPYmpcbiAgdGhpcy5faW4gPSB7fTtcblxuICAvLyB1IC0+IHYgLT4gTnVtYmVyXG4gIHRoaXMuX3ByZWRzID0ge307XG5cbiAgLy8gdiAtPiBlZGdlT2JqXG4gIHRoaXMuX291dCA9IHt9O1xuXG4gIC8vIHYgLT4gdyAtPiBOdW1iZXJcbiAgdGhpcy5fc3VjcyA9IHt9O1xuXG4gIC8vIGUgLT4gZWRnZU9ialxuICB0aGlzLl9lZGdlT2JqcyA9IHt9O1xuXG4gIC8vIGUgLT4gbGFiZWxcbiAgdGhpcy5fZWRnZUxhYmVscyA9IHt9O1xufVxuXG4vKiBOdW1iZXIgb2Ygbm9kZXMgaW4gdGhlIGdyYXBoLiBTaG91bGQgb25seSBiZSBjaGFuZ2VkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbi4gKi9cbkdyYXBoLnByb3RvdHlwZS5fbm9kZUNvdW50ID0gMDtcblxuLyogTnVtYmVyIG9mIGVkZ2VzIGluIHRoZSBncmFwaC4gU2hvdWxkIG9ubHkgYmUgY2hhbmdlZCBieSB0aGUgaW1wbGVtZW50YXRpb24uICovXG5HcmFwaC5wcm90b3R5cGUuX2VkZ2VDb3VudCA9IDA7XG5cblxuLyogPT09IEdyYXBoIGZ1bmN0aW9ucyA9PT09PT09PT0gKi9cblxuR3JhcGgucHJvdG90eXBlLmlzRGlyZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2lzRGlyZWN0ZWQ7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaXNNdWx0aWdyYXBoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pc011bHRpZ3JhcGg7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaXNDb21wb3VuZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faXNDb21wb3VuZDtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zZXRHcmFwaCA9IGZ1bmN0aW9uKGxhYmVsKSB7XG4gIHRoaXMuX2xhYmVsID0gbGFiZWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmdyYXBoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9sYWJlbDtcbn07XG5cblxuLyogPT09IE5vZGUgZnVuY3Rpb25zID09PT09PT09PT0gKi9cblxuR3JhcGgucHJvdG90eXBlLnNldERlZmF1bHROb2RlTGFiZWwgPSBmdW5jdGlvbihuZXdEZWZhdWx0KSB7XG4gIGlmICghXy5pc0Z1bmN0aW9uKG5ld0RlZmF1bHQpKSB7XG4gICAgbmV3RGVmYXVsdCA9IF8uY29uc3RhbnQobmV3RGVmYXVsdCk7XG4gIH1cbiAgdGhpcy5fZGVmYXVsdE5vZGVMYWJlbEZuID0gbmV3RGVmYXVsdDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUubm9kZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9ub2RlQ291bnQ7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUubm9kZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF8ua2V5cyh0aGlzLl9ub2Rlcyk7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc291cmNlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBfLmZpbHRlcih0aGlzLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gXy5pc0VtcHR5KHNlbGYuX2luW3ZdKTtcbiAgfSk7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc2lua3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gXy5maWx0ZXIodGhpcy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIF8uaXNFbXB0eShzZWxmLl9vdXRbdl0pO1xuICB9KTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zZXROb2RlcyA9IGZ1bmN0aW9uKHZzLCB2YWx1ZSkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBfLmVhY2godnMsIGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICBzZWxmLnNldE5vZGUodiwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnNldE5vZGUodik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0Tm9kZSA9IGZ1bmN0aW9uKHYsIHZhbHVlKSB7XG4gIGlmIChfLmhhcyh0aGlzLl9ub2RlcywgdikpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuX25vZGVzW3ZdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5fbm9kZXNbdl0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHZhbHVlIDogdGhpcy5fZGVmYXVsdE5vZGVMYWJlbEZuKHYpO1xuICBpZiAodGhpcy5faXNDb21wb3VuZCkge1xuICAgIHRoaXMuX3BhcmVudFt2XSA9IEdSQVBIX05PREU7XG4gICAgdGhpcy5fY2hpbGRyZW5bdl0gPSB7fTtcbiAgICB0aGlzLl9jaGlsZHJlbltHUkFQSF9OT0RFXVt2XSA9IHRydWU7XG4gIH1cbiAgdGhpcy5faW5bdl0gPSB7fTtcbiAgdGhpcy5fcHJlZHNbdl0gPSB7fTtcbiAgdGhpcy5fb3V0W3ZdID0ge307XG4gIHRoaXMuX3N1Y3Nbdl0gPSB7fTtcbiAgKyt0aGlzLl9ub2RlQ291bnQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiB0aGlzLl9ub2Rlc1t2XTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5oYXNOb2RlID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gXy5oYXModGhpcy5fbm9kZXMsIHYpO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnJlbW92ZU5vZGUgPSAgZnVuY3Rpb24odikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChfLmhhcyh0aGlzLl9ub2RlcywgdikpIHtcbiAgICB2YXIgcmVtb3ZlRWRnZSA9IGZ1bmN0aW9uKGUpIHsgc2VsZi5yZW1vdmVFZGdlKHNlbGYuX2VkZ2VPYmpzW2VdKTsgfTtcbiAgICBkZWxldGUgdGhpcy5fbm9kZXNbdl07XG4gICAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUZyb21QYXJlbnRzQ2hpbGRMaXN0KHYpO1xuICAgICAgZGVsZXRlIHRoaXMuX3BhcmVudFt2XTtcbiAgICAgIF8uZWFjaCh0aGlzLmNoaWxkcmVuKHYpLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICBzZWxmLnNldFBhcmVudChjaGlsZCk7XG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9jaGlsZHJlblt2XTtcbiAgICB9XG4gICAgXy5lYWNoKF8ua2V5cyh0aGlzLl9pblt2XSksIHJlbW92ZUVkZ2UpO1xuICAgIGRlbGV0ZSB0aGlzLl9pblt2XTtcbiAgICBkZWxldGUgdGhpcy5fcHJlZHNbdl07XG4gICAgXy5lYWNoKF8ua2V5cyh0aGlzLl9vdXRbdl0pLCByZW1vdmVFZGdlKTtcbiAgICBkZWxldGUgdGhpcy5fb3V0W3ZdO1xuICAgIGRlbGV0ZSB0aGlzLl9zdWNzW3ZdO1xuICAgIC0tdGhpcy5fbm9kZUNvdW50O1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uKHYsIHBhcmVudCkge1xuICBpZiAoIXRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHBhcmVudCBpbiBhIG5vbi1jb21wb3VuZCBncmFwaFwiKTtcbiAgfVxuXG4gIGlmIChfLmlzVW5kZWZpbmVkKHBhcmVudCkpIHtcbiAgICBwYXJlbnQgPSBHUkFQSF9OT0RFO1xuICB9IGVsc2Uge1xuICAgIC8vIENvZXJjZSBwYXJlbnQgdG8gc3RyaW5nXG4gICAgcGFyZW50ICs9IFwiXCI7XG4gICAgZm9yICh2YXIgYW5jZXN0b3IgPSBwYXJlbnQ7XG4gICAgICAhXy5pc1VuZGVmaW5lZChhbmNlc3Rvcik7XG4gICAgICBhbmNlc3RvciA9IHRoaXMucGFyZW50KGFuY2VzdG9yKSkge1xuICAgICAgaWYgKGFuY2VzdG9yID09PSB2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNldHRpbmcgXCIgKyBwYXJlbnQrIFwiIGFzIHBhcmVudCBvZiBcIiArIHYgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgd291bGQgY3JlYXRlIGEgY3ljbGVcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXROb2RlKHBhcmVudCk7XG4gIH1cblxuICB0aGlzLnNldE5vZGUodik7XG4gIHRoaXMuX3JlbW92ZUZyb21QYXJlbnRzQ2hpbGRMaXN0KHYpO1xuICB0aGlzLl9wYXJlbnRbdl0gPSBwYXJlbnQ7XG4gIHRoaXMuX2NoaWxkcmVuW3BhcmVudF1bdl0gPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5fcmVtb3ZlRnJvbVBhcmVudHNDaGlsZExpc3QgPSBmdW5jdGlvbih2KSB7XG4gIGRlbGV0ZSB0aGlzLl9jaGlsZHJlblt0aGlzLl9wYXJlbnRbdl1dW3ZdO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uKHYpIHtcbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50W3ZdO1xuICAgIGlmIChwYXJlbnQgIT09IEdSQVBIX05PREUpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbih2KSB7XG4gIGlmIChfLmlzVW5kZWZpbmVkKHYpKSB7XG4gICAgdiA9IEdSQVBIX05PREU7XG4gIH1cblxuICBpZiAodGhpcy5faXNDb21wb3VuZCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuW3ZdO1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgcmV0dXJuIF8ua2V5cyhjaGlsZHJlbik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHYgPT09IEdSQVBIX05PREUpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlcygpO1xuICB9IGVsc2UgaWYgKHRoaXMuaGFzTm9kZSh2KSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLnByZWRlY2Vzc29ycyA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHByZWRzViA9IHRoaXMuX3ByZWRzW3ZdO1xuICBpZiAocHJlZHNWKSB7XG4gICAgcmV0dXJuIF8ua2V5cyhwcmVkc1YpO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc3VjY2Vzc29ycyA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHN1Y3NWID0gdGhpcy5fc3Vjc1t2XTtcbiAgaWYgKHN1Y3NWKSB7XG4gICAgcmV0dXJuIF8ua2V5cyhzdWNzVik7XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5uZWlnaGJvcnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBwcmVkcyA9IHRoaXMucHJlZGVjZXNzb3JzKHYpO1xuICBpZiAocHJlZHMpIHtcbiAgICByZXR1cm4gXy51bmlvbihwcmVkcywgdGhpcy5zdWNjZXNzb3JzKHYpKTtcbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLmlzTGVhZiA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBuZWlnaGJvcnM7XG4gIGlmICh0aGlzLmlzRGlyZWN0ZWQoKSkge1xuICAgIG5laWdoYm9ycyA9IHRoaXMuc3VjY2Vzc29ycyh2KTtcbiAgfSBlbHNlIHtcbiAgICBuZWlnaGJvcnMgPSB0aGlzLm5laWdoYm9ycyh2KTtcbiAgfVxuICByZXR1cm4gbmVpZ2hib3JzLmxlbmd0aCA9PT0gMDtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5maWx0ZXJOb2RlcyA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICB2YXIgY29weSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHtcbiAgICBkaXJlY3RlZDogdGhpcy5faXNEaXJlY3RlZCxcbiAgICBtdWx0aWdyYXBoOiB0aGlzLl9pc011bHRpZ3JhcGgsXG4gICAgY29tcG91bmQ6IHRoaXMuX2lzQ29tcG91bmRcbiAgfSk7XG5cbiAgY29weS5zZXRHcmFwaCh0aGlzLmdyYXBoKCkpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgXy5lYWNoKHRoaXMuX25vZGVzLCBmdW5jdGlvbih2YWx1ZSwgdikge1xuICAgIGlmIChmaWx0ZXIodikpIHtcbiAgICAgIGNvcHkuc2V0Tm9kZSh2LCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcblxuICBfLmVhY2godGhpcy5fZWRnZU9ianMsIGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoY29weS5oYXNOb2RlKGUudikgJiYgY29weS5oYXNOb2RlKGUudykpIHtcbiAgICAgIGNvcHkuc2V0RWRnZShlLCBzZWxmLmVkZ2UoZSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHBhcmVudHMgPSB7fTtcbiAgZnVuY3Rpb24gZmluZFBhcmVudCh2KSB7XG4gICAgdmFyIHBhcmVudCA9IHNlbGYucGFyZW50KHYpO1xuICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCB8fCBjb3B5Lmhhc05vZGUocGFyZW50KSkge1xuICAgICAgcGFyZW50c1t2XSA9IHBhcmVudDtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfSBlbHNlIGlmIChwYXJlbnQgaW4gcGFyZW50cykge1xuICAgICAgcmV0dXJuIHBhcmVudHNbcGFyZW50XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZpbmRQYXJlbnQocGFyZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5faXNDb21wb3VuZCkge1xuICAgIF8uZWFjaChjb3B5Lm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICAgIGNvcHkuc2V0UGFyZW50KHYsIGZpbmRQYXJlbnQodikpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59O1xuXG4vKiA9PT0gRWRnZSBmdW5jdGlvbnMgPT09PT09PT09PSAqL1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0RGVmYXVsdEVkZ2VMYWJlbCA9IGZ1bmN0aW9uKG5ld0RlZmF1bHQpIHtcbiAgaWYgKCFfLmlzRnVuY3Rpb24obmV3RGVmYXVsdCkpIHtcbiAgICBuZXdEZWZhdWx0ID0gXy5jb25zdGFudChuZXdEZWZhdWx0KTtcbiAgfVxuICB0aGlzLl9kZWZhdWx0RWRnZUxhYmVsRm4gPSBuZXdEZWZhdWx0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5lZGdlQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2VkZ2VDb3VudDtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5lZGdlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXy52YWx1ZXModGhpcy5fZWRnZU9ianMpO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNldFBhdGggPSBmdW5jdGlvbih2cywgdmFsdWUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgXy5yZWR1Y2UodnMsIGZ1bmN0aW9uKHYsIHcpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICBzZWxmLnNldEVkZ2UodiwgdywgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnNldEVkZ2Uodiwgdyk7XG4gICAgfVxuICAgIHJldHVybiB3O1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKlxuICogc2V0RWRnZSh2LCB3LCBbdmFsdWUsIFtuYW1lXV0pXG4gKiBzZXRFZGdlKHsgdiwgdywgW25hbWVdIH0sIFt2YWx1ZV0pXG4gKi9cbkdyYXBoLnByb3RvdHlwZS5zZXRFZGdlID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2LCB3LCBuYW1lLCB2YWx1ZTtcbiAgdmFyIHZhbHVlU3BlY2lmaWVkID0gZmFsc2U7XG4gIHZhciBhcmcwID0gYXJndW1lbnRzWzBdO1xuXG4gIGlmICh0eXBlb2YgYXJnMCA9PT0gXCJvYmplY3RcIiAmJiBhcmcwICE9PSBudWxsICYmIFwidlwiIGluIGFyZzApIHtcbiAgICB2ID0gYXJnMC52O1xuICAgIHcgPSBhcmcwLnc7XG4gICAgbmFtZSA9IGFyZzAubmFtZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YWx1ZVNwZWNpZmllZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHYgPSBhcmcwO1xuICAgIHcgPSBhcmd1bWVudHNbMV07XG4gICAgbmFtZSA9IGFyZ3VtZW50c1szXTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIHZhbHVlID0gYXJndW1lbnRzWzJdO1xuICAgICAgdmFsdWVTcGVjaWZpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHYgPSBcIlwiICsgdjtcbiAgdyA9IFwiXCIgKyB3O1xuICBpZiAoIV8uaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBuYW1lID0gXCJcIiArIG5hbWU7XG4gIH1cblxuICB2YXIgZSA9IGVkZ2VBcmdzVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCB2LCB3LCBuYW1lKTtcbiAgaWYgKF8uaGFzKHRoaXMuX2VkZ2VMYWJlbHMsIGUpKSB7XG4gICAgaWYgKHZhbHVlU3BlY2lmaWVkKSB7XG4gICAgICB0aGlzLl9lZGdlTGFiZWxzW2VdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKG5hbWUpICYmICF0aGlzLl9pc011bHRpZ3JhcGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IGEgbmFtZWQgZWRnZSB3aGVuIGlzTXVsdGlncmFwaCA9IGZhbHNlXCIpO1xuICB9XG5cbiAgLy8gSXQgZGlkbid0IGV4aXN0LCBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBpdC5cbiAgLy8gRmlyc3QgZW5zdXJlIHRoZSBub2RlcyBleGlzdC5cbiAgdGhpcy5zZXROb2RlKHYpO1xuICB0aGlzLnNldE5vZGUodyk7XG5cbiAgdGhpcy5fZWRnZUxhYmVsc1tlXSA9IHZhbHVlU3BlY2lmaWVkID8gdmFsdWUgOiB0aGlzLl9kZWZhdWx0RWRnZUxhYmVsRm4odiwgdywgbmFtZSk7XG5cbiAgdmFyIGVkZ2VPYmogPSBlZGdlQXJnc1RvT2JqKHRoaXMuX2lzRGlyZWN0ZWQsIHYsIHcsIG5hbWUpO1xuICAvLyBFbnN1cmUgd2UgYWRkIHVuZGlyZWN0ZWQgZWRnZXMgaW4gYSBjb25zaXN0ZW50IHdheS5cbiAgdiA9IGVkZ2VPYmoudjtcbiAgdyA9IGVkZ2VPYmoudztcblxuICBPYmplY3QuZnJlZXplKGVkZ2VPYmopO1xuICB0aGlzLl9lZGdlT2Jqc1tlXSA9IGVkZ2VPYmo7XG4gIGluY3JlbWVudE9ySW5pdEVudHJ5KHRoaXMuX3ByZWRzW3ddLCB2KTtcbiAgaW5jcmVtZW50T3JJbml0RW50cnkodGhpcy5fc3Vjc1t2XSwgdyk7XG4gIHRoaXMuX2luW3ddW2VdID0gZWRnZU9iajtcbiAgdGhpcy5fb3V0W3ZdW2VdID0gZWRnZU9iajtcbiAgdGhpcy5fZWRnZUNvdW50Kys7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmVkZ2UgPSBmdW5jdGlvbih2LCB3LCBuYW1lKSB7XG4gIHZhciBlID0gKGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICA/IGVkZ2VPYmpUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIGFyZ3VtZW50c1swXSlcbiAgICA6IGVkZ2VBcmdzVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCB2LCB3LCBuYW1lKSk7XG4gIHJldHVybiB0aGlzLl9lZGdlTGFiZWxzW2VdO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmhhc0VkZ2UgPSBmdW5jdGlvbih2LCB3LCBuYW1lKSB7XG4gIHZhciBlID0gKGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICA/IGVkZ2VPYmpUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIGFyZ3VtZW50c1swXSlcbiAgICA6IGVkZ2VBcmdzVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCB2LCB3LCBuYW1lKSk7XG4gIHJldHVybiBfLmhhcyh0aGlzLl9lZGdlTGFiZWxzLCBlKTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5yZW1vdmVFZGdlID0gZnVuY3Rpb24odiwgdywgbmFtZSkge1xuICB2YXIgZSA9IChhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgPyBlZGdlT2JqVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCBhcmd1bWVudHNbMF0pXG4gICAgOiBlZGdlQXJnc1RvSWQodGhpcy5faXNEaXJlY3RlZCwgdiwgdywgbmFtZSkpO1xuICB2YXIgZWRnZSA9IHRoaXMuX2VkZ2VPYmpzW2VdO1xuICBpZiAoZWRnZSkge1xuICAgIHYgPSBlZGdlLnY7XG4gICAgdyA9IGVkZ2UudztcbiAgICBkZWxldGUgdGhpcy5fZWRnZUxhYmVsc1tlXTtcbiAgICBkZWxldGUgdGhpcy5fZWRnZU9ianNbZV07XG4gICAgZGVjcmVtZW50T3JSZW1vdmVFbnRyeSh0aGlzLl9wcmVkc1t3XSwgdik7XG4gICAgZGVjcmVtZW50T3JSZW1vdmVFbnRyeSh0aGlzLl9zdWNzW3ZdLCB3KTtcbiAgICBkZWxldGUgdGhpcy5faW5bd11bZV07XG4gICAgZGVsZXRlIHRoaXMuX291dFt2XVtlXTtcbiAgICB0aGlzLl9lZGdlQ291bnQtLTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5pbkVkZ2VzID0gZnVuY3Rpb24odiwgdSkge1xuICB2YXIgaW5WID0gdGhpcy5faW5bdl07XG4gIGlmIChpblYpIHtcbiAgICB2YXIgZWRnZXMgPSBfLnZhbHVlcyhpblYpO1xuICAgIGlmICghdSkge1xuICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICByZXR1cm4gXy5maWx0ZXIoZWRnZXMsIGZ1bmN0aW9uKGVkZ2UpIHsgcmV0dXJuIGVkZ2UudiA9PT0gdTsgfSk7XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5vdXRFZGdlcyA9IGZ1bmN0aW9uKHYsIHcpIHtcbiAgdmFyIG91dFYgPSB0aGlzLl9vdXRbdl07XG4gIGlmIChvdXRWKSB7XG4gICAgdmFyIGVkZ2VzID0gXy52YWx1ZXMob3V0Vik7XG4gICAgaWYgKCF3KSB7XG4gICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIHJldHVybiBfLmZpbHRlcihlZGdlcywgZnVuY3Rpb24oZWRnZSkgeyByZXR1cm4gZWRnZS53ID09PSB3OyB9KTtcbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLm5vZGVFZGdlcyA9IGZ1bmN0aW9uKHYsIHcpIHtcbiAgdmFyIGluRWRnZXMgPSB0aGlzLmluRWRnZXModiwgdyk7XG4gIGlmIChpbkVkZ2VzKSB7XG4gICAgcmV0dXJuIGluRWRnZXMuY29uY2F0KHRoaXMub3V0RWRnZXModiwgdykpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBpbmNyZW1lbnRPckluaXRFbnRyeShtYXAsIGspIHtcbiAgaWYgKG1hcFtrXSkge1xuICAgIG1hcFtrXSsrO1xuICB9IGVsc2Uge1xuICAgIG1hcFtrXSA9IDE7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVjcmVtZW50T3JSZW1vdmVFbnRyeShtYXAsIGspIHtcbiAgaWYgKCEtLW1hcFtrXSkgeyBkZWxldGUgbWFwW2tdOyB9XG59XG5cbmZ1bmN0aW9uIGVkZ2VBcmdzVG9JZChpc0RpcmVjdGVkLCB2Xywgd18sIG5hbWUpIHtcbiAgdmFyIHYgPSBcIlwiICsgdl87XG4gIHZhciB3ID0gXCJcIiArIHdfO1xuICBpZiAoIWlzRGlyZWN0ZWQgJiYgdiA+IHcpIHtcbiAgICB2YXIgdG1wID0gdjtcbiAgICB2ID0gdztcbiAgICB3ID0gdG1wO1xuICB9XG4gIHJldHVybiB2ICsgRURHRV9LRVlfREVMSU0gKyB3ICsgRURHRV9LRVlfREVMSU0gK1xuICAgICAgICAgICAgIChfLmlzVW5kZWZpbmVkKG5hbWUpID8gREVGQVVMVF9FREdFX05BTUUgOiBuYW1lKTtcbn1cblxuZnVuY3Rpb24gZWRnZUFyZ3NUb09iaihpc0RpcmVjdGVkLCB2Xywgd18sIG5hbWUpIHtcbiAgdmFyIHYgPSBcIlwiICsgdl87XG4gIHZhciB3ID0gXCJcIiArIHdfO1xuICBpZiAoIWlzRGlyZWN0ZWQgJiYgdiA+IHcpIHtcbiAgICB2YXIgdG1wID0gdjtcbiAgICB2ID0gdztcbiAgICB3ID0gdG1wO1xuICB9XG4gIHZhciBlZGdlT2JqID0gIHsgdjogdiwgdzogdyB9O1xuICBpZiAobmFtZSkge1xuICAgIGVkZ2VPYmoubmFtZSA9IG5hbWU7XG4gIH1cbiAgcmV0dXJuIGVkZ2VPYmo7XG59XG5cbmZ1bmN0aW9uIGVkZ2VPYmpUb0lkKGlzRGlyZWN0ZWQsIGVkZ2VPYmopIHtcbiAgcmV0dXJuIGVkZ2VBcmdzVG9JZChpc0RpcmVjdGVkLCBlZGdlT2JqLnYsIGVkZ2VPYmoudywgZWRnZU9iai5uYW1lKTtcbn1cbiIsIi8vIEluY2x1ZGVzIG9ubHkgdGhlIFwiY29yZVwiIG9mIGdyYXBobGliXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR3JhcGg6IHJlcXVpcmUoXCIuL2dyYXBoXCIpLFxuICB2ZXJzaW9uOiByZXF1aXJlKFwiLi92ZXJzaW9uXCIpXG59O1xuIiwidmFyIF8gPSByZXF1aXJlKFwiLi9sb2Rhc2hcIik7XG52YXIgR3JhcGggPSByZXF1aXJlKFwiLi9ncmFwaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHdyaXRlOiB3cml0ZSxcbiAgcmVhZDogcmVhZFxufTtcblxuZnVuY3Rpb24gd3JpdGUoZykge1xuICB2YXIganNvbiA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICBkaXJlY3RlZDogZy5pc0RpcmVjdGVkKCksXG4gICAgICBtdWx0aWdyYXBoOiBnLmlzTXVsdGlncmFwaCgpLFxuICAgICAgY29tcG91bmQ6IGcuaXNDb21wb3VuZCgpXG4gICAgfSxcbiAgICBub2Rlczogd3JpdGVOb2RlcyhnKSxcbiAgICBlZGdlczogd3JpdGVFZGdlcyhnKVxuICB9O1xuICBpZiAoIV8uaXNVbmRlZmluZWQoZy5ncmFwaCgpKSkge1xuICAgIGpzb24udmFsdWUgPSBfLmNsb25lKGcuZ3JhcGgoKSk7XG4gIH1cbiAgcmV0dXJuIGpzb247XG59XG5cbmZ1bmN0aW9uIHdyaXRlTm9kZXMoZykge1xuICByZXR1cm4gXy5tYXAoZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGVWYWx1ZSA9IGcubm9kZSh2KTtcbiAgICB2YXIgcGFyZW50ID0gZy5wYXJlbnQodik7XG4gICAgdmFyIG5vZGUgPSB7IHY6IHYgfTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQobm9kZVZhbHVlKSkge1xuICAgICAgbm9kZS52YWx1ZSA9IG5vZGVWYWx1ZTtcbiAgICB9XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmVudCkpIHtcbiAgICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRWRnZXMoZykge1xuICByZXR1cm4gXy5tYXAoZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2VWYWx1ZSA9IGcuZWRnZShlKTtcbiAgICB2YXIgZWRnZSA9IHsgdjogZS52LCB3OiBlLncgfTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoZS5uYW1lKSkge1xuICAgICAgZWRnZS5uYW1lID0gZS5uYW1lO1xuICAgIH1cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoZWRnZVZhbHVlKSkge1xuICAgICAgZWRnZS52YWx1ZSA9IGVkZ2VWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGVkZ2U7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWFkKGpzb24pIHtcbiAgdmFyIGcgPSBuZXcgR3JhcGgoanNvbi5vcHRpb25zKS5zZXRHcmFwaChqc29uLnZhbHVlKTtcbiAgXy5lYWNoKGpzb24ubm9kZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgZy5zZXROb2RlKGVudHJ5LnYsIGVudHJ5LnZhbHVlKTtcbiAgICBpZiAoZW50cnkucGFyZW50KSB7XG4gICAgICBnLnNldFBhcmVudChlbnRyeS52LCBlbnRyeS5wYXJlbnQpO1xuICAgIH1cbiAgfSk7XG4gIF8uZWFjaChqc29uLmVkZ2VzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgIGcuc2V0RWRnZSh7IHY6IGVudHJ5LnYsIHc6IGVudHJ5LncsIG5hbWU6IGVudHJ5Lm5hbWUgfSwgZW50cnkudmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIGc7XG59XG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG5cbnZhciBsb2Rhc2g7XG5cbmlmICh0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIHRyeSB7XG4gICAgbG9kYXNoID0ge1xuICAgICAgY2xvbmU6IHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVcIiksXG4gICAgICBjb25zdGFudDogcmVxdWlyZShcImxvZGFzaC9jb25zdGFudFwiKSxcbiAgICAgIGVhY2g6IHJlcXVpcmUoXCJsb2Rhc2gvZWFjaFwiKSxcbiAgICAgIGZpbHRlcjogcmVxdWlyZShcImxvZGFzaC9maWx0ZXJcIiksXG4gICAgICBoYXM6ICByZXF1aXJlKFwibG9kYXNoL2hhc1wiKSxcbiAgICAgIGlzQXJyYXk6IHJlcXVpcmUoXCJsb2Rhc2gvaXNBcnJheVwiKSxcbiAgICAgIGlzRW1wdHk6IHJlcXVpcmUoXCJsb2Rhc2gvaXNFbXB0eVwiKSxcbiAgICAgIGlzRnVuY3Rpb246IHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSxcbiAgICAgIGlzVW5kZWZpbmVkOiByZXF1aXJlKFwibG9kYXNoL2lzVW5kZWZpbmVkXCIpLFxuICAgICAga2V5czogcmVxdWlyZShcImxvZGFzaC9rZXlzXCIpLFxuICAgICAgbWFwOiByZXF1aXJlKFwibG9kYXNoL21hcFwiKSxcbiAgICAgIHJlZHVjZTogcmVxdWlyZShcImxvZGFzaC9yZWR1Y2VcIiksXG4gICAgICBzaXplOiByZXF1aXJlKFwibG9kYXNoL3NpemVcIiksXG4gICAgICB0cmFuc2Zvcm06IHJlcXVpcmUoXCJsb2Rhc2gvdHJhbnNmb3JtXCIpLFxuICAgICAgdW5pb246IHJlcXVpcmUoXCJsb2Rhc2gvdW5pb25cIiksXG4gICAgICB2YWx1ZXM6IHJlcXVpcmUoXCJsb2Rhc2gvdmFsdWVzXCIpXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGNvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgZXJyb3JcbiAgfVxufVxuXG5pZiAoIWxvZGFzaCkge1xuICBsb2Rhc2ggPSB3aW5kb3cuXztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsb2Rhc2g7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICcyLjEuOCc7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyksXG4gICAgc2V0Q2FjaGVBZGQgPSByZXF1aXJlKCcuL19zZXRDYWNoZUFkZCcpLFxuICAgIHNldENhY2hlSGFzID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVIYXMnKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG4iLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuIiwidmFyIGJhc2VJbmRleE9mID0gcmVxdWlyZSgnLi9fYmFzZUluZGV4T2YnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUluY2x1ZGVzO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UmVkdWNlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG4iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAqL1xudmFyIGFzY2lpU2l6ZSA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXNjaWlTaXplO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ247XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbkluO1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbicpLFxuICAgIGJhc2VBc3NpZ25JbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25JbicpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBjb3B5U3ltYm9scyA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzJyksXG4gICAgY29weVN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzSW4nKSxcbiAgICBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpLFxuICAgIGdldEFsbEtleXNJbiA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXNJbicpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGluaXRDbG9uZUFycmF5ID0gcmVxdWlyZSgnLi9faW5pdENsb25lQXJyYXknKSxcbiAgICBpbml0Q2xvbmVCeVRhZyA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUJ5VGFnJyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzTWFwID0gcmVxdWlyZSgnLi9pc01hcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU2V0ID0gcmVxdWlyZSgnLi9pc1NldCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG5jbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbmNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIERlZXAgY2xvbmVcbiAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICB2YXIgcmVzdWx0LFxuICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gIGlmIChjdXN0b21pemVyKSB7XG4gICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICB9XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgfVxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gIGlmIChzdGFja2VkKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQ7XG4gIH1cbiAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlKSB7XG4gICAgICByZXN1bHQuYWRkKGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNsb25lO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDcmVhdGU7XG4iLCJ2YXIgYmFzZUZvck93biA9IHJlcXVpcmUoJy4vX2Jhc2VGb3JPd24nKSxcbiAgICBjcmVhdGVCYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKi9cbnZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VFYWNoO1xuIiwidmFyIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaWx0ZXI7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmluZEluZGV4O1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzRmxhdHRlbmFibGUgPSByZXF1aXJlKCcuL19pc0ZsYXR0ZW5hYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGbGF0dGVuO1xuIiwidmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRm9yJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuIiwidmFyIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvck93bjtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldEFsbEtleXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXMob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VIYXM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG4iLCJ2YXIgYmFzZUZpbmRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VGaW5kSW5kZXgnKSxcbiAgICBiYXNlSXNOYU4gPSByZXF1aXJlKCcuL19iYXNlSXNOYU4nKSxcbiAgICBzdHJpY3RJbmRleE9mID0gcmVxdWlyZSgnLi9fc3RyaWN0SW5kZXhPZicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJbmRleE9mO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgYmFzZUlzRXF1YWxEZWVwID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWxEZWVwJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBlcXVhbEJ5VGFnID0gcmVxdWlyZSgnLi9fZXF1YWxCeVRhZycpLFxuICAgIGVxdWFsT2JqZWN0cyA9IHJlcXVpcmUoJy4vX2VxdWFsT2JqZWN0cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbERlZXA7XG4iLCJ2YXIgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWFwO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hdGNoO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYU47XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuIiwidmFyIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1NldDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwidmFyIGJhc2VNYXRjaGVzID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXMnKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXNQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBwcm9wZXJ0eSA9IHJlcXVpcmUoJy4vcHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXRlcmF0ZWU7XG4iLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5c0luID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcbiIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hcDtcbiIsInZhciBiYXNlSXNNYXRjaCA9IHJlcXVpcmUoJy4vX2Jhc2VJc01hdGNoJyksXG4gICAgZ2V0TWF0Y2hEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWF0Y2hEYXRhJyksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlcztcbiIsInZhciBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyksXG4gICAgZ2V0ID0gcmVxdWlyZSgnLi9nZXQnKSxcbiAgICBoYXNJbiA9IHJlcXVpcmUoJy4vaGFzSW4nKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzUHJvcGVydHk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eTtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHlEZWVwO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAsIHdpdGhvdXQgc3VwcG9ydFxuICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gIHVzaW5nIGBlYWNoRnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBpbml0QWNjdW0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50IG9mXG4gKiAgYGNvbGxlY3Rpb25gIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSB7XG4gIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXG4gICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZWR1Y2U7XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlc3Q7XG4iLCJ2YXIgY29uc3RhbnQgPSByZXF1aXJlKCcuL2NvbnN0YW50JyksXG4gICAgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0VG9TdHJpbmc7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzJyksXG4gICAgYXJyYXlJbmNsdWRlc1dpdGggPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzV2l0aCcpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKSxcbiAgICBjcmVhdGVTZXQgPSByZXF1aXJlKCcuL19jcmVhdGVTZXQnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICByZXN1bHQgPSBbXSxcbiAgICAgIHNlZW4gPSByZXN1bHQ7XG5cbiAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gIH1cbiAgZWxzZSBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICB2YXIgc2V0ID0gaXRlcmF0ZWUgPyBudWxsIDogY3JlYXRlU2V0KGFycmF5KTtcbiAgICBpZiAoc2V0KSB7XG4gICAgICByZXR1cm4gc2V0VG9BcnJheShzZXQpO1xuICAgIH1cbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgc2VlbiA9IG5ldyBTZXRDYWNoZTtcbiAgfVxuICBlbHNlIHtcbiAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgfVxuICBvdXRlcjpcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmlxO1xuIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVZhbHVlcztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlSGFzO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGlkZW50aXR5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RGdW5jdGlvbjtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURhdGFWaWV3O1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVJlZ0V4cDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lU3ltYm9sO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weU9iamVjdDtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9scztcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpO1xuXG4vKipcbiAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHNJbjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUVhY2g7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuIiwidmFyIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIG5vb3AgPSByZXF1aXJlKCcuL25vb3AnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gKi9cbnZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVNldDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5U29tZSA9IHJlcXVpcmUoJy4vX2FycmF5U29tZScpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxCeVRhZztcbiIsInZhciBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXM7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5c0luO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hdGNoRGF0YTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHNJbjtcbiIsInZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4vX0RhdGFWaWV3JyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vX1Byb21pc2UnKSxcbiAgICBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBXZWFrTWFwID0gcmVxdWlyZSgnLi9fV2Vha01hcCcpLFxuICAgIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRhZztcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG52YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNVbmljb2RlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQXJyYXk7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKSxcbiAgICBjbG9uZURhdGFWaWV3ID0gcmVxdWlyZSgnLi9fY2xvbmVEYXRhVmlldycpLFxuICAgIGNsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsIi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVG9BcnJheTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlQWRkO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlSGFzO1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuIiwidmFyIGJhc2VTZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VTZXRUb1N0cmluZycpLFxuICAgIHNob3J0T3V0ID0gcmVxdWlyZSgnLi9fc2hvcnRPdXQnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb1N0cmluZztcbiIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG9ydE91dDtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmljdEluZGV4T2Y7XG4iLCJ2YXIgYXNjaWlTaXplID0gcmVxdWlyZSgnLi9fYXNjaWlTaXplJyksXG4gICAgaGFzVW5pY29kZSA9IHJlcXVpcmUoJy4vX2hhc1VuaWNvZGUnKSxcbiAgICB1bmljb2RlU2l6ZSA9IHJlcXVpcmUoJy4vX3VuaWNvZGVTaXplJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbnVtYmVyIG9mIHN5bWJvbHMgaW4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1NpemUoc3RyaW5nKSB7XG4gIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICA/IHVuaWNvZGVTaXplKHN0cmluZylcbiAgICA6IGFzY2lpU2l6ZShzdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1NpemU7XG4iLCJ2YXIgbWVtb2l6ZUNhcHBlZCA9IHJlcXVpcmUoJy4vX21lbW9pemVDYXBwZWQnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvUGF0aDtcbiIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9LZXk7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4vKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xudmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYSBVbmljb2RlIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICovXG5mdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IHJlVW5pY29kZS5sYXN0SW5kZXggPSAwO1xuICB3aGlsZSAocmVVbmljb2RlLnRlc3Qoc3RyaW5nKSkge1xuICAgICsrcmVzdWx0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pY29kZVNpemU7XG4iLCJ2YXIgYmFzZUNsb25lID0gcmVxdWlyZSgnLi9fYmFzZUNsb25lJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgdmFsdWVgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwczovL21kbi5pby9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSlcbiAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcbiAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZFxuICogYXJyYXlzLiBUaGUgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBjbG9uZWRcbiAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcbiAqIGFzIGVycm9yIG9iamVjdHMsIGZ1bmN0aW9ucywgRE9NIG5vZGVzLCBhbmQgV2Vha01hcHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZURlZXBcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zdGFudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mb3JFYWNoJyk7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgYmFzZUZpbHRlciA9IHJlcXVpcmUoJy4vX2Jhc2VGaWx0ZXInKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKiBAc2VlIF8ucmVqZWN0XG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICogXTtcbiAqXG4gKiBfLmZpbHRlcih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICovXG5mdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbHRlcjtcbiIsInZhciBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgY2FzdEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fY2FzdEZ1bmN0aW9uJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBlYWNoXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAqXG4gKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG4iLCJ2YXIgYmFzZUhhcyA9IHJlcXVpcmUoJy4vX2Jhc2VIYXMnKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiAyIH0gfTtcbiAqIHZhciBvdGhlciA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhcyhvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXMob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhcyhvdGhlciwgJ2EnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXM7XG4iLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGVtcHR5IG9iamVjdCwgY29sbGVjdGlvbiwgbWFwLCBvciBzZXQuXG4gKlxuICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gKiBwcm9wZXJ0aWVzLlxuICpcbiAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICogalF1ZXJ5LWxpa2UgY29sbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYGxlbmd0aGAgb2YgYDBgLlxuICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0VtcHR5KG51bGwpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSh0cnVlKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAoaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZS5zcGxpY2UgPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gIH1cbiAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICByZXR1cm4gIXZhbHVlLnNpemU7XG4gIH1cbiAgaWYgKGlzUHJvdG90eXBlKHZhbHVlKSkge1xuICAgIHJldHVybiAhYmFzZUtleXModmFsdWUpLmxlbmd0aDtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VtcHR5O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsInZhciBiYXNlSXNNYXAgPSByZXF1aXJlKCcuL19iYXNlSXNNYXAnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTWFwKG5ldyBNYXApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXA7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlSXNTZXQgPSByZXF1aXJlKCcuL19iYXNlSXNTZXQnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU2V0KG5ldyBTZXQpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTZXQ7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmc7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1VuZGVmaW5lZDtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIExvZGFzaCA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIENvcHlyaWdodCBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL29wZW5qc2Yub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUtRVM1IGVudmlyb25tZW50cy4gKi9cbiAgdmFyIHVuZGVmaW5lZDtcblxuICAvKiogVXNlZCBhcyB0aGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuICovXG4gIHZhciBWRVJTSU9OID0gJzQuMTcuMTUnO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xuICB2YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuICAvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG4gIHZhciBDT1JFX0VSUk9SX1RFWFQgPSAnVW5zdXBwb3J0ZWQgY29yZS1qcyB1c2UuIFRyeSBodHRwczovL25wbXMuaW8vc2VhcmNoP3E9cG9ueWZpbGwuJyxcbiAgICAgIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuICAvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG4gIHZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuICAvKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG4gIHZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi9cbiAgdmFyIFBMQUNFSE9MREVSID0gJ19fbG9kYXNoX3BsYWNlaG9sZGVyX18nO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG4gIHZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG4gIHZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbiAgdmFyIFdSQVBfQklORF9GTEFHID0gMSxcbiAgICAgIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsXG4gICAgICBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgICAgV1JBUF9DVVJSWV9GTEFHID0gOCxcbiAgICAgIFdSQVBfQ1VSUllfUklHSFRfRkxBRyA9IDE2LFxuICAgICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMixcbiAgICAgIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHID0gNjQsXG4gICAgICBXUkFQX0FSWV9GTEFHID0gMTI4LFxuICAgICAgV1JBUF9SRUFSR19GTEFHID0gMjU2LFxuICAgICAgV1JBUF9GTElQX0ZMQUcgPSA1MTI7XG5cbiAgLyoqIFVzZWQgYXMgZGVmYXVsdCBvcHRpb25zIGZvciBgXy50cnVuY2F0ZWAuICovXG4gIHZhciBERUZBVUxUX1RSVU5DX0xFTkdUSCA9IDMwLFxuICAgICAgREVGQVVMVF9UUlVOQ19PTUlTU0lPTiA9ICcuLi4nO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbiAgdmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICAgIEhPVF9TUEFOID0gMTY7XG5cbiAgLyoqIFVzZWQgdG8gaW5kaWNhdGUgdGhlIHR5cGUgb2YgbGF6eSBpdGVyYXRlZXMuICovXG4gIHZhciBMQVpZX0ZJTFRFUl9GTEFHID0gMSxcbiAgICAgIExBWllfTUFQX0ZMQUcgPSAyLFxuICAgICAgTEFaWV9XSElMRV9GTEFHID0gMztcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbiAgdmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MSxcbiAgICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgsXG4gICAgICBOQU4gPSAwIC8gMDtcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB0aGUgbWF4aW11bSBsZW5ndGggYW5kIGluZGV4IG9mIGFuIGFycmF5LiAqL1xuICB2YXIgTUFYX0FSUkFZX0xFTkdUSCA9IDQyOTQ5NjcyOTUsXG4gICAgICBNQVhfQVJSQVlfSU5ERVggPSBNQVhfQVJSQVlfTEVOR1RIIC0gMSxcbiAgICAgIEhBTEZfTUFYX0FSUkFZX0xFTkdUSCA9IE1BWF9BUlJBWV9MRU5HVEggPj4+IDE7XG5cbiAgLyoqIFVzZWQgdG8gYXNzb2NpYXRlIHdyYXAgbWV0aG9kcyB3aXRoIHRoZWlyIGJpdCBmbGFncy4gKi9cbiAgdmFyIHdyYXBGbGFncyA9IFtcbiAgICBbJ2FyeScsIFdSQVBfQVJZX0ZMQUddLFxuICAgIFsnYmluZCcsIFdSQVBfQklORF9GTEFHXSxcbiAgICBbJ2JpbmRLZXknLCBXUkFQX0JJTkRfS0VZX0ZMQUddLFxuICAgIFsnY3VycnknLCBXUkFQX0NVUlJZX0ZMQUddLFxuICAgIFsnY3VycnlSaWdodCcsIFdSQVBfQ1VSUllfUklHSFRfRkxBR10sXG4gICAgWydmbGlwJywgV1JBUF9GTElQX0ZMQUddLFxuICAgIFsncGFydGlhbCcsIFdSQVBfUEFSVElBTF9GTEFHXSxcbiAgICBbJ3BhcnRpYWxSaWdodCcsIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHXSxcbiAgICBbJ3JlYXJnJywgV1JBUF9SRUFSR19GTEFHXVxuICBdO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBkb21FeGNUYWcgPSAnW29iamVjdCBET01FeGNlcHRpb25dJyxcbiAgICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXScsXG4gICAgICB3ZWFrU2V0VGFnID0gJ1tvYmplY3QgV2Vha1NldF0nO1xuXG4gIHZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbiAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUVzY2FwZWRIdG1sID0gLyYoPzphbXB8bHR8Z3R8cXVvdHwjMzkpOy9nLFxuICAgICAgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csXG4gICAgICByZUhhc0VzY2FwZWRIdG1sID0gUmVnRXhwKHJlRXNjYXBlZEh0bWwuc291cmNlKSxcbiAgICAgIHJlSGFzVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cChyZVVuZXNjYXBlZEh0bWwuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlRXZhbHVhdGUgPSAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcc1xcU10rPyklPi9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXG4gICAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gICAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICAgKi9cbiAgdmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZyxcbiAgICAgIHJlSGFzUmVnRXhwQ2hhciA9IFJlZ0V4cChyZVJlZ0V4cENoYXIuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xuICB2YXIgcmVUcmltID0gL15cXHMrfFxccyskL2csXG4gICAgICByZVRyaW1TdGFydCA9IC9eXFxzKy8sXG4gICAgICByZVRyaW1FbmQgPSAvXFxzKyQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdyYXAgZGV0YWlsIGNvbW1lbnRzLiAqL1xuICB2YXIgcmVXcmFwQ29tbWVudCA9IC9cXHsoPzpcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoIC4rXFxdIFxcKlxcLyk/XFxuPy8sXG4gICAgICByZVdyYXBEZXRhaWxzID0gL1xce1xcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggKC4rKVxcXSBcXCovLFxuICAgICAgcmVTcGxpdERldGFpbHMgPSAvLD8gJiAvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIGNvbXBvc2VkIG9mIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaFxuICAgKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxuICAgKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG4gIHZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG4gIHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG4gIHZhciByZUxhdGluID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2c7XG5cbiAgLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbiAgdmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgICByc0RpbmdiYXRSYW5nZSA9ICdcXFxcdTI3MDAtXFxcXHUyN2JmJyxcbiAgICAgIHJzTG93ZXJSYW5nZSA9ICdhLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmYnLFxuICAgICAgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JyxcbiAgICAgIHJzTm9uQ2hhclJhbmdlID0gJ1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZicsXG4gICAgICByc1B1bmN0dWF0aW9uUmFuZ2UgPSAnXFxcXHUyMDAwLVxcXFx1MjA2ZicsXG4gICAgICByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnLFxuICAgICAgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZScsXG4gICAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZicsXG4gICAgICByc0JyZWFrUmFuZ2UgPSByc01hdGhPcFJhbmdlICsgcnNOb25DaGFyUmFuZ2UgKyByc1B1bmN0dWF0aW9uUmFuZ2UgKyByc1NwYWNlUmFuZ2U7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xuICB2YXIgcnNBcG9zID0gXCJbJ1xcdTIwMTldXCIsXG4gICAgICByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgICByc0JyZWFrID0gJ1snICsgcnNCcmVha1JhbmdlICsgJ10nLFxuICAgICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICAgIHJzRGlnaXRzID0gJ1xcXFxkKycsXG4gICAgICByc0RpbmdiYXQgPSAnWycgKyByc0RpbmdiYXRSYW5nZSArICddJyxcbiAgICAgIHJzTG93ZXIgPSAnWycgKyByc0xvd2VyUmFuZ2UgKyAnXScsXG4gICAgICByc01pc2MgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICAgIHJzVXBwZXIgPSAnWycgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xuICB2YXIgcnNNaXNjTG93ZXIgPSAnKD86JyArIHJzTG93ZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgICByc01pc2NVcHBlciA9ICcoPzonICsgcnNVcHBlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICAgIHJzT3B0Q29udHJMb3dlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OmR8bGx8bXxyZXxzfHR8dmUpKT8nLFxuICAgICAgcnNPcHRDb250clVwcGVyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86RHxMTHxNfFJFfFN8VHxWRSkpPycsXG4gICAgICByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICAgIHJzT3JkTG93ZXIgPSAnXFxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aCkoPz1cXFxcYnxbQS1aX10pJyxcbiAgICAgIHJzT3JkVXBwZXIgPSAnXFxcXGQqKD86MVNUfDJORHwzUkR8KD8hWzEyM10pXFxcXGRUSCkoPz1cXFxcYnxbYS16X10pJyxcbiAgICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICAgIHJzRW1vamkgPSAnKD86JyArIFtyc0RpbmdiYXQsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzU2VxLFxuICAgICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYXBvc3Ryb3BoZXMuICovXG4gIHZhciByZUFwb3MgPSBSZWdFeHAocnNBcG9zLCAnZycpO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXG4gICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXG4gICAqL1xuICB2YXIgcmVDb21ib01hcmsgPSBSZWdFeHAocnNDb21ibywgJ2cnKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xuICB2YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggY29tcGxleCBvciBjb21wb3VuZCB3b3Jkcy4gKi9cbiAgdmFyIHJlVW5pY29kZVdvcmQgPSBSZWdFeHAoW1xuICAgIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gICAgcnNNaXNjVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyICsgcnNNaXNjTG93ZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICAgIHJzVXBwZXIgKyAnPycgKyByc01pc2NMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlcixcbiAgICByc1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyLFxuICAgIHJzT3JkVXBwZXIsXG4gICAgcnNPcmRMb3dlcixcbiAgICByc0RpZ2l0cyxcbiAgICByc0Vtb2ppXG4gIF0uam9pbignfCcpLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHdpdGggW3plcm8td2lkdGggam9pbmVycyBvciBjb2RlIHBvaW50cyBmcm9tIHRoZSBhc3RyYWwgcGxhbmVzXShodHRwOi8vZWV2LmVlL2Jsb2cvMjAxNS8wOS8xMi9kYXJrLWNvcm5lcnMtb2YtdW5pY29kZS8pLiAqL1xuICB2YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB0aGF0IG5lZWQgYSBtb3JlIHJvYnVzdCByZWdleHAgdG8gbWF0Y2ggd29yZHMuICovXG4gIHZhciByZUhhc1VuaWNvZGVXb3JkID0gL1thLXpdW0EtWl18W0EtWl17Mn1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87XG5cbiAgLyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgY29udGV4dFByb3BzID0gW1xuICAgICdBcnJheScsICdCdWZmZXInLCAnRGF0YVZpZXcnLCAnRGF0ZScsICdFcnJvcicsICdGbG9hdDMyQXJyYXknLCAnRmxvYXQ2NEFycmF5JyxcbiAgICAnRnVuY3Rpb24nLCAnSW50OEFycmF5JywgJ0ludDE2QXJyYXknLCAnSW50MzJBcnJheScsICdNYXAnLCAnTWF0aCcsICdPYmplY3QnLFxuICAgICdQcm9taXNlJywgJ1JlZ0V4cCcsICdTZXQnLCAnU3RyaW5nJywgJ1N5bWJvbCcsICdUeXBlRXJyb3InLCAnVWludDhBcnJheScsXG4gICAgJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ1VpbnQxNkFycmF5JywgJ1VpbnQzMkFycmF5JywgJ1dlYWtNYXAnLFxuICAgICdfJywgJ2NsZWFyVGltZW91dCcsICdpc0Zpbml0ZScsICdwYXJzZUludCcsICdzZXRUaW1lb3V0J1xuICBdO1xuXG4gIC8qKiBVc2VkIHRvIG1ha2UgdGVtcGxhdGUgc291cmNlVVJMcyBlYXNpZXIgdG8gaWRlbnRpZnkuICovXG4gIHZhciB0ZW1wbGF0ZUNvdW50ZXIgPSAtMTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG4gIHZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xuICB0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICB0eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbiAgdmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbiAgY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbiAgY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBMYXRpbiBVbmljb2RlIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy4gKi9cbiAgdmFyIGRlYnVycmVkTGV0dGVycyA9IHtcbiAgICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gICAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICAgJ1xceGUwJzogJ2EnLCAgJ1xceGUxJzogJ2EnLCAnXFx4ZTInOiAnYScsICdcXHhlMyc6ICdhJywgJ1xceGU0JzogJ2EnLCAnXFx4ZTUnOiAnYScsXG4gICAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAgICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgICAnXFx4YzgnOiAnRScsICAnXFx4YzknOiAnRScsICdcXHhjYSc6ICdFJywgJ1xceGNiJzogJ0UnLFxuICAgICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICAgJ1xceGNjJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgICAnXFx4ZWMnOiAnaScsICAnXFx4ZWQnOiAnaScsICdcXHhlZSc6ICdpJywgJ1xceGVmJzogJ2knLFxuICAgICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgICAnXFx4ZjInOiAnbycsICAnXFx4ZjMnOiAnbycsICdcXHhmNCc6ICdvJywgJ1xceGY1JzogJ28nLCAnXFx4ZjYnOiAnbycsICdcXHhmOCc6ICdvJyxcbiAgICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAgICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICAgJ1xceGRkJzogJ1knLCAgJ1xceGZkJzogJ3knLCAnXFx4ZmYnOiAneScsXG4gICAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAgICdcXHhkZic6ICdzcycsXG4gICAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cbiAgICAnXFx1MDEwMCc6ICdBJywgICdcXHUwMTAyJzogJ0EnLCAnXFx1MDEwNCc6ICdBJyxcbiAgICAnXFx1MDEwMSc6ICdhJywgICdcXHUwMTAzJzogJ2EnLCAnXFx1MDEwNSc6ICdhJyxcbiAgICAnXFx1MDEwNic6ICdDJywgICdcXHUwMTA4JzogJ0MnLCAnXFx1MDEwYSc6ICdDJywgJ1xcdTAxMGMnOiAnQycsXG4gICAgJ1xcdTAxMDcnOiAnYycsICAnXFx1MDEwOSc6ICdjJywgJ1xcdTAxMGInOiAnYycsICdcXHUwMTBkJzogJ2MnLFxuICAgICdcXHUwMTBlJzogJ0QnLCAgJ1xcdTAxMTAnOiAnRCcsICdcXHUwMTBmJzogJ2QnLCAnXFx1MDExMSc6ICdkJyxcbiAgICAnXFx1MDExMic6ICdFJywgICdcXHUwMTE0JzogJ0UnLCAnXFx1MDExNic6ICdFJywgJ1xcdTAxMTgnOiAnRScsICdcXHUwMTFhJzogJ0UnLFxuICAgICdcXHUwMTEzJzogJ2UnLCAgJ1xcdTAxMTUnOiAnZScsICdcXHUwMTE3JzogJ2UnLCAnXFx1MDExOSc6ICdlJywgJ1xcdTAxMWInOiAnZScsXG4gICAgJ1xcdTAxMWMnOiAnRycsICAnXFx1MDExZSc6ICdHJywgJ1xcdTAxMjAnOiAnRycsICdcXHUwMTIyJzogJ0cnLFxuICAgICdcXHUwMTFkJzogJ2cnLCAgJ1xcdTAxMWYnOiAnZycsICdcXHUwMTIxJzogJ2cnLCAnXFx1MDEyMyc6ICdnJyxcbiAgICAnXFx1MDEyNCc6ICdIJywgICdcXHUwMTI2JzogJ0gnLCAnXFx1MDEyNSc6ICdoJywgJ1xcdTAxMjcnOiAnaCcsXG4gICAgJ1xcdTAxMjgnOiAnSScsICAnXFx1MDEyYSc6ICdJJywgJ1xcdTAxMmMnOiAnSScsICdcXHUwMTJlJzogJ0knLCAnXFx1MDEzMCc6ICdJJyxcbiAgICAnXFx1MDEyOSc6ICdpJywgICdcXHUwMTJiJzogJ2knLCAnXFx1MDEyZCc6ICdpJywgJ1xcdTAxMmYnOiAnaScsICdcXHUwMTMxJzogJ2knLFxuICAgICdcXHUwMTM0JzogJ0onLCAgJ1xcdTAxMzUnOiAnaicsXG4gICAgJ1xcdTAxMzYnOiAnSycsICAnXFx1MDEzNyc6ICdrJywgJ1xcdTAxMzgnOiAnaycsXG4gICAgJ1xcdTAxMzknOiAnTCcsICAnXFx1MDEzYic6ICdMJywgJ1xcdTAxM2QnOiAnTCcsICdcXHUwMTNmJzogJ0wnLCAnXFx1MDE0MSc6ICdMJyxcbiAgICAnXFx1MDEzYSc6ICdsJywgICdcXHUwMTNjJzogJ2wnLCAnXFx1MDEzZSc6ICdsJywgJ1xcdTAxNDAnOiAnbCcsICdcXHUwMTQyJzogJ2wnLFxuICAgICdcXHUwMTQzJzogJ04nLCAgJ1xcdTAxNDUnOiAnTicsICdcXHUwMTQ3JzogJ04nLCAnXFx1MDE0YSc6ICdOJyxcbiAgICAnXFx1MDE0NCc6ICduJywgICdcXHUwMTQ2JzogJ24nLCAnXFx1MDE0OCc6ICduJywgJ1xcdTAxNGInOiAnbicsXG4gICAgJ1xcdTAxNGMnOiAnTycsICAnXFx1MDE0ZSc6ICdPJywgJ1xcdTAxNTAnOiAnTycsXG4gICAgJ1xcdTAxNGQnOiAnbycsICAnXFx1MDE0Zic6ICdvJywgJ1xcdTAxNTEnOiAnbycsXG4gICAgJ1xcdTAxNTQnOiAnUicsICAnXFx1MDE1Nic6ICdSJywgJ1xcdTAxNTgnOiAnUicsXG4gICAgJ1xcdTAxNTUnOiAncicsICAnXFx1MDE1Nyc6ICdyJywgJ1xcdTAxNTknOiAncicsXG4gICAgJ1xcdTAxNWEnOiAnUycsICAnXFx1MDE1Yyc6ICdTJywgJ1xcdTAxNWUnOiAnUycsICdcXHUwMTYwJzogJ1MnLFxuICAgICdcXHUwMTViJzogJ3MnLCAgJ1xcdTAxNWQnOiAncycsICdcXHUwMTVmJzogJ3MnLCAnXFx1MDE2MSc6ICdzJyxcbiAgICAnXFx1MDE2Mic6ICdUJywgICdcXHUwMTY0JzogJ1QnLCAnXFx1MDE2Nic6ICdUJyxcbiAgICAnXFx1MDE2Myc6ICd0JywgICdcXHUwMTY1JzogJ3QnLCAnXFx1MDE2Nyc6ICd0JyxcbiAgICAnXFx1MDE2OCc6ICdVJywgICdcXHUwMTZhJzogJ1UnLCAnXFx1MDE2Yyc6ICdVJywgJ1xcdTAxNmUnOiAnVScsICdcXHUwMTcwJzogJ1UnLCAnXFx1MDE3Mic6ICdVJyxcbiAgICAnXFx1MDE2OSc6ICd1JywgICdcXHUwMTZiJzogJ3UnLCAnXFx1MDE2ZCc6ICd1JywgJ1xcdTAxNmYnOiAndScsICdcXHUwMTcxJzogJ3UnLCAnXFx1MDE3Myc6ICd1JyxcbiAgICAnXFx1MDE3NCc6ICdXJywgICdcXHUwMTc1JzogJ3cnLFxuICAgICdcXHUwMTc2JzogJ1knLCAgJ1xcdTAxNzcnOiAneScsICdcXHUwMTc4JzogJ1knLFxuICAgICdcXHUwMTc5JzogJ1onLCAgJ1xcdTAxN2InOiAnWicsICdcXHUwMTdkJzogJ1onLFxuICAgICdcXHUwMTdhJzogJ3onLCAgJ1xcdTAxN2MnOiAneicsICdcXHUwMTdlJzogJ3onLFxuICAgICdcXHUwMTMyJzogJ0lKJywgJ1xcdTAxMzMnOiAnaWonLFxuICAgICdcXHUwMTUyJzogJ09lJywgJ1xcdTAxNTMnOiAnb2UnLFxuICAgICdcXHUwMTQ5JzogXCInblwiLCAnXFx1MDE3Zic6ICdzJ1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG4gIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgaHRtbFVuZXNjYXBlcyA9IHtcbiAgICAnJmFtcDsnOiAnJicsXG4gICAgJyZsdDsnOiAnPCcsXG4gICAgJyZndDsnOiAnPicsXG4gICAgJyZxdW90Oyc6ICdcIicsXG4gICAgJyYjMzk7JzogXCInXCJcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXG4nOiAnbicsXG4gICAgJ1xccic6ICdyJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbiAgdmFyIGZyZWVQYXJzZUZsb2F0ID0gcGFyc2VGbG9hdCxcbiAgICAgIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuICB2YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbiAgdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuICAvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbiAgLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG4gIHZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgICAgaWYgKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICAgIH1cblxuICAgICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9KCkpO1xuXG4gIC8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG4gIHZhciBub2RlSXNBcnJheUJ1ZmZlciA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzQXJyYXlCdWZmZXIsXG4gICAgICBub2RlSXNEYXRlID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNEYXRlLFxuICAgICAgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXAsXG4gICAgICBub2RlSXNSZWdFeHAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1JlZ0V4cCxcbiAgICAgIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0LFxuICAgICAgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUFnZ3JlZ2F0b3JgIGZvciBhcnJheXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5QWdncmVnYXRvcihhcnJheSwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUVhY2hSaWdodChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZXZlcnlgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RXZlcnkoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgKiBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAgICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2VSaWdodChhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbLS1sZW5ndGhdO1xuICAgIH1cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgKiBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYW4gQVNDSUkgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIHZhciBhc2NpaVNpemUgPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBBU0NJSSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXNjaWlUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhbiBBU0NJSSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFzY2lpV29yZHMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmZpbmRLZXlgIGFuZCBgXy5maW5kTGFzdEtleWAsXG4gICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmBcbiAgICogdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCBvciBpdHMga2V5LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRLZXkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYykge1xuICAgIHZhciByZXN1bHQ7XG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlSW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2ZXaXRoKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVhbmAgYW5kIGBfLm1lYW5CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZU1lYW4oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiBsZW5ndGggPyAoYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIC8gbGVuZ3RoKSA6IE5BTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCwgd2l0aG91dCBzdXBwb3J0XG4gICAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYCB1c2luZyBgZWFjaEZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEFjY3VtIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudCBvZlxuICAgKiAgYGNvbGxlY3Rpb25gIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXG4gICAgICAgID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lIHRoZVxuICAgKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gICAqIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc3VtYCBhbmQgYF8uc3VtQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBpdGVyYXRlZShhcnJheVtpbmRleF0pO1xuICAgICAgaWYgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGN1cnJlbnQgOiAocmVzdWx0ICsgY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICAgKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvUGFpcnNgIGFuZCBgXy50b1BhaXJzSW5gIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXlcbiAgICogb2Yga2V5LXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBgcHJvcHNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRvUGFpcnMob2JqZWN0LCBwcm9wcykge1xuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAgICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gICAqIG9mIGBwcm9wc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVN0YXJ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBzdHJpbmcgc3ltYm9sXG4gICAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBzdHJpbmcgc3ltYm9sXG4gICAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgICB2YXIgaW5kZXggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgYHBsYWNlaG9sZGVyYCBvY2N1cnJlbmNlcyBpbiBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgY291bnQuXG4gICAqL1xuICBmdW5jdGlvbiBjb3VudEhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gMDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKGFycmF5W2xlbmd0aF0gPT09IHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICsrcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IExhdGluLTEgU3VwcGxlbWVudCBhbmQgTGF0aW4gRXh0ZW5kZWQtQVxuICAgKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgbGV0dGVyLlxuICAgKi9cbiAgdmFyIGRlYnVyckxldHRlciA9IGJhc2VQcm9wZXJ0eU9mKGRlYnVycmVkTGV0dGVycyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIHZhciBlc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxFc2NhcGVzKTtcblxuICAvKipcbiAgICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocikge1xuICAgIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW2Nocl07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICAgIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBhIHdvcmQgY29tcG9zZWQgb2YgVW5pY29kZSBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgd29yZCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZVdvcmQudGVzdChzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBpdGVyYXRvcmAgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVyYXRvciBUaGUgaXRlcmF0b3IgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBpdGVyYXRvclRvQXJyYXkoaXRlcmF0b3IpIHtcbiAgICB2YXIgZGF0YSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoIShkYXRhID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICByZXN1bHQucHVzaChkYXRhLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgYHBsYWNlaG9sZGVyYCBlbGVtZW50cyBpbiBgYXJyYXlgIHdpdGggYW4gaW50ZXJuYWwgcGxhY2Vob2xkZXJcbiAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlaXIgaW5kZXhlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gcmVwbGFjZS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKHZhbHVlID09PSBwbGFjZWhvbGRlciB8fCB2YWx1ZSA9PT0gUExBQ0VIT0xERVIpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gUExBQ0VIT0xERVI7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzZXRgIHRvIGl0cyB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWUtdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBzZXRUb1BhaXJzKHNldCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gW3ZhbHVlLCB2YWx1ZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubGFzdEluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICAgKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ICsgMTtcbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHN5bWJvbHMgaW4gYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ1NpemUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyB1bmljb2RlU2l6ZShzdHJpbmcpXG4gICAgICA6IGFzY2lpU2l6ZShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKVxuICAgICAgOiBhc2NpaVRvQXJyYXkoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnVuZXNjYXBlYCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gdW5lc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICB2YXIgdW5lc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxVbmVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaXplIG9mIGEgVW5pY29kZSBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVNpemUoc3RyaW5nKSB7XG4gICAgdmFyIHJlc3VsdCA9IHJlVW5pY29kZS5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlIChyZVVuaWNvZGUudGVzdChzdHJpbmcpKSB7XG4gICAgICArK3Jlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgYSBVbmljb2RlIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVdvcmRzKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlV29yZCkgfHwgW107XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHVzaW5nIHRoZSBgY29udGV4dGAgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAxLjEuMFxuICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQ9cm9vdF0gVGhlIGNvbnRleHQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBuZXcgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ubWl4aW4oeyAnZm9vJzogXy5jb25zdGFudCgnZm9vJykgfSk7XG4gICAqXG4gICAqIHZhciBsb2Rhc2ggPSBfLnJ1bkluQ29udGV4dCgpO1xuICAgKiBsb2Rhc2gubWl4aW4oeyAnYmFyJzogbG9kYXNoLmNvbnN0YW50KCdiYXInKSB9KTtcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKF8uZm9vKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKiBfLmlzRnVuY3Rpb24oXy5iYXIpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guZm9vKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmJhcik7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogLy8gQ3JlYXRlIGEgc3VwZWQtdXAgYGRlZmVyYCBpbiBOb2RlLmpzLlxuICAgKiB2YXIgZGVmZXIgPSBfLnJ1bkluQ29udGV4dCh7ICdzZXRUaW1lb3V0Jzogc2V0SW1tZWRpYXRlIH0pLmRlZmVyO1xuICAgKi9cbiAgdmFyIHJ1bkluQ29udGV4dCA9IChmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnRleHQgPSBjb250ZXh0ID09IG51bGwgPyByb290IDogXy5kZWZhdWx0cyhyb290Lk9iamVjdCgpLCBjb250ZXh0LCBfLnBpY2socm9vdCwgY29udGV4dFByb3BzKSk7XG5cbiAgICAvKiogQnVpbHQtaW4gY29uc3RydWN0b3IgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBFcnJvciA9IGNvbnRleHQuRXJyb3IsXG4gICAgICAgIEZ1bmN0aW9uID0gY29udGV4dC5GdW5jdGlvbixcbiAgICAgICAgTWF0aCA9IGNvbnRleHQuTWF0aCxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dC5PYmplY3QsXG4gICAgICAgIFJlZ0V4cCA9IGNvbnRleHQuUmVnRXhwLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0LlN0cmluZyxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dC5UeXBlRXJyb3I7XG5cbiAgICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICAgICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xuICAgIHZhciBjb3JlSnNEYXRhID0gY29udGV4dFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbiAgICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG4gICAgdmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4gICAgLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcy4gKi9cbiAgICB2YXIgaWRDb3VudGVyID0gMDtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG4gICAgdmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICAgICAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gICAgICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAgICogb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xuICAgIHZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGBfYCByZWZlcmVuY2UgaW4gYF8ubm9Db25mbGljdGAuICovXG4gICAgdmFyIG9sZERhc2ggPSByb290Ll87XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xuICAgIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAgICAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4gICAgKTtcblxuICAgIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gY29udGV4dC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgICAgIFN5bWJvbCA9IGNvbnRleHQuU3ltYm9sLFxuICAgICAgICBVaW50OEFycmF5ID0gY29udGV4dC5VaW50OEFycmF5LFxuICAgICAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCksXG4gICAgICAgIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG4gICAgICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgICAgICBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltSXRlcmF0b3IgPSBTeW1ib2wgPyBTeW1ib2wuaXRlcmF0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICAgICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH0oKSk7XG5cbiAgICAvKiogTW9ja2VkIGJ1aWx0LWlucy4gKi9cbiAgICB2YXIgY3R4Q2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQgIT09IHJvb3QuY2xlYXJUaW1lb3V0ICYmIGNvbnRleHQuY2xlYXJUaW1lb3V0LFxuICAgICAgICBjdHhOb3cgPSBEYXRlICYmIERhdGUubm93ICE9PSByb290LkRhdGUubm93ICYmIERhdGUubm93LFxuICAgICAgICBjdHhTZXRUaW1lb3V0ID0gY29udGV4dC5zZXRUaW1lb3V0ICE9PSByb290LnNldFRpbWVvdXQgJiYgY29udGV4dC5zZXRUaW1lb3V0O1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICAgIHZhciBuYXRpdmVDZWlsID0gTWF0aC5jZWlsLFxuICAgICAgICBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgICAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxuICAgICAgICBuYXRpdmVKb2luID0gYXJyYXlQcm90by5qb2luLFxuICAgICAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcbiAgICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluLFxuICAgICAgICBuYXRpdmVOb3cgPSBEYXRlLm5vdyxcbiAgICAgICAgbmF0aXZlUGFyc2VJbnQgPSBjb250ZXh0LnBhcnNlSW50LFxuICAgICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbSxcbiAgICAgICAgbmF0aXZlUmV2ZXJzZSA9IGFycmF5UHJvdG8ucmV2ZXJzZTtcblxuICAgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbiAgICB2YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUoY29udGV4dCwgJ0RhdGFWaWV3JyksXG4gICAgICAgIE1hcCA9IGdldE5hdGl2ZShjb250ZXh0LCAnTWFwJyksXG4gICAgICAgIFByb21pc2UgPSBnZXROYXRpdmUoY29udGV4dCwgJ1Byb21pc2UnKSxcbiAgICAgICAgU2V0ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdTZXQnKSxcbiAgICAgICAgV2Vha01hcCA9IGdldE5hdGl2ZShjb250ZXh0LCAnV2Vha01hcCcpLFxuICAgICAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbiAgICAvKiogVXNlZCB0byBzdG9yZSBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbiAgICB2YXIgbWV0YU1hcCA9IFdlYWtNYXAgJiYgbmV3IFdlYWtNYXA7XG5cbiAgICAvKiogVXNlZCB0byBsb29rdXAgdW5taW5pZmllZCBmdW5jdGlvbiBuYW1lcy4gKi9cbiAgICB2YXIgcmVhbE5hbWVzID0ge307XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xuICAgIHZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgICAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgICAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICAgICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuICAgIC8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xuICAgIHZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgaW1wbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW4gc2VxdWVuY2VzLiBNZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiBhbmQgcmV0dXJuIGFycmF5cywgY29sbGVjdGlvbnMsXG4gICAgICogYW5kIGZ1bmN0aW9ucyBjYW4gYmUgY2hhaW5lZCB0b2dldGhlci4gTWV0aG9kcyB0aGF0IHJldHJpZXZlIGEgc2luZ2xlIHZhbHVlXG4gICAgICogb3IgbWF5IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZW5kIHRoZSBjaGFpbiBzZXF1ZW5jZVxuICAgICAqIGFuZCByZXR1cm4gdGhlIHVud3JhcHBlZCB2YWx1ZS4gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgbXVzdCBiZSB1bndyYXBwZWRcbiAgICAgKiB3aXRoIGBfI3ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEV4cGxpY2l0IGNoYWluIHNlcXVlbmNlcywgd2hpY2ggbXVzdCBiZSB1bndyYXBwZWQgd2l0aCBgXyN2YWx1ZWAsIG1heSBiZVxuICAgICAqIGVuYWJsZWQgdXNpbmcgYF8uY2hhaW5gLlxuICAgICAqXG4gICAgICogVGhlIGV4ZWN1dGlvbiBvZiBjaGFpbmVkIG1ldGhvZHMgaXMgbGF6eSwgdGhhdCBpcywgaXQncyBkZWZlcnJlZCB1bnRpbFxuICAgICAqIGBfI3ZhbHVlYCBpcyBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgY2FsbGVkLlxuICAgICAqXG4gICAgICogTGF6eSBldmFsdWF0aW9uIGFsbG93cyBzZXZlcmFsIG1ldGhvZHMgdG8gc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24uXG4gICAgICogU2hvcnRjdXQgZnVzaW9uIGlzIGFuIG9wdGltaXphdGlvbiB0byBtZXJnZSBpdGVyYXRlZSBjYWxsczsgdGhpcyBhdm9pZHNcbiAgICAgKiB0aGUgY3JlYXRpb24gb2YgaW50ZXJtZWRpYXRlIGFycmF5cyBhbmQgY2FuIGdyZWF0bHkgcmVkdWNlIHRoZSBudW1iZXIgb2ZcbiAgICAgKiBpdGVyYXRlZSBleGVjdXRpb25zLiBTZWN0aW9ucyBvZiBhIGNoYWluIHNlcXVlbmNlIHF1YWxpZnkgZm9yIHNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlmIHRoZSBzZWN0aW9uIGlzIGFwcGxpZWQgdG8gYW4gYXJyYXkgYW5kIGl0ZXJhdGVlcyBhY2NlcHQgb25seVxuICAgICAqIG9uZSBhcmd1bWVudC4gVGhlIGhldXJpc3RpYyBmb3Igd2hldGhlciBhIHNlY3Rpb24gcXVhbGlmaWVzIGZvciBzaG9ydGN1dFxuICAgICAqIGZ1c2lvbiBpcyBzdWJqZWN0IHRvIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGBfI3ZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIGxvZGFzaCBtZXRob2RzLCB3cmFwcGVycyBoYXZlIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgQXJyYXlgIG1ldGhvZHMgYXJlOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGBzaGlmdGAsIGBzb3J0YCwgYHNwbGljZWAsIGFuZCBgdW5zaGlmdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBTdHJpbmdgIG1ldGhvZHMgYXJlOlxuICAgICAqIGByZXBsYWNlYCBhbmQgYHNwbGl0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uIGFyZTpcbiAgICAgKiBgYXRgLCBgY29tcGFjdGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBkcm9wV2hpbGVgLCBgZmlsdGVyYCwgYGZpbmRgLFxuICAgICAqIGBmaW5kTGFzdGAsIGBoZWFkYCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcmVqZWN0YCwgYHJldmVyc2VgLCBgc2xpY2VgLFxuICAgICAqIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGFuZCBgdG9BcnJheWBcbiAgICAgKlxuICAgICAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBtZXRob2RzIGFyZTpcbiAgICAgKiBgYWZ0ZXJgLCBgYXJ5YCwgYGFzc2lnbmAsIGBhc3NpZ25JbmAsIGBhc3NpZ25JbldpdGhgLCBgYXNzaWduV2l0aGAsIGBhdGAsXG4gICAgICogYGJlZm9yZWAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjYXN0QXJyYXlgLCBgY2hhaW5gLCBgY2h1bmtgLFxuICAgICAqIGBjb21taXRgLCBgY29tcGFjdGAsIGBjb25jYXRgLCBgY29uZm9ybXNgLCBgY29uc3RhbnRgLCBgY291bnRCeWAsIGBjcmVhdGVgLFxuICAgICAqIGBjdXJyeWAsIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgZGVmZXJgLCBgZGVsYXlgLFxuICAgICAqIGBkaWZmZXJlbmNlYCwgYGRpZmZlcmVuY2VCeWAsIGBkaWZmZXJlbmNlV2l0aGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsXG4gICAgICogYGRyb3BSaWdodFdoaWxlYCwgYGRyb3BXaGlsZWAsIGBleHRlbmRgLCBgZXh0ZW5kV2l0aGAsIGBmaWxsYCwgYGZpbHRlcmAsXG4gICAgICogYGZsYXRNYXBgLCBgZmxhdE1hcERlZXBgLCBgZmxhdE1hcERlcHRoYCwgYGZsYXR0ZW5gLCBgZmxhdHRlbkRlZXBgLFxuICAgICAqIGBmbGF0dGVuRGVwdGhgLCBgZmxpcGAsIGBmbG93YCwgYGZsb3dSaWdodGAsIGBmcm9tUGFpcnNgLCBgZnVuY3Rpb25zYCxcbiAgICAgKiBgZnVuY3Rpb25zSW5gLCBgZ3JvdXBCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnRlcnNlY3Rpb25CeWAsXG4gICAgICogYGludGVyc2VjdGlvbldpdGhgLCBgaW52ZXJ0YCwgYGludmVydEJ5YCwgYGludm9rZU1hcGAsIGBpdGVyYXRlZWAsIGBrZXlCeWAsXG4gICAgICogYGtleXNgLCBga2V5c0luYCwgYG1hcGAsIGBtYXBLZXlzYCwgYG1hcFZhbHVlc2AsIGBtYXRjaGVzYCwgYG1hdGNoZXNQcm9wZXJ0eWAsXG4gICAgICogYG1lbW9pemVgLCBgbWVyZ2VgLCBgbWVyZ2VXaXRoYCwgYG1ldGhvZGAsIGBtZXRob2RPZmAsIGBtaXhpbmAsIGBuZWdhdGVgLFxuICAgICAqIGBudGhBcmdgLCBgb21pdGAsIGBvbWl0QnlgLCBgb25jZWAsIGBvcmRlckJ5YCwgYG92ZXJgLCBgb3ZlckFyZ3NgLFxuICAgICAqIGBvdmVyRXZlcnlgLCBgb3ZlclNvbWVgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLCBgcGFydGl0aW9uYCwgYHBpY2tgLFxuICAgICAqIGBwaWNrQnlgLCBgcGxhbnRgLCBgcHJvcGVydHlgLCBgcHJvcGVydHlPZmAsIGBwdWxsYCwgYHB1bGxBbGxgLCBgcHVsbEFsbEJ5YCxcbiAgICAgKiBgcHVsbEFsbFdpdGhgLCBgcHVsbEF0YCwgYHB1c2hgLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZWFyZ2AsIGByZWplY3RgLFxuICAgICAqIGByZW1vdmVgLCBgcmVzdGAsIGByZXZlcnNlYCwgYHNhbXBsZVNpemVgLCBgc2V0YCwgYHNldFdpdGhgLCBgc2h1ZmZsZWAsXG4gICAgICogYHNsaWNlYCwgYHNvcnRgLCBgc29ydEJ5YCwgYHNwbGljZWAsIGBzcHJlYWRgLCBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gICAgICogYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGB0YXBgLCBgdGhyb3R0bGVgLCBgdGhydWAsIGB0b0FycmF5YCxcbiAgICAgKiBgdG9QYWlyc2AsIGB0b1BhaXJzSW5gLCBgdG9QYXRoYCwgYHRvUGxhaW5PYmplY3RgLCBgdHJhbnNmb3JtYCwgYHVuYXJ5YCxcbiAgICAgKiBgdW5pb25gLCBgdW5pb25CeWAsIGB1bmlvbldpdGhgLCBgdW5pcWAsIGB1bmlxQnlgLCBgdW5pcVdpdGhgLCBgdW5zZXRgLFxuICAgICAqIGB1bnNoaWZ0YCwgYHVuemlwYCwgYHVuemlwV2l0aGAsIGB1cGRhdGVgLCBgdXBkYXRlV2l0aGAsIGB2YWx1ZXNgLFxuICAgICAqIGB2YWx1ZXNJbmAsIGB3aXRob3V0YCwgYHdyYXBgLCBgeG9yYCwgYHhvckJ5YCwgYHhvcldpdGhgLCBgemlwYCxcbiAgICAgKiBgemlwT2JqZWN0YCwgYHppcE9iamVjdERlZXBgLCBhbmQgYHppcFdpdGhgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgYXJlICoqbm90KiogY2hhaW5hYmxlIGJ5IGRlZmF1bHQgYXJlOlxuICAgICAqIGBhZGRgLCBgYXR0ZW1wdGAsIGBjYW1lbENhc2VgLCBgY2FwaXRhbGl6ZWAsIGBjZWlsYCwgYGNsYW1wYCwgYGNsb25lYCxcbiAgICAgKiBgY2xvbmVEZWVwYCwgYGNsb25lRGVlcFdpdGhgLCBgY2xvbmVXaXRoYCwgYGNvbmZvcm1zVG9gLCBgZGVidXJyYCxcbiAgICAgKiBgZGVmYXVsdFRvYCwgYGRpdmlkZWAsIGBlYWNoYCwgYGVhY2hSaWdodGAsIGBlbmRzV2l0aGAsIGBlcWAsIGBlc2NhcGVgLFxuICAgICAqIGBlc2NhcGVSZWdFeHBgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLCBgZmluZEtleWAsIGBmaW5kTGFzdGAsXG4gICAgICogYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgZmlyc3RgLCBgZmxvb3JgLCBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLFxuICAgICAqIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsIGBnZXRgLCBgZ3RgLCBgZ3RlYCwgYGhhc2AsXG4gICAgICogYGhhc0luYCwgYGhlYWRgLCBgaWRlbnRpdHlgLCBgaW5jbHVkZXNgLCBgaW5kZXhPZmAsIGBpblJhbmdlYCwgYGludm9rZWAsXG4gICAgICogYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNBcnJheUJ1ZmZlcmAsIGBpc0FycmF5TGlrZWAsIGBpc0FycmF5TGlrZU9iamVjdGAsXG4gICAgICogYGlzQm9vbGVhbmAsIGBpc0J1ZmZlcmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCwgYGlzRW1wdHlgLCBgaXNFcXVhbGAsXG4gICAgICogYGlzRXF1YWxXaXRoYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc0ludGVnZXJgLCBgaXNMZW5ndGhgLFxuICAgICAqIGBpc01hcGAsIGBpc01hdGNoYCwgYGlzTWF0Y2hXaXRoYCwgYGlzTmFOYCwgYGlzTmF0aXZlYCwgYGlzTmlsYCwgYGlzTnVsbGAsXG4gICAgICogYGlzTnVtYmVyYCwgYGlzT2JqZWN0YCwgYGlzT2JqZWN0TGlrZWAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCxcbiAgICAgKiBgaXNTYWZlSW50ZWdlcmAsIGBpc1NldGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBpc1R5cGVkQXJyYXlgLFxuICAgICAqIGBpc1dlYWtNYXBgLCBgaXNXZWFrU2V0YCwgYGpvaW5gLCBga2ViYWJDYXNlYCwgYGxhc3RgLCBgbGFzdEluZGV4T2ZgLFxuICAgICAqIGBsb3dlckNhc2VgLCBgbG93ZXJGaXJzdGAsIGBsdGAsIGBsdGVgLCBgbWF4YCwgYG1heEJ5YCwgYG1lYW5gLCBgbWVhbkJ5YCxcbiAgICAgKiBgbWluYCwgYG1pbkJ5YCwgYG11bHRpcGx5YCwgYG5vQ29uZmxpY3RgLCBgbm9vcGAsIGBub3dgLCBgbnRoYCwgYHBhZGAsXG4gICAgICogYHBhZEVuZGAsIGBwYWRTdGFydGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsIGByZWR1Y2VSaWdodGAsXG4gICAgICogYHJlcGVhdGAsIGByZXN1bHRgLCBgcm91bmRgLCBgcnVuSW5Db250ZXh0YCwgYHNhbXBsZWAsIGBzaGlmdGAsIGBzaXplYCxcbiAgICAgKiBgc25ha2VDYXNlYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgc29ydGVkSW5kZXhCeWAsIGBzb3J0ZWRMYXN0SW5kZXhgLFxuICAgICAqIGBzb3J0ZWRMYXN0SW5kZXhCeWAsIGBzdGFydENhc2VgLCBgc3RhcnRzV2l0aGAsIGBzdHViQXJyYXlgLCBgc3R1YkZhbHNlYCxcbiAgICAgKiBgc3R1Yk9iamVjdGAsIGBzdHViU3RyaW5nYCwgYHN0dWJUcnVlYCwgYHN1YnRyYWN0YCwgYHN1bWAsIGBzdW1CeWAsXG4gICAgICogYHRlbXBsYXRlYCwgYHRpbWVzYCwgYHRvRmluaXRlYCwgYHRvSW50ZWdlcmAsIGB0b0pTT05gLCBgdG9MZW5ndGhgLFxuICAgICAqIGB0b0xvd2VyYCwgYHRvTnVtYmVyYCwgYHRvU2FmZUludGVnZXJgLCBgdG9TdHJpbmdgLCBgdG9VcHBlcmAsIGB0cmltYCxcbiAgICAgKiBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBgdHJ1bmNhdGVgLCBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBgdXBwZXJDYXNlYCxcbiAgICAgKiBgdXBwZXJGaXJzdGAsIGB2YWx1ZWAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAbmFtZSBfXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDIsIDNdKTtcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIHdyYXBwZWQucmVkdWNlKF8uYWRkKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyBSZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKiB2YXIgc3F1YXJlcyA9IHdyYXBwZWQubWFwKHNxdWFyZSk7XG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKSB7XG4gICAgICAgICAgcmV0dXJuIHdyYXBwZXJDbG9uZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICAgICAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gd2hvc2UgcHJvdG90eXBlIGNoYWluIHNlcXVlbmNlIHdyYXBwZXJzIGluaGVyaXQgZnJvbS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUxvZGFzaCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIGBsb2Rhc2hgIHdyYXBwZXIgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGFpbkFsbF0gRW5hYmxlIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwpIHtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgICAgIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcbiAgICAgIHRoaXMuX19pbmRleF9fID0gMDtcbiAgICAgIHRoaXMuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICAgICAqIGVtYmVkZGVkIFJ1YnkgKEVSQikgYXMgd2VsbCBhcyBFUzIwMTUgdGVtcGxhdGUgc3RyaW5ncy4gQ2hhbmdlIHRoZVxuICAgICAqIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2VzY2FwZSc6IHJlRXNjYXBlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2ludGVycG9sYXRlJzogcmVJbnRlcnBvbGF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAqL1xuICAgICAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICAnXyc6IGxvZGFzaFxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBFbnN1cmUgd3JhcHBlcnMgYXJlIGluc3RhbmNlcyBvZiBgYmFzZUxvZGFzaGAuXG4gICAgbG9kYXNoLnByb3RvdHlwZSA9IGJhc2VMb2Rhc2gucHJvdG90eXBlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBsb2Rhc2g7XG5cbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9kYXNoV3JhcHBlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBsYXp5IHdyYXBwZXIgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGxhenkgZXZhbHVhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMYXp5V3JhcHBlcih2YWx1ZSkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2Rpcl9fID0gMTtcbiAgICAgIHRoaXMuX19maWx0ZXJlZF9fID0gZmFsc2U7XG4gICAgICB0aGlzLl9faXRlcmF0ZWVzX18gPSBbXTtcbiAgICAgIHRoaXMuX190YWtlQ291bnRfXyA9IE1BWF9BUlJBWV9MRU5HVEg7XG4gICAgICB0aGlzLl9fdmlld3NfXyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgbGF6eSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xvbmVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eUNsb25lKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzLl9fd3JhcHBlZF9fKTtcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIHJlc3VsdC5fX2Rpcl9fID0gdGhpcy5fX2Rpcl9fO1xuICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRoaXMuX19maWx0ZXJlZF9fO1xuICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18gPSBjb3B5QXJyYXkodGhpcy5fX2l0ZXJhdGVlc19fKTtcbiAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gdGhpcy5fX3Rha2VDb3VudF9fO1xuICAgICAgcmVzdWx0Ll9fdmlld3NfXyA9IGNvcHlBcnJheSh0aGlzLl9fdmlld3NfXyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIHRoZSBkaXJlY3Rpb24gb2YgbGF6eSBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgcmV2ZXJzZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVJldmVyc2UoKSB7XG4gICAgICBpZiAodGhpcy5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gPSAtMTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fICo9IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgdW53cmFwcGVkIHZhbHVlIGZyb20gaXRzIGxhenkgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlWYWx1ZSgpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuX193cmFwcGVkX18udmFsdWUoKSxcbiAgICAgICAgICBkaXIgPSB0aGlzLl9fZGlyX18sXG4gICAgICAgICAgaXNBcnIgPSBpc0FycmF5KGFycmF5KSxcbiAgICAgICAgICBpc1JpZ2h0ID0gZGlyIDwgMCxcbiAgICAgICAgICBhcnJMZW5ndGggPSBpc0FyciA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgdmlldyA9IGdldFZpZXcoMCwgYXJyTGVuZ3RoLCB0aGlzLl9fdmlld3NfXyksXG4gICAgICAgICAgc3RhcnQgPSB2aWV3LnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IHZpZXcuZW5kLFxuICAgICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgIGluZGV4ID0gaXNSaWdodCA/IGVuZCA6IChzdGFydCAtIDEpLFxuICAgICAgICAgIGl0ZXJhdGVlcyA9IHRoaXMuX19pdGVyYXRlZXNfXyxcbiAgICAgICAgICBpdGVyTGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgdGFrZUNvdW50ID0gbmF0aXZlTWluKGxlbmd0aCwgdGhpcy5fX3Rha2VDb3VudF9fKTtcblxuICAgICAgaWYgKCFpc0FyciB8fCAoIWlzUmlnaHQgJiYgYXJyTGVuZ3RoID09IGxlbmd0aCAmJiB0YWtlQ291bnQgPT0gbGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZShhcnJheSwgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKGxlbmd0aC0tICYmIHJlc0luZGV4IDwgdGFrZUNvdW50KSB7XG4gICAgICAgIGluZGV4ICs9IGRpcjtcblxuICAgICAgICB2YXIgaXRlckluZGV4ID0gLTEsXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICB3aGlsZSAoKytpdGVySW5kZXggPCBpdGVyTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBpdGVyYXRlZXNbaXRlckluZGV4XSxcbiAgICAgICAgICAgICAgaXRlcmF0ZWUgPSBkYXRhLml0ZXJhdGVlLFxuICAgICAgICAgICAgICB0eXBlID0gZGF0YS50eXBlLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICAgIGlmICh0eXBlID09IExBWllfTUFQX0ZMQUcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY29tcHV0ZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfRklMVEVSX0ZMQUcpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBgTGF6eVdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXp5V3JhcHBlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgICAgIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuICAgIEhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuICAgIEhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG4gICAgSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbiAgICBIYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuICAgIEhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgZGF0YS5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICAgIC0tdGhpcy5zaXplO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICAgICAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICsrdGhpcy5zaXplO1xuICAgICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAgICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAgICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICAgICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuICAgIE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGFkZFxuICAgICAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICAgICAqIEBhbGlhcyBwdXNoXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgICAgIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG4gICAgU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG4gICAgU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICAgICAgfVxuICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuICAgIFN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG4gICAgU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuICAgIFN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcbiAgICBTdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG4gICAgU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgICAgICkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2FtcGxlYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNhbXBsZShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtiYXNlUmFuZG9tKDAsIGxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2FtcGxlU2l6ZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNhbXBsZVNpemUoYXJyYXksIG4pIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpLCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gICAgICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZ2dyZWdhdGVzIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBvbiBgYWNjdW11bGF0b3JgIHdpdGgga2V5cyB0cmFuc2Zvcm1lZFxuICAgICAqIGJ5IGBpdGVyYXRlZWAgYW5kIHZhbHVlcyBzZXQgYnkgYHNldHRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBZ2dyZWdhdG9yKGNvbGxlY3Rpb24sIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICAgICAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAgICAgKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAgICAgKiB2YWx1ZSBjaGVja3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXQob2JqZWN0LCBwYXRocykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgc2tpcCA9IG9iamVjdCA9PSBudWxsO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gc2tpcCA/IHVuZGVmaW5lZCA6IGdldChvYmplY3QsIHBhdGhzW2luZGV4XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsYW1wYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHtcbiAgICAgIGlmIChudW1iZXIgPT09IG51bWJlcikge1xuICAgICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG51bWJlciA9IG51bWJlciA8PSB1cHBlciA/IG51bWJlciA6IHVwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyID49IGxvd2VyID8gbnVtYmVyIDogbG93ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICAgICAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogIDEgLSBEZWVwIGNsb25lXG4gICAgICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gICAgICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgICAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQ7XG4gICAgICB9XG4gICAgICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgICAgIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgICAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgICAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICAgICAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gICAgICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY29uZm9ybXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXMoc291cmNlKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc1RvYCB3aGljaCBhY2NlcHRzIGBwcm9wc2AgdG8gY2hlY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGNvbmZvcm1zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2xlbmd0aF0sXG4gICAgICAgICAgICBwcmVkaWNhdGUgPSBzb3VyY2Vba2V5XSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKCh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHx8ICFwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5kZWxheWAgYW5kIGBfLmRlZmVyYCB3aGljaCBhY2NlcHRzIGBhcmdzYFxuICAgICAqIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURlbGF5KGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kaWZmZXJlbmNlYCB3aXRob3V0IHN1cHBvcnRcbiAgICAgKiBmb3IgZXhjbHVkaW5nIG11bHRpcGxlIGFycmF5cyBvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICB2YWx1ZXNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhbHVlcyA9IGFycmF5TWFwKHZhbHVlcywgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodmFsdWVzLmxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcyA9IG5ldyBTZXRDYWNoZSh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID09IG51bGwgPyB2YWx1ZSA6IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIHZhciB2YWx1ZXNJbmRleCA9IHZhbHVlc0xlbmd0aDtcbiAgICAgICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1t2YWx1ZXNJbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHZhbHVlcywgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICovXG4gICAgdmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICovXG4gICAgdmFyIGJhc2VFYWNoUmlnaHQgPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duUmlnaHQsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZXZlcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSAhIXByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5tYXhgIGFuZCBgXy5taW5gIHdoaWNoIGFjY2VwdHMgYVxuICAgICAqIGBjb21wYXJhdG9yYCB0byBkZXRlcm1pbmUgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciB1c2VkIHRvIGNvbXBhcmUgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRXh0cmVtdW0oYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT0gbnVsbCAmJiAoY29tcHV0ZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IChjdXJyZW50ID09PSBjdXJyZW50ICYmICFpc1N5bWJvbChjdXJyZW50KSlcbiAgICAgICAgICAgICAgOiBjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHZhciBjb21wdXRlZCA9IGN1cnJlbnQsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbGxgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgc3RhcnQgPSB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IGxlbmd0aCkgPyBsZW5ndGggOiB0b0ludGVnZXIoZW5kKTtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbmQgPSBzdGFydCA+IGVuZCA/IDAgOiB0b0xlbmd0aChlbmQpO1xuICAgICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIGFycmF5W3N0YXJ0KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICAgICAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAgICAgKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VGb3JgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllc1xuICAgICAqIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvclJpZ2h0ID0gY3JlYXRlQmFzZUZvcih0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25SaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yUmlnaHQob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZnVuY3Rpb25zYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mXG4gICAgICogYG9iamVjdGAgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZmlsdGVyZWQgZnJvbSBgcHJvcHNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZmlsdGVyLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZ1bmN0aW9ucyhvYmplY3QsIHByb3BzKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaWx0ZXIocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvYmplY3Rba2V5XSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICAgICAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICAgICAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gICAgICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgICAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ndGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR3QodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPiBvdGhlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSGFzKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5SYW5nZWAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG51bWJlcmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gbnVtYmVyID49IG5hdGl2ZU1pbihzdGFydCwgZW5kKSAmJiBudW1iZXIgPCBuYXRpdmVNYXgoc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmludGVyc2VjdGlvbmAsIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB0aGF0IGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5cyBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBzaGFyZWQgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnRlcnNlY3Rpb24oYXJyYXlzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluY2x1ZGVzID0gY29tcGFyYXRvciA/IGFycmF5SW5jbHVkZXNXaXRoIDogYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheXNbMF0ubGVuZ3RoLFxuICAgICAgICAgIG90aExlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGgsXG4gICAgICAgICAgY2FjaGVzID0gQXJyYXkob3RoTGVuZ3RoKSxcbiAgICAgICAgICBtYXhMZW5ndGggPSBJbmZpbml0eSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKG90aEluZGV4LS0pIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW290aEluZGV4XTtcbiAgICAgICAgaWYgKG90aEluZGV4ICYmIGl0ZXJhdGVlKSB7XG4gICAgICAgICAgYXJyYXkgPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4TGVuZ3RoID0gbmF0aXZlTWluKGFycmF5Lmxlbmd0aCwgbWF4TGVuZ3RoKTtcbiAgICAgICAgY2FjaGVzW290aEluZGV4XSA9ICFjb21wYXJhdG9yICYmIChpdGVyYXRlZSB8fCAobGVuZ3RoID49IDEyMCAmJiBhcnJheS5sZW5ndGggPj0gMTIwKSlcbiAgICAgICAgICA/IG5ldyBTZXRDYWNoZShvdGhJbmRleCAmJiBhcnJheSlcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGFycmF5ID0gYXJyYXlzWzBdO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBzZWVuID0gY2FjaGVzWzBdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIHJlc3VsdC5sZW5ndGggPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoIShzZWVuXG4gICAgICAgICAgICAgID8gY2FjaGVIYXMoc2VlbiwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgIDogaW5jbHVkZXMocmVzdWx0LCBjb21wdXRlZCwgY29tcGFyYXRvcilcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICBvdGhJbmRleCA9IG90aExlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoLS1vdGhJbmRleCkge1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzW290aEluZGV4XTtcbiAgICAgICAgICAgIGlmICghKGNhY2hlXG4gICAgICAgICAgICAgICAgICA/IGNhY2hlSGFzKGNhY2hlLCBjb21wdXRlZClcbiAgICAgICAgICAgICAgICAgIDogaW5jbHVkZXMoYXJyYXlzW290aEluZGV4XSwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbnZlcnRgIGFuZCBgXy5pbnZlcnRCeWAgd2hpY2ggaW52ZXJ0c1xuICAgICAqIGBvYmplY3RgIHdpdGggdmFsdWVzIHRyYW5zZm9ybWVkIGJ5IGBpdGVyYXRlZWAgYW5kIHNldCBieSBgc2V0dGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnZlcnRlcihvYmplY3QsIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgaXRlcmF0ZWUodmFsdWUpLCBrZXksIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbnZva2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIG1ldGhvZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncykge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHZhciBmdW5jID0gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFwcGx5KGZ1bmMsIG9iamVjdCwgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJyYXlCdWZmZXJgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJyYXlCdWZmZXJUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNEYXRlYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBkYXRlIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0RhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGRhdGVUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICAgICAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICAgICAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgICAgIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICAgICAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgICAgIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgICAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgICAgIG9iaklzT2JqID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICAgICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gICAgICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICAgICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gICAgICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNSZWdFeHBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1JlZ0V4cCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gcmVnZXhwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgICAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgICAgIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgICAgIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICAgICAgfVxuICAgICAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5sdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTHQodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPCBvdGhlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICAgICAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICAgICAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgICAgIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubnRoYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VOdGgoYXJyYXksIG4pIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuICs9IG4gPCAwID8gbGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiBpc0luZGV4KG4sIGxlbmd0aCkgPyBhcnJheVtuXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5vcmRlckJ5YCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMubGVuZ3RoID8gaXRlcmF0ZWVzIDogW2lkZW50aXR5XSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgICAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBoYXNJbihvYmplY3QsIHBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSxcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICAgICAgYmFzZVNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEFsbEJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAgICogc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4T2YgPSBjb21wYXJhdG9yID8gYmFzZUluZGV4T2ZXaXRoIDogYmFzZUluZGV4T2YsXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIHNlZW4gPSBhcnJheTtcblxuICAgICAgaWYgKGFycmF5ID09PSB2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzID0gY29weUFycmF5KHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2VlbiA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBmcm9tSW5kZXggPSAwLFxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbUluZGV4ID0gaW5kZXhPZihzZWVuLCBjb21wdXRlZCwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSkgPiAtMSkge1xuICAgICAgICAgIGlmIChzZWVuICE9PSBhcnJheSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoc2VlbiwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGZyb21JbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIGluZGV4ZXMgb3IgY2FwdHVyaW5nIHRoZSByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGluZGV4ZXMubGVuZ3RoIDogMCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBpZiAobGVuZ3RoID09IGxhc3RJbmRleCB8fCBpbmRleCAhPT0gcHJldmlvdXMpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXMgPSBpbmRleDtcbiAgICAgICAgICBpZiAoaXNJbmRleChpbmRleCkpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VVbnNldChhcnJheSwgaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciByZXR1cm5pbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93ZXIgVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikge1xuICAgICAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5nZWAgYW5kIGBfLnJhbmdlUmlnaHRgIHdoaWNoIGRvZXNuJ3RcbiAgICAgKiBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlcGVhdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZXBlYXQoc3RyaW5nLCBuKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICBpZiAoIXN0cmluZyB8fCBuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gTGV2ZXJhZ2UgdGhlIGV4cG9uZW50aWF0aW9uIGJ5IHNxdWFyaW5nIGFsZ29yaXRobSBmb3IgYSBmYXN0ZXIgcmVwZWF0LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V4cG9uZW50aWF0aW9uX2J5X3NxdWFyaW5nIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuICUgMikge1xuICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG5hdGl2ZUZsb29yKG4gLyAyKTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChuKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zYW1wbGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTYW1wbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGFycmF5U2FtcGxlKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlU2l6ZWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuKSB7XG4gICAgICB2YXIgYXJyYXkgPSB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoYXJyYXksIGJhc2VDbGFtcChuLCAwLCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gICAgICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldERhdGFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldERhdGEgPSAhbWV0YU1hcCA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgZGF0YSkge1xuICAgICAgbWV0YU1hcC5zZXQoZnVuYywgZGF0YSk7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcbiAgICAgIHN0YXJ0ID4+Pj0gMDtcblxuICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvbWVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4YCB3aGljaFxuICAgICAqIHBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvZiBgYXJyYXlgIHRvIGRldGVybWluZSB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA9PSBudWxsID8gbG93IDogYXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09PSB2YWx1ZSAmJiBoaWdoIDw9IEhBTEZfTUFYX0FSUkFZX0xFTkdUSCkge1xuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDEsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gYXJyYXlbbWlkXTtcblxuICAgICAgICAgIGlmIChjb21wdXRlZCAhPT0gbnVsbCAmJiAhaXNTeW1ib2woY29tcHV0ZWQpICYmXG4gICAgICAgICAgICAgIChyZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKSkpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWdoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaWRlbnRpdHksIHJldEhpZ2hlc3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4QnlgIGFuZCBgXy5zb3J0ZWRMYXN0SW5kZXhCeWBcbiAgICAgKiB3aGljaCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGVcbiAgICAgKiB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YWx1ZSA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHZhbElzTmFOID0gdmFsdWUgIT09IHZhbHVlLFxuICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpLFxuICAgICAgICAgIHZhbElzVW5kZWZpbmVkID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IG5hdGl2ZUZsb29yKChsb3cgKyBoaWdoKSAvIDIpLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZShhcnJheVttaWRdKSxcbiAgICAgICAgICAgIG90aElzRGVmaW5lZCA9IGNvbXB1dGVkICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhJc051bGwgPSBjb21wdXRlZCA9PT0gbnVsbCxcbiAgICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkLFxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChjb21wdXRlZCk7XG5cbiAgICAgICAgaWYgKHZhbElzTmFOKSB7XG4gICAgICAgICAgdmFyIHNldExvdyA9IHJldEhpZ2hlc3QgfHwgb3RoSXNSZWZsZXhpdmU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNVbmRlZmluZWQpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiAocmV0SGlnaGVzdCB8fCBvdGhJc0RlZmluZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzTnVsbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNOdWxsKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1N5bWJvbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAhb3RoSXNOdWxsICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc1N5bWJvbCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3RoSXNOdWxsIHx8IG90aElzU3ltYm9sKSB7XG4gICAgICAgICAgc2V0TG93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TG93ID0gcmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldExvdykge1xuICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1pbihoaWdoLCBNQVhfQVJSQVlfSU5ERVgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZFVuaXFgIGFuZCBgXy5zb3J0ZWRVbmlxQnlgIHdpdGhvdXRcbiAgICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIGlmICghaW5kZXggfHwgIWVxKGNvbXB1dGVkLCBzZWVuKSkge1xuICAgICAgICAgIHZhciBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9OdW1iZXJgIHdoaWNoIGRvZXNuJ3QgZW5zdXJlIGNvcnJlY3RcbiAgICAgKiBjb252ZXJzaW9ucyBvZiBiaW5hcnksIGhleGFkZWNpbWFsLCBvciBvY3RhbCBzdHJpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTkFOO1xuICAgICAgfVxuICAgICAgcmV0dXJuICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAgICAgKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgc2VlbiA9IHJlc3VsdDtcblxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgIHZhciBzZXQgPSBpdGVyYXRlZSA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgICAgICBpZiAoc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBzZWVuID0gbmV3IFNldENhY2hlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bnNldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51cGRhdGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHJldHVybiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdXBkYXRlcihiYXNlR2V0KG9iamVjdCwgcGF0aCkpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZHJvcFdoaWxlYCBhbmQgYF8udGFrZVdoaWxlYFxuICAgICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRHJvcF0gU3BlY2lmeSBkcm9wcGluZyBlbGVtZW50cyBpbnN0ZWFkIG9mIHRha2luZyB0aGVtLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgaXNEcm9wLCBmcm9tUmlnaHQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkgJiZcbiAgICAgICAgcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge31cblxuICAgICAgcmV0dXJuIGlzRHJvcFxuICAgICAgICA/IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IDAgOiBpbmRleCksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiBsZW5ndGgpKVxuICAgICAgICA6IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IDApLCAoZnJvbVJpZ2h0ID8gbGVuZ3RoIDogaW5kZXgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgd3JhcHBlclZhbHVlYCB3aGljaCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcbiAgICAgKiBwZXJmb3JtaW5nIGEgc2VxdWVuY2Ugb2YgYWN0aW9ucyBvbiB0aGUgdW53cmFwcGVkIGB2YWx1ZWAsIHdoZXJlIGVhY2hcbiAgICAgKiBzdWNjZXNzaXZlIGFjdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFjdGlvbnMgQWN0aW9ucyB0byBwZXJmb3JtIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdyYXBwZXJWYWx1ZSh2YWx1ZSwgYWN0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC52YWx1ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKGFjdGlvbnMsIGZ1bmN0aW9uKHJlc3VsdCwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb24uZnVuYy5hcHBseShhY3Rpb24udGhpc0FyZywgYXJyYXlQdXNoKFtyZXN1bHRdLCBhY3Rpb24uYXJncykpO1xuICAgICAgfSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ueG9yYCwgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlWG9yKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VVbmlxKGFycmF5c1swXSkgOiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tpbmRleF0sXG4gICAgICAgICAgICBvdGhJbmRleCA9IC0xO1xuXG4gICAgICAgIHdoaWxlICgrK290aEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG90aEluZGV4ICE9IGluZGV4KSB7XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gYmFzZURpZmZlcmVuY2UocmVzdWx0W2luZGV4XSB8fCBhcnJheSwgYXJyYXlzW290aEluZGV4XSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKHJlc3VsdCwgMSksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uemlwT2JqZWN0YCB3aGljaCBhc3NpZ25zIHZhbHVlcyB1c2luZyBgYXNzaWduRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25GdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVppcE9iamVjdChwcm9wcywgdmFsdWVzLCBhc3NpZ25GdW5jKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgdmFsc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGluZGV4IDwgdmFsc0xlbmd0aCA/IHZhbHVlc1tpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGFzc2lnbkZ1bmMocmVzdWx0LCBwcm9wc1tpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhbiBlbXB0eSBhcnJheSBpZiBpdCdzIG5vdCBhbiBhcnJheSBsaWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgYGJhc2VSZXN0YCBhbGlhcyB3aGljaCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBgaWRlbnRpdHlgIGJ5IG1vZHVsZVxuICAgICAqIHJlcGxhY2VtZW50IHBsdWdpbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHZhciBjYXN0UmVzdCA9IGJhc2VSZXN0O1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdFNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gICAgICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgY2xlYXJUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vY2xlYXJUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8T2JqZWN0fSBpZCBUaGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3Qgb2YgdGhlIHRpbWVyIHRvIGNsZWFyLlxuICAgICAqL1xuICAgIHZhciBjbGVhclRpbWVvdXQgPSBjdHhDbGVhclRpbWVvdXQgfHwgZnVuY3Rpb24oaWQpIHtcbiAgICAgIHJldHVybiByb290LmNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICBidWZmZXIuY29weShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gICAgICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gICAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gICAgICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gICAgICpcbiAgICAgKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICAgICAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAgICAgKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcbiAgICAgICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXIgPT0gJ2Rlc2MnID8gLTEgOiAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAgICAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgICAgIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gICAgICogcGxhY2Vob2xkZXJzLCBhbmQgcHJvdmlkZWQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZWZ0TGVuZ3RoICsgcmFuZ2VMZW5ndGgpLFxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChyYW5nZUxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXgrK10gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBjb21wb3NlQXJnc2AgZXhjZXB0IHRoYXQgdGhlIGFyZ3VtZW50cyBjb21wb3NpdGlvblxuICAgICAqIGlzIHRhaWxvcmVkIGZvciBgXy5wYXJ0aWFsUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzSW5kZXggPSAtMSxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgcmlnaHRJbmRleCA9IC0xLFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShyYW5nZUxlbmd0aCArIHJpZ2h0TGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IHJhbmdlTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IGFyZ3NJbmRleDtcbiAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgcmlnaHRJbmRleF0gPSBwYXJ0aWFsc1tyaWdodEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbb2Zmc2V0ICsgaG9sZGVyc1tob2xkZXJzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICAgICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgICAgIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05ldykge1xuICAgICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5ncm91cEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGFjY3VtdWxhdG9yIG9iamVjdCBpbml0aWFsaXplci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyLCBpbml0aWFsaXplcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5QWdncmVnYXRvciA6IGJhc2VBZ2dyZWdhdG9yLFxuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBpbml0aWFsaXplciA/IGluaXRpYWxpemVyKCkgOiB7fTtcblxuICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBzZXR0ZXIsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYWNjdW11bGF0b3IpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5sb3dlckZpcnN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBTdHJpbmdgIGNhc2UgbWV0aG9kIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdChtZXRob2ROYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHZhciBjaHIgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgICAgIHZhciB0cmFpbGluZyA9IHN0clN5bWJvbHNcbiAgICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxuICAgICAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgICAgIHJldHVybiBjaHJbbWV0aG9kTmFtZV0oKSArIHRyYWlsaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5jYW1lbENhc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBhcnJheVJlZHVjZSh3b3JkcyhkZWJ1cnIoc3RyaW5nKS5yZXBsYWNlKHJlQXBvcywgJycpKSwgY2FsbGJhY2ssICcnKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gaW5zdGFuY2Ugb2YgYEN0b3JgIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3RvcihDdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFVzZSBhIGBzd2l0Y2hgIHN0YXRlbWVudCB0byB3b3JrIHdpdGggY2xhc3MgY29uc3RydWN0b3JzLiBTZWVcbiAgICAgICAgLy8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQ3RvcjtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICBjYXNlIDc6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuXG4gICAgICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBlbmFibGUgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJpdHkgVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KSB7XG4gICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob2xkZXJzID0gKGxlbmd0aCA8IDMgJiYgYXJnc1swXSAhPT0gcGxhY2Vob2xkZXIgJiYgYXJnc1tsZW5ndGggLSAxXSAhPT0gcGxhY2Vob2xkZXIpXG4gICAgICAgICAgPyBbXVxuICAgICAgICAgIDogcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuXG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFyZ3MsIGhvbGRlcnMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSAtIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUgPyBjb2xsZWN0aW9uW2luZGV4XSA6IGluZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZsb3dgIG9yIGBfLmZsb3dSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsb3cgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihmdW5jcykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gZnVuY3MubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwcmVyZXEgPSBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS50aHJ1O1xuXG4gICAgICAgIGlmIChmcm9tUmlnaHQpIHtcbiAgICAgICAgICBmdW5jcy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlcmVxICYmICF3cmFwcGVyICYmIGdldEZ1bmNOYW1lKGZ1bmMpID09ICd3cmFwcGVyJykge1xuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBuZXcgTG9kYXNoV3JhcHBlcihbXSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gd3JhcHBlciA/IGluZGV4IDogbGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGZ1bmMgPSBmdW5jc1tpbmRleF07XG5cbiAgICAgICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICAgICAgZGF0YSA9IGZ1bmNOYW1lID09ICd3cmFwcGVyJyA/IGdldERhdGEoZnVuYykgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoZGF0YSAmJiBpc0xhemlhYmxlKGRhdGFbMF0pICYmXG4gICAgICAgICAgICAgICAgZGF0YVsxXSA9PSAoV1JBUF9BUllfRkxBRyB8IFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9SRUFSR19GTEFHKSAmJlxuICAgICAgICAgICAgICAgICFkYXRhWzRdLmxlbmd0aCAmJiBkYXRhWzldID09IDFcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlcltnZXRGdW5jTmFtZShkYXRhWzBdKV0uYXBwbHkod3JhcHBlciwgZGF0YVszXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSAoZnVuYy5sZW5ndGggPT0gMSAmJiBpc0xhemlhYmxlKGZ1bmMpKVxuICAgICAgICAgICAgICA/IHdyYXBwZXJbZnVuY05hbWVdKClcbiAgICAgICAgICAgICAgOiB3cmFwcGVyLnRocnUoZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuXG4gICAgICAgICAgaWYgKHdyYXBwZXIgJiYgYXJncy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIucGxhbnQodmFsdWUpLnZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGxlbmd0aCA/IGZ1bmNzW2luZGV4XS5hcHBseSh0aGlzLCBhcmdzKSA6IHZhbHVlO1xuXG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNzW2luZGV4XS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AsIHBhcnRpYWwgYXBwbGljYXRpb24sIGFuZCBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzUmlnaHRdIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkXG4gICAgICogIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNSaWdodF0gVGhlIGBwYXJ0aWFsc1JpZ2h0YCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUh5YnJpZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBXUkFQX0FSWV9GTEFHLFxuICAgICAgICAgIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHLFxuICAgICAgICAgIGlzQ3VycmllZCA9IGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSxcbiAgICAgICAgICBpc0ZsaXAgPSBiaXRtYXNrICYgV1JBUF9GTElQX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDdXJyaWVkKSB7XG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpLFxuICAgICAgICAgICAgICBob2xkZXJzQ291bnQgPSBjb3VudEhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFscykge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHNSaWdodCkge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggLT0gaG9sZGVyc0NvdW50O1xuICAgICAgICBpZiAoaXNDdXJyaWVkICYmIGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgdmFyIG5ld0hvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHRoaXNBcmcsXG4gICAgICAgICAgICBhcmdzLCBuZXdIb2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkgLSBsZW5ndGhcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLFxuICAgICAgICAgICAgZm4gPSBpc0JpbmRLZXkgPyB0aGlzQmluZGluZ1tmdW5jXSA6IGZ1bmM7XG5cbiAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICAgIGlmIChhcmdQb3MpIHtcbiAgICAgICAgICBhcmdzID0gcmVvcmRlcihhcmdzLCBhcmdQb3MpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcCAmJiBsZW5ndGggPiAxKSB7XG4gICAgICAgICAgYXJncy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJ5ICYmIGFyeSA8IGxlbmd0aCkge1xuICAgICAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpIHtcbiAgICAgICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3Rvcihmbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmludmVydEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRvSXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgaXRlcmF0ZWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludmVydGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmVydGVyKHNldHRlciwgdG9JdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZlcnRlcihvYmplY3QsIHNldHRlciwgdG9JdGVyYXRlZShpdGVyYXRlZSksIHt9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSB1c2VkIGZvciBgdW5kZWZpbmVkYCBhcmd1bWVudHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVNYXRoT3BlcmF0aW9uKG9wZXJhdG9yLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9TdHJpbmcob3RoZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBvdGhlciA9IGJhc2VUb051bWJlcihvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ub3ZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBvdmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU92ZXIoYXJyYXlGdW5jKSB7XG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oaXRlcmF0ZWVzKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcbiAgICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICB2YXIgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGFycmF5RnVuYyhpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgIGJhc2VkIG9uIGBsZW5ndGhgLiBUaGUgYGNoYXJzYCBzdHJpbmdcbiAgICAgKiBpcyB0cnVuY2F0ZWQgaWYgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGV4Y2VlZHMgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWRkaW5nKGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIGNoYXJzID0gY2hhcnMgPT09IHVuZGVmaW5lZCA/ICcgJyA6IGJhc2VUb1N0cmluZyhjaGFycyk7XG5cbiAgICAgIHZhciBjaGFyc0xlbmd0aCA9IGNoYXJzLmxlbmd0aDtcbiAgICAgIGlmIChjaGFyc0xlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJzTGVuZ3RoID8gYmFzZVJlcGVhdChjaGFycywgbGVuZ3RoKSA6IGNoYXJzO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VSZXBlYXQoY2hhcnMsIG5hdGl2ZUNlaWwobGVuZ3RoIC8gc3RyaW5nU2l6ZShjaGFycykpKTtcbiAgICAgIHJldHVybiBoYXNVbmljb2RlKGNoYXJzKVxuICAgICAgICA/IGNhc3RTbGljZShzdHJpbmdUb0FycmF5KHJlc3VsdCksIDAsIGxlbmd0aCkuam9pbignJylcbiAgICAgICAgOiByZXN1bHQuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nXG4gICAgICogb2YgYHRoaXNBcmdgIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCksXG4gICAgICAgICAgICBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG5cbiAgICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzWysrYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJhbmdlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgICAgaWYgKHN0ZXAgJiYgdHlwZW9mIHN0ZXAgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyAoc3RhcnQgPCBlbmQgPyAxIDogLTEpIDogdG9GaW5pdGUoc3RlcCk7XG4gICAgICAgIHJldHVybiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSByZWxhdGlvbmFsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlbGF0aW9uYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24ob3BlcmF0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnICYmIHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBvdGhlciA9IHRvTnVtYmVyKG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGNvbnRpbnVlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgYGZ1bmNgIHdyYXBwZXIuXG4gICAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlY3VycnkoZnVuYywgYml0bWFzaywgd3JhcEZ1bmMsIHBsYWNlaG9sZGVyLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNDdXJyeSA9IGJpdG1hc2sgJiBXUkFQX0NVUlJZX0ZMQUcsXG4gICAgICAgICAgbmV3SG9sZGVycyA9IGlzQ3VycnkgPyBob2xkZXJzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBob2xkZXJzLFxuICAgICAgICAgIG5ld1BhcnRpYWxzID0gaXNDdXJyeSA/IHBhcnRpYWxzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogcGFydGlhbHM7XG5cbiAgICAgIGJpdG1hc2sgfD0gKGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfRkxBRyA6IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgIGJpdG1hc2sgJj0gfihpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgOiBXUkFQX1BBUlRJQUxfRkxBRyk7XG5cbiAgICAgIGlmICghKGJpdG1hc2sgJiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgbmV3UGFydGlhbHMsIG5ld0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsXG4gICAgICAgIG5ld0hvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gd3JhcEZ1bmMuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIGlmIChpc0xhemlhYmxlKGZ1bmMpKSB7XG4gICAgICAgIHNldERhdGEocmVzdWx0LCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhyZXN1bHQsIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLnJvdW5kYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBNYXRoYCBtZXRob2QgdG8gdXNlIHdoZW4gcm91bmRpbmcuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUm91bmQobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBNYXRoW21ldGhvZE5hbWVdO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG51bWJlciwgcHJlY2lzaW9uKSB7XG4gICAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PSBudWxsID8gMCA6IG5hdGl2ZU1pbih0b0ludGVnZXIocHJlY2lzaW9uKSwgMjkyKTtcbiAgICAgICAgaWYgKHByZWNpc2lvbiAmJiBuYXRpdmVJc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgICAgLy8gU2hpZnQgd2l0aCBleHBvbmVudGlhbCBub3RhdGlvbiB0byBhdm9pZCBmbG9hdGluZy1wb2ludCBpc3N1ZXMuXG4gICAgICAgICAgLy8gU2VlIFtNRE5dKGh0dHBzOi8vbWRuLmlvL3JvdW5kI0V4YW1wbGVzKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHZhciBwYWlyID0gKHRvU3RyaW5nKG51bWJlcikgKyAnZScpLnNwbGl0KCdlJyksXG4gICAgICAgICAgICAgIHZhbHVlID0gZnVuYyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdICsgcHJlY2lzaW9uKSk7XG5cbiAgICAgICAgICBwYWlyID0gKHRvU3RyaW5nKHZhbHVlKSArICdlJykuc3BsaXQoJ2UnKTtcbiAgICAgICAgICByZXR1cm4gKyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdIC0gcHJlY2lzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMobnVtYmVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gICAgICovXG4gICAgdmFyIGNyZWF0ZVNldCA9ICEoU2V0ICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV0pID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy50b1BhaXJzYCBvciBgXy50b1BhaXJzSW5gIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhaXJzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVRvUGFpcnMoa2V5c0Z1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgICAgICBpZiAodGFnID09IG1hcFRhZykge1xuICAgICAgICAgIHJldHVybiBtYXBUb0FycmF5KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VG9QYWlycyhvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlVG9QYWlycyhvYmplY3QsIGtleXNGdW5jKG9iamVjdCkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYCB3aXRoIG9wdGlvbmFsXG4gICAgICogYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogICAgMSAtIGBfLmJpbmRgXG4gICAgICogICAgMiAtIGBfLmJpbmRLZXlgXG4gICAgICogICAgNCAtIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBvZiBhIGJvdW5kIGZ1bmN0aW9uXG4gICAgICogICAgOCAtIGBfLmN1cnJ5YFxuICAgICAqICAgMTYgLSBgXy5jdXJyeVJpZ2h0YFxuICAgICAqICAgMzIgLSBgXy5wYXJ0aWFsYFxuICAgICAqICAgNjQgLSBgXy5wYXJ0aWFsUmlnaHRgXG4gICAgICogIDEyOCAtIGBfLnJlYXJnYFxuICAgICAqICAyNTYgLSBgXy5hcnlgXG4gICAgICogIDUxMiAtIGBfLmZsaXBgXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRztcbiAgICAgIGlmICghaXNCaW5kS2V5ICYmIHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhcnRpYWxzID8gcGFydGlhbHMubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJ5ID0gYXJ5ID09PSB1bmRlZmluZWQgPyBhcnkgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKGFyeSksIDApO1xuICAgICAgYXJpdHkgPSBhcml0eSA9PT0gdW5kZWZpbmVkID8gYXJpdHkgOiB0b0ludGVnZXIoYXJpdHkpO1xuICAgICAgbGVuZ3RoIC09IGhvbGRlcnMgPyBob2xkZXJzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmIChiaXRtYXNrICYgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzUmlnaHQgPSBwYXJ0aWFscyxcbiAgICAgICAgICAgIGhvbGRlcnNSaWdodCA9IGhvbGRlcnM7XG5cbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBnZXREYXRhKGZ1bmMpO1xuXG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCxcbiAgICAgICAgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBtZXJnZURhdGEobmV3RGF0YSwgZGF0YSk7XG4gICAgICB9XG4gICAgICBmdW5jID0gbmV3RGF0YVswXTtcbiAgICAgIGJpdG1hc2sgPSBuZXdEYXRhWzFdO1xuICAgICAgdGhpc0FyZyA9IG5ld0RhdGFbMl07XG4gICAgICBwYXJ0aWFscyA9IG5ld0RhdGFbM107XG4gICAgICBob2xkZXJzID0gbmV3RGF0YVs0XTtcbiAgICAgIGFyaXR5ID0gbmV3RGF0YVs5XSA9IG5ld0RhdGFbOV0gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IChpc0JpbmRLZXkgPyAwIDogZnVuYy5sZW5ndGgpXG4gICAgICAgIDogbmF0aXZlTWF4KG5ld0RhdGFbOV0gLSBsZW5ndGgsIDApO1xuXG4gICAgICBpZiAoIWFyaXR5ICYmIGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKTtcbiAgICAgIH1cbiAgICAgIGlmICghYml0bWFzayB8fCBiaXRtYXNrID09IFdSQVBfQklORF9GTEFHKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpO1xuICAgICAgfSBlbHNlIGlmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRyB8fCBiaXRtYXNrID09IFdSQVBfQ1VSUllfUklHSFRfRkxBRykge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSk7XG4gICAgICB9IGVsc2UgaWYgKChiaXRtYXNrID09IFdSQVBfUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKFdSQVBfQklORF9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcpKSAmJiAhaG9sZGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVIeWJyaWQuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZXR0ZXIgPSBkYXRhID8gYmFzZVNldERhdGEgOiBzZXREYXRhO1xuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhzZXR0ZXIocmVzdWx0LCBuZXdEYXRhKSwgZnVuYywgYml0bWFzayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c2AgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25JbmAgdXNlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzXG4gICAgICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcbiAgICAgKiB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgIHJldHVybiBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzRGVlcGAgdG8gY3VzdG9taXplIGl0cyBgXy5tZXJnZWAgdXNlIHRvIG1lcmdlIHNvdXJjZVxuICAgICAqIG9iamVjdHMgaW50byBkZXN0aW5hdGlvbiBvYmplY3RzIHRoYXQgYXJlIHBhc3NlZCB0aHJ1LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgcGFyZW50IG9iamVjdCBvZiBgc3JjVmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykge1xuICAgICAgaWYgKGlzT2JqZWN0KG9ialZhbHVlKSAmJiBpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgb2JqVmFsdWUpO1xuICAgICAgICBiYXNlTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCB1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLm9taXRgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uY2xvbmVEZWVwYCB1c2UgdG8gb25seSBjbG9uZSBwbGFpblxuICAgICAqIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bmNsb25lZCB2YWx1ZSBvciBgdW5kZWZpbmVkYCB0byBkZWZlciBjbG9uaW5nIHRvIGBfLmNsb25lRGVlcGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tT21pdENsb25lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gICAgICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgICAgIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gICAgICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgICAgIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gICAgICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICAgICAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgICAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgICAgIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICAgICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAgICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZCwgZmxhdHRlbiksIGZ1bmMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAgICAgKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgZ2V0RGF0YSA9ICFtZXRhTWFwID8gbm9vcCA6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHJldHVybiBtZXRhTWFwLmdldChmdW5jKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmFtZSBvZiBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RnVuY05hbWUoZnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IChmdW5jLm5hbWUgKyAnJyksXG4gICAgICAgICAgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0XSxcbiAgICAgICAgICBsZW5ndGggPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYWxOYW1lcywgcmVzdWx0KSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sXG4gICAgICAgICAgICBvdGhlckZ1bmMgPSBkYXRhLmZ1bmM7XG4gICAgICAgIGlmIChvdGhlckZ1bmMgPT0gbnVsbCB8fCBvdGhlckZ1bmMgPT0gZnVuYykge1xuICAgICAgICAgIHJldHVybiBkYXRhLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXJndW1lbnQgcGxhY2Vob2xkZXIgdmFsdWUgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SG9sZGVyKGZ1bmMpIHtcbiAgICAgIHZhciBvYmplY3QgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaCwgJ3BsYWNlaG9sZGVyJykgPyBsb2Rhc2ggOiBmdW5jO1xuICAgICAgcmV0dXJuIG9iamVjdC5wbGFjZWhvbGRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBcIml0ZXJhdGVlXCIgZnVuY3Rpb24uIElmIGBfLml0ZXJhdGVlYCBpcyBjdXN0b21pemVkLFxuICAgICAqIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGJhc2VJdGVyYXRlZWAuXG4gICAgICogSWYgYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgdGhlIGNob3NlbiBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGggdGhlbSBhbmRcbiAgICAgKiBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIHRoZSBjcmVhdGVkIGl0ZXJhdGVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2hvc2VuIGZ1bmN0aW9uIG9yIGl0cyByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SXRlcmF0ZWUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoLml0ZXJhdGVlIHx8IGl0ZXJhdGVlO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSBpdGVyYXRlZSA/IGJhc2VJdGVyYXRlZSA6IHJlc3VsdDtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gcmVzdWx0KGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICAgICAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgICAgIDogZGF0YS5tYXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gICAgICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICBpZiAodW5tYXNrZWQpIHtcbiAgICAgICAgaWYgKGlzT3duKSB7XG4gICAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAgICAgKi9cbiAgICB2YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAgICAgKi9cbiAgICB2YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHdoaWxlIChvYmplY3QpIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICAgICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgdmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbiAgICAvLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG4gICAgaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgICAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAgICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgICAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gICAgICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmlldywgYXBwbHlpbmcgYW55IGB0cmFuc2Zvcm1zYCB0byB0aGUgYHN0YXJ0YCBhbmQgYGVuZGAgcG9zaXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm1zIFRoZSB0cmFuc2Zvcm1hdGlvbnMgdG8gYXBwbHkgdG8gdGhlIHZpZXcuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgYHN0YXJ0YCBhbmQgYGVuZGBcbiAgICAgKiAgcG9zaXRpb25zIG9mIHRoZSB2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFZpZXcoc3RhcnQsIGVuZCwgdHJhbnNmb3Jtcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdHJhbnNmb3Jtc1tpbmRleF0sXG4gICAgICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnZHJvcCc6ICAgICAgc3RhcnQgKz0gc2l6ZTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZHJvcFJpZ2h0JzogZW5kIC09IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Rha2UnOiAgICAgIGVuZCA9IG5hdGl2ZU1pbihlbmQsIHN0YXJ0ICsgc2l6ZSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Rha2VSaWdodCc6IHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0LCBlbmQgLSBzaXplKTsgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7ICdzdGFydCc6IHN0YXJ0LCAnZW5kJzogZW5kIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgd3JhcHBlciBkZXRhaWxzIGZyb20gdGhlIGBzb3VyY2VgIGJvZHkgY29tbWVudC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3cmFwcGVyIGRldGFpbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0V3JhcERldGFpbHMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBzb3VyY2UubWF0Y2gocmVXcmFwRGV0YWlscyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXS5zcGxpdChyZVNwbGl0RGV0YWlscykgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgICAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gICAgICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgICAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgICAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICAgICAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICAgICAgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICAgICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHdyYXBwZXIgYGRldGFpbHNgIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBgc291cmNlYCBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gbW9kaWZ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBpbnNlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc291cmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgZGV0YWlscykge1xuICAgICAgdmFyIGxlbmd0aCA9IGRldGFpbHMubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgZGV0YWlsc1tsYXN0SW5kZXhdID0gKGxlbmd0aCA+IDEgPyAnJiAnIDogJycpICsgZGV0YWlsc1tsYXN0SW5kZXhdO1xuICAgICAgZGV0YWlscyA9IGRldGFpbHMuam9pbihsZW5ndGggPiAyID8gJywgJyA6ICcgJyk7XG4gICAgICByZXR1cm4gc291cmNlLnJlcGxhY2UocmVXcmFwQ29tbWVudCwgJ3tcXG4vKiBbd3JhcHBlZCB3aXRoICcgKyBkZXRhaWxzICsgJ10gKi9cXG4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gICAgICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAgICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgICAgICkge1xuICAgICAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICAgICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgICAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xhemlhYmxlKGZ1bmMpIHtcbiAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgICAgIG90aGVyID0gbG9kYXNoW2Z1bmNOYW1lXTtcblxuICAgICAgaWYgKHR5cGVvZiBvdGhlciAhPSAnZnVuY3Rpb24nIHx8ICEoZnVuY05hbWUgaW4gTGF6eVdyYXBwZXIucHJvdG90eXBlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZnVuYyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGdldERhdGEob3RoZXIpO1xuICAgICAgcmV0dXJuICEhZGF0YSAmJiBmdW5jID09PSBkYXRhWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgICAgIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBpcyBjYXBhYmxlIG9mIGJlaW5nIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrYWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIHZhciBpc01hc2thYmxlID0gY29yZUpzRGF0YSA/IGlzRnVuY3Rpb24gOiBzdHViRmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gICAgICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gICAgICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAgICAgKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAgICAgKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAgICAgKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgICAgICBjYWNoZS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdGhlIGZ1bmN0aW9uIG1ldGFkYXRhIG9mIGBzb3VyY2VgIGludG8gYGRhdGFgLlxuICAgICAqXG4gICAgICogTWVyZ2luZyBtZXRhZGF0YSByZWR1Y2VzIHRoZSBudW1iZXIgb2Ygd3JhcHBlcnMgdXNlZCB0byBpbnZva2UgYSBmdW5jdGlvbi5cbiAgICAgKiBUaGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgbWV0aG9kcyBsaWtlIGBfLmJpbmRgLCBgXy5jdXJyeWAsIGFuZCBgXy5wYXJ0aWFsYFxuICAgICAqIG1heSBiZSBhcHBsaWVkIHJlZ2FyZGxlc3Mgb2YgZXhlY3V0aW9uIG9yZGVyLiBNZXRob2RzIGxpa2UgYF8uYXJ5YCBhbmRcbiAgICAgKiBgXy5yZWFyZ2AgbW9kaWZ5IGZ1bmN0aW9uIGFyZ3VtZW50cywgbWFraW5nIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFyZVxuICAgICAqIGV4ZWN1dGVkIGltcG9ydGFudCwgcHJldmVudGluZyB0aGUgbWVyZ2luZyBvZiBtZXRhZGF0YS4gSG93ZXZlciwgd2UgbWFrZVxuICAgICAqIGFuIGV4Y2VwdGlvbiBmb3IgYSBzYWZlIGNvbWJpbmVkIGNhc2Ugd2hlcmUgY3VycmllZCBmdW5jdGlvbnMgaGF2ZSBgXy5hcnlgXG4gICAgICogYW5kIG9yIGBfLnJlYXJnYCBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIFRoZSBkZXN0aW5hdGlvbiBtZXRhZGF0YS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIHNvdXJjZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRhdGFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlRGF0YShkYXRhLCBzb3VyY2UpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gZGF0YVsxXSxcbiAgICAgICAgICBzcmNCaXRtYXNrID0gc291cmNlWzFdLFxuICAgICAgICAgIG5ld0JpdG1hc2sgPSBiaXRtYXNrIHwgc3JjQml0bWFzayxcbiAgICAgICAgICBpc0NvbW1vbiA9IG5ld0JpdG1hc2sgPCAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcgfCBXUkFQX0FSWV9GTEFHKTtcblxuICAgICAgdmFyIGlzQ29tYm8gPVxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSkgfHxcbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfUkVBUkdfRkxBRykgJiYgKGRhdGFbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkpIHx8XG4gICAgICAgICgoc3JjQml0bWFzayA9PSAoV1JBUF9BUllfRkxBRyB8IFdSQVBfUkVBUkdfRkxBRykpICYmIChzb3VyY2VbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSk7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgbWV0YWRhdGEgY2FuJ3QgYmUgbWVyZ2VkLlxuICAgICAgaWYgKCEoaXNDb21tb24gfHwgaXNDb21ibykpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGB0aGlzQXJnYCBpZiBhdmFpbGFibGUuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQklORF9GTEFHKSB7XG4gICAgICAgIGRhdGFbMl0gPSBzb3VyY2VbMl07XG4gICAgICAgIC8vIFNldCB3aGVuIGN1cnJ5aW5nIGEgYm91bmQgZnVuY3Rpb24uXG4gICAgICAgIG5ld0JpdG1hc2sgfD0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHID8gMCA6IFdSQVBfQ1VSUllfQk9VTkRfRkxBRztcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCBhcmd1bWVudHMuXG4gICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbM107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzID0gZGF0YVszXTtcbiAgICAgICAgZGF0YVszXSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3MocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNF0pIDogdmFsdWU7XG4gICAgICAgIGRhdGFbNF0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbM10sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs0XTtcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCByaWdodCBhcmd1bWVudHMuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs1XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBwYXJ0aWFscyA9IGRhdGFbNV07XG4gICAgICAgIGRhdGFbNV0gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzUmlnaHQocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNl0pIDogdmFsdWU7XG4gICAgICAgIGRhdGFbNl0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbNV0sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs2XTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyZ1Bvc2AgaWYgYXZhaWxhYmxlLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbN107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZGF0YVs3XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJ5YCBpZiBpdCdzIHNtYWxsZXIuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQVJZX0ZMQUcpIHtcbiAgICAgICAgZGF0YVs4XSA9IGRhdGFbOF0gPT0gbnVsbCA/IHNvdXJjZVs4XSA6IG5hdGl2ZU1pbihkYXRhWzhdLCBzb3VyY2VbOF0pO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJpdHlgIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG4gICAgICBpZiAoZGF0YVs5XSA9PSBudWxsKSB7XG4gICAgICAgIGRhdGFbOV0gPSBzb3VyY2VbOV07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBmdW5jYCBhbmQgbWVyZ2UgYml0bWFza3MuXG4gICAgICBkYXRhWzBdID0gc291cmNlWzBdO1xuICAgICAgZGF0YVsxXSA9IG5ld0JpdG1hc2s7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICAgICAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICAgKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gICAgICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwYXJlbnQgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byBnZXQgdGhlIHBhcmVudCB2YWx1ZSBvZi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGFyZW50IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcmVudChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IDIgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVvcmRlciBgYXJyYXlgIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGluZGV4ZXMgd2hlcmUgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgZmlyc3QgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIGZpcnN0IGVsZW1lbnQsIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIHNlY29uZCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgc2Vjb25kIGVsZW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHJlb3JkZXIuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJyYXkgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW9yZGVyKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihpbmRleGVzLmxlbmd0aCwgYXJyTGVuZ3RoKSxcbiAgICAgICAgICBvbGRBcnJheSA9IGNvcHlBcnJheShhcnJheSk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGFycmF5W2xlbmd0aF0gPSBpc0luZGV4KGluZGV4LCBhcnJMZW5ndGgpID8gb2xkQXJyYXlbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xuICAgICAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiB0aGlzIGZ1bmN0aW9uIGJlY29tZXMgaG90LCBpLmUuIGlzIGludm9rZWQgYSBsb3QgaW4gYSBzaG9ydFxuICAgICAqIHBlcmlvZCBvZiB0aW1lLCBpdCB3aWxsIHRyaXAgaXRzIGJyZWFrZXIgYW5kIHRyYW5zaXRpb24gdG8gYW4gaWRlbnRpdHlcbiAgICAgKiBmdW5jdGlvbiB0byBhdm9pZCBnYXJiYWdlIGNvbGxlY3Rpb24gcGF1c2VzIGluIFY4LiBTZWVcbiAgICAgKiBbVjggaXNzdWUgMjA3MF0oaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjA3MClcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldERhdGEgPSBzaG9ydE91dChiYXNlU2V0RGF0YSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgc2V0VGltZW91dGBdKGh0dHBzOi8vbWRuLmlvL3NldFRpbWVvdXQpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9cbiAgICB2YXIgc2V0VGltZW91dCA9IGN0eFNldFRpbWVvdXQgfHwgZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgICAgcmV0dXJuIHJvb3Quc2V0VGltZW91dChmdW5jLCB3YWl0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYHdyYXBwZXJgIHRvIG1pbWljIHRoZSBzb3VyY2Ugb2YgYHJlZmVyZW5jZWBcbiAgICAgKiB3aXRoIHdyYXBwZXIgZGV0YWlscyBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgc291cmNlIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWZlcmVuY2UgVGhlIHJlZmVyZW5jZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgd3JhcHBlcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0V3JhcFRvU3RyaW5nKHdyYXBwZXIsIHJlZmVyZW5jZSwgYml0bWFzaykge1xuICAgICAgdmFyIHNvdXJjZSA9IChyZWZlcmVuY2UgKyAnJyk7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcod3JhcHBlciwgaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCB1cGRhdGVXcmFwRGV0YWlscyhnZXRXcmFwRGV0YWlscyhzb3VyY2UpLCBiaXRtYXNrKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICAgICAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICAgICAqIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgICAgIHZhciBjb3VudCA9IDAsXG4gICAgICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCB3aGljaCBtdXRhdGVzIGFuZCBzZXRzIHRoZSBzaXplIG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT1hcnJheS5sZW5ndGhdIFRoZSBzaXplIG9mIGBhcnJheWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZVNlbGYoYXJyYXksIHNpemUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gICAgICBzaXplID0gc2l6ZSA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogc2l6ZTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgc2l6ZSkge1xuICAgICAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oaW5kZXgsIGxhc3RJbmRleCksXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuXG4gICAgICAgIGFycmF5W3JhbmRdID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGFycmF5Lmxlbmd0aCA9IHNpemU7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICovXG4gICAgdmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICAgICAgcmVzdWx0LnB1c2goJycpO1xuICAgICAgfVxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgICAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgICAgIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgd3JhcHBlciBgZGV0YWlsc2AgYmFzZWQgb24gYGJpdG1hc2tgIGZsYWdzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkZXRhaWxzYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVXcmFwRGV0YWlscyhkZXRhaWxzLCBiaXRtYXNrKSB7XG4gICAgICBhcnJheUVhY2god3JhcEZsYWdzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICdfLicgKyBwYWlyWzBdO1xuICAgICAgICBpZiAoKGJpdG1hc2sgJiBwYWlyWzFdKSAmJiAhYXJyYXlJbmNsdWRlcyhkZXRhaWxzLCB2YWx1ZSkpIHtcbiAgICAgICAgICBkZXRhaWxzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkZXRhaWxzLnNvcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHdyYXBwZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gd3JhcHBlciBUaGUgd3JhcHBlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgd3JhcHBlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xuICAgICAgaWYgKHdyYXBwZXIgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXR1cm4gd3JhcHBlci5jbG9uZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZXIuX193cmFwcGVkX18sIHdyYXBwZXIuX19jaGFpbl9fKTtcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh3cmFwcGVyLl9fYWN0aW9uc19fKTtcbiAgICAgIHJlc3VsdC5fX2luZGV4X18gID0gd3JhcHBlci5fX2luZGV4X187XG4gICAgICByZXN1bHQuX192YWx1ZXNfXyA9IHdyYXBwZXIuX192YWx1ZXNfXztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIGdyb3VwcyB0aGUgbGVuZ3RoIG9mIGBzaXplYC5cbiAgICAgKiBJZiBgYXJyYXlgIGNhbid0IGJlIHNwbGl0IGV2ZW5seSwgdGhlIGZpbmFsIGNodW5rIHdpbGwgYmUgdGhlIHJlbWFpbmluZ1xuICAgICAqIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdIFRoZSBsZW5ndGggb2YgZWFjaCBjaHVua1xuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY2h1bmtzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAyKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InXSwgWydjJywgJ2QnXV1cbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDMpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYicsICdjJ10sIFsnZCddXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNodW5rKGFycmF5LCBzaXplLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzaXplLCBndWFyZCkgOiBzaXplID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IG5hdGl2ZU1heCh0b0ludGVnZXIoc2l6ZSksIDApO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGggfHwgc2l6ZSA8IDEpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobmF0aXZlQ2VpbChsZW5ndGggLyBzaXplKSk7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSBiYXNlU2xpY2UoYXJyYXksIGluZGV4LCAoaW5kZXggKz0gc2l6ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG4gICAgICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGZhbHNleS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhcnJheSBjb25jYXRlbmF0aW5nIGBhcnJheWAgd2l0aCBhbnkgYWRkaXRpb25hbCBhcnJheXNcbiAgICAgKiBhbmQvb3IgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbmNhdGVuYXRlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBjb25jYXRlbmF0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxXTtcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNvbmNhdChhcnJheSwgMiwgWzNdLCBbWzRdXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvdGhlcik7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoIC0gMSksXG4gICAgICAgICAgYXJyYXkgPSBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGFyZ3NbaW5kZXggLSAxXSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlQdXNoKGlzQXJyYXkoYXJyYXkpID8gY29weUFycmF5KGFycmF5KSA6IFthcnJheV0sIGJhc2VGbGF0dGVuKGFyZ3MsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGBhcnJheWAgdmFsdWVzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXIgZ2l2ZW4gYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLndpdGhvdXQsIF8ueG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZShbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2UgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsQnlgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRpZmZlcmVuY2VCeShbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sIFt7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZUJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdCh2YWx1ZXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YCB0byBgdmFsdWVzYC4gVGhlIG9yZGVyIGFuZFxuICAgICAqIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBjb21wYXJhdG9yXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxXaXRoYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZVdpdGgob2JqZWN0cywgW3sgJ3gnOiAxLCAneSc6IDIgfV0sIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZVdpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QodmFsdWVzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChjb21wYXJhdG9yKSkge1xuICAgICAgICBjb21wYXJhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUsIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbHMgZWxlbWVudHMgb2YgYGFycmF5YCB3aXRoIGB2YWx1ZWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90XG4gICAgICogaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8uZmlsbChhcnJheSwgJ2EnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydhJywgJ2EnLCAnYSddXG4gICAgICpcbiAgICAgKiBfLmZpbGwoQXJyYXkoMyksIDIpO1xuICAgICAqIC8vID0+IFsyLCAyLCAyXVxuICAgICAqXG4gICAgICogXy5maWxsKFs0LCA2LCA4LCAxMF0sICcqJywgMSwgMyk7XG4gICAgICogLy8gPT4gWzQsICcqJywgJyonLCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICYmIHR5cGVvZiBzdGFydCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgdmFsdWUsIHN0YXJ0KSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAncGViYmxlcyc7IH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICBpZiAoZnJvbUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggPCAwXG4gICAgICAgICAgPyBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApXG4gICAgICAgICAgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbnMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVlcChbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0LCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZWVwKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIElORklOSVRZKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYGFycmF5YCB1cCB0byBgZGVwdGhgIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgWzIsIFszLCBbNF1dLCA1XV07XG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZXB0aChhcnJheSwgMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlcHRoKGFycmF5LCBkZXB0aCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy50b1BhaXJzYDsgdGhpcyBtZXRob2QgcmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWRcbiAgICAgKiBmcm9tIGtleS12YWx1ZSBgcGFpcnNgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZyb21QYWlycyhbWydhJywgMV0sIFsnYicsIDJdXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbVBhaXJzKHBhaXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpbmRleF07XG4gICAgICAgIHJlc3VsdFtwYWlyWzBdXSA9IHBhaXJbMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyBmaXJzdFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmhlYWQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmhlYWQoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhlYWQoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgaW4gYGFycmF5YFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzIHRoZVxuICAgICAqIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMCwgLTEpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGFsbCBnaXZlbiBhcnJheXNcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb24oWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsyXVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb25CeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5pbnRlcnNlY3Rpb25CeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKSxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuXG4gICAgICBpZiAoaXRlcmF0ZWUgPT09IGxhc3QobWFwcGVkKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcHBlZC5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXNcbiAgICAgKiBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3IgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH1dXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpLFxuICAgICAgICAgIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG5cbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIG1hcHBlZC5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYWxsIGVsZW1lbnRzIGluIGBhcnJheWAgaW50byBhIHN0cmluZyBzZXBhcmF0ZWQgYnkgYHNlcGFyYXRvcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NlcGFyYXRvcj0nLCddIFRoZSBlbGVtZW50IHNlcGFyYXRvci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBqb2luZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmpvaW4oWydhJywgJ2InLCAnYyddLCAnficpO1xuICAgICAqIC8vID0+ICdhfmJ+YydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBqb2luKGFycmF5LCBzZXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBhcnJheSA9PSBudWxsID8gJycgOiBuYXRpdmVKb2luLmNhbGwoYXJyYXksIHNlcGFyYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBhcnJheWAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgIGluZGV4ID0gaW5kZXggPCAwID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKSA6IG5hdGl2ZU1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgICAgID8gc3RyaWN0TGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleClcbiAgICAgICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGluZGV4LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBlbGVtZW50IGF0IGluZGV4IGBuYCBvZiBgYXJyYXlgLiBJZiBgbmAgaXMgbmVnYXRpdmUsIHRoZSBudGhcbiAgICAgKiBlbGVtZW50IGZyb20gdGhlIGVuZCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjExLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCddO1xuICAgICAqXG4gICAgICogXy5udGgoYXJyYXksIDEpO1xuICAgICAqIC8vID0+ICdiJ1xuICAgICAqXG4gICAgICogXy5udGgoYXJyYXksIC0yKTtcbiAgICAgKiAvLyA9PiAnYyc7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbnRoKGFycmF5LCBuKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlTnRoKGFycmF5LCB0b0ludGVnZXIobikpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGdpdmVuIHZhbHVlcyBmcm9tIGBhcnJheWAgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ud2l0aG91dGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnJlbW92ZWBcbiAgICAgKiB0byByZW1vdmUgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnYScsICdiJywgJ2MnXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbChhcnJheSwgJ2EnLCAnYycpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovXG4gICAgdmFyIHB1bGwgPSBiYXNlUmVzdChwdWxsQWxsKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnYScsICdiJywgJ2MnXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbChhcnJheSwgWydhJywgJ2MnXSk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYicsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsQWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlQnlgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMyB9LCB7ICd4JzogMSB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbEJ5KGFycmF5LCBbeyAneCc6IDEgfSwgeyAneCc6IDMgfV0sICd4Jyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGxCeShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YCB0byBgdmFsdWVzYC4gVGhlIGNvbXBhcmF0b3IgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZVdpdGhgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDMsICd5JzogNCB9LCB7ICd4JzogNSwgJ3knOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsV2l0aChhcnJheSwgW3sgJ3gnOiAzLCAneSc6IDQgfV0sIF8uaXNFcXVhbCk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiA1LCAneSc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsV2l0aChhcnJheSwgdmFsdWVzLCBjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIGBhcnJheWAgY29ycmVzcG9uZGluZyB0byBgaW5kZXhlc2AgYW5kIHJldHVybnMgYW5cbiAgICAgKiBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5hdGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gW2luZGV4ZXNdIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAgICAgKiB2YXIgcHVsbGVkID0gXy5wdWxsQXQoYXJyYXksIFsxLCAzXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydhJywgJ2MnXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cocHVsbGVkKTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnZCddXG4gICAgICovXG4gICAgdmFyIHB1bGxBdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYmFzZUF0KGFycmF5LCBpbmRleGVzKTtcblxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgYXJyYXlNYXAoaW5kZXhlcywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGlzSW5kZXgoaW5kZXgsIGxlbmd0aCkgPyAraW5kZXggOiBpbmRleDtcbiAgICAgIH0pLnNvcnQoY29tcGFyZUFzY2VuZGluZykpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBgYXJyYXlgIHRoYXQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnB1bGxgXG4gICAgICogdG8gcHVsbCBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGJ5IHZhbHVlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDRdO1xuICAgICAqIHZhciBldmVucyA9IF8ucmVtb3ZlKGFycmF5LCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAgICAgKiAvLyA9PiBbMiwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcHJlZGljYXRlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgYGFycmF5YCBzbyB0aGF0IHRoZSBmaXJzdCBlbGVtZW50IGJlY29tZXMgdGhlIGxhc3QsIHRoZSBzZWNvbmRcbiAgICAgKiBlbGVtZW50IGJlY29tZXMgdGhlIHNlY29uZCB0byBsYXN0LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgIGFuZCBpcyBiYXNlZCBvblxuICAgICAqIFtgQXJyYXkjcmV2ZXJzZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3JldmVyc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXy5yZXZlcnNlKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXZlcnNlKGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/IGFycmF5IDogbmF0aXZlUmV2ZXJzZS5jYWxsKGFycmF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGluc3RlYWQgb2ZcbiAgICAgKiBbYEFycmF5I3NsaWNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvc2xpY2UpIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAmJiB0eXBlb2YgZW5kICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzdGFydCwgZW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0ludGVnZXIoZW5kKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgbG93ZXN0IGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbMzAsIDUwXSwgNDApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyXG4gICAgICogc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogNCB9LCB7ICd4JzogNSB9XTtcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29ydGVkSW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCAneCcpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4T2YoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGhpZ2hlc3RcbiAgICAgKiBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG9cbiAgICAgKiBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4KFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gNFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleChhcnJheSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZExhc3RJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ueDsgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCAneCcpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubGFzdEluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IHBlcmZvcm1zIGEgYmluYXJ5XG4gICAgICogc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4T2YoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpIC0gMTtcbiAgICAgICAgaWYgKGVxKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCdzIGRlc2lnbmVkIGFuZCBvcHRpbWl6ZWRcbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZFVuaXEoWzEsIDEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU29ydGVkVW5pcShhcnJheSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFCeWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZFVuaXFCeShbMS4xLCAxLjIsIDIuMywgMi40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMSwgMi4zXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZFVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRhaWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWlsKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCAxLCBsZW5ndGgpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZShhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIG4gPSBsZW5ndGggLSBuO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC4gRWxlbWVudHMgYXJlXG4gICAgICogdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGZhbHNlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLiBFbGVtZW50c1xuICAgICAqIGFyZSB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgZnJvbSBhbGwgZ2l2ZW4gYXJyYXlzIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uKFsyXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb20gdGhlIGZpcnN0XG4gICAgICogYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uQnkoWzIuMV0sIFsxLjIsIDIuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjEsIDEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udW5pb25CeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBSZXN1bHQgdmFsdWVzIGFyZSBjaG9zZW4gZnJvbVxuICAgICAqIHRoZSBmaXJzdCBhcnJheSBpbiB3aGljaCB0aGUgdmFsdWUgb2NjdXJzLiBUaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy51bmlvbldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciB1bmlvbldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpO1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXksIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGluIHdoaWNoIG9ubHkgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgZWFjaCBlbGVtZW50XG4gICAgICogaXMga2VwdC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1clxuICAgICAqIGluIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzIsIDEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICAgICAqIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXFCeShbMi4xLCAxLjIsIDIuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjEsIDEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udW5pcUJ5KFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXNcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS5UaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy51bmlxV2l0aChvYmplY3RzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxV2l0aChhcnJheSwgY29tcGFyYXRvcikge1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIHVuZGVmaW5lZCwgY29tcGFyYXRvcikgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiBncm91cGVkXG4gICAgICogZWxlbWVudHMgYW5kIGNyZWF0ZXMgYW4gYXJyYXkgcmVncm91cGluZyB0aGUgZWxlbWVudHMgdG8gdGhlaXIgcHJlLXppcFxuICAgICAqIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXG4gICAgICpcbiAgICAgKiBfLnVuemlwKHppcHBlZCk7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcChhcnJheSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgIGFycmF5ID0gYXJyYXlGaWx0ZXIoYXJyYXksIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChncm91cCkpIHtcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoZ3JvdXAubGVuZ3RoLCBsZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBiYXNlVGltZXMobGVuZ3RoLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gYXJyYXlNYXAoYXJyYXksIGJhc2VQcm9wZXJ0eShpbmRleCkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgcmVncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhlXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIHJlZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSk7XG4gICAgICogLy8gPT4gW1sxLCAxMCwgMTAwXSwgWzIsIDIwLCAyMDBdXVxuICAgICAqXG4gICAgICogXy51bnppcFdpdGgoemlwcGVkLCBfLmFkZCk7XG4gICAgICogLy8gPT4gWzMsIDMwLCAzMDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXBXaXRoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdW56aXAoYXJyYXkpO1xuICAgICAgaWYgKGl0ZXJhdGVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheU1hcChyZXN1bHQsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZSwgdW5kZWZpbmVkLCBncm91cCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgZ2l2ZW4gdmFsdWVzIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndpdGhvdXQoWzIsIDEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKi9cbiAgICB2YXIgd2l0aG91dCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgaXMgdGhlXG4gICAgICogW3N5bW1ldHJpYyBkaWZmZXJlbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW1tZXRyaWNfZGlmZmVyZW5jZSlcbiAgICAgKiBvZiB0aGUgZ2l2ZW4gYXJyYXlzLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlclxuICAgICAqIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ud2l0aG91dFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvcihbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICovXG4gICAgdmFyIHhvciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy54b3JgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnlcbiAgICAgKiB3aGljaCBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkXG4gICAgICogYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmVcbiAgICAgKiBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvckJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjIsIDMuNF1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ueG9yQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIHhvckJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnhvcmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLiBUaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy54b3JXaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIHhvcldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpO1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCksIHVuZGVmaW5lZCwgY29tcGFyYXRvcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMsIHRoZSBmaXJzdCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiBmaXJzdCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCB0aGUgc2Vjb25kIG9mIHdoaWNoIGNvbnRhaW5zIHRoZVxuICAgICAqIHNlY29uZCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMSwgdHJ1ZV0sIFsnYicsIDIsIGZhbHNlXV1cbiAgICAgKi9cbiAgICB2YXIgemlwID0gYmFzZVJlc3QodW56aXApO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mcm9tUGFpcnNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgdHdvIGFycmF5cyxcbiAgICAgKiBvbmUgb2YgcHJvcGVydHkgaWRlbnRpZmllcnMgYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wcz1bXV0gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoWydhJywgJ2InXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3QocHJvcHMsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHMgfHwgW10sIHZhbHVlcyB8fCBbXSwgYXNzaWduVmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwT2JqZWN0YCBleGNlcHQgdGhhdCBpdCBzdXBwb3J0cyBwcm9wZXJ0eSBwYXRocy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wcz1bXV0gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3REZWVwKFsnYS5iWzBdLmMnLCAnYS5iWzFdLmQnXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IFt7ICdjJzogMSB9LCB7ICdkJzogMiB9XSB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3REZWVwKHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGJhc2VTZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgdG8gc3BlY2lmeVxuICAgICAqIGhvdyBncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhlXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmVcbiAgICAgKiAgZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBXaXRoKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0sIGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBhICsgYiArIGM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzExMSwgMjIyXVxuICAgICAqL1xuICAgIHZhciB6aXBXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBpdGVyYXRlZSA9IGxlbmd0aCA+IDEgPyBhcnJheXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGl0ZXJhdGVlID0gdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgPyAoYXJyYXlzLnBvcCgpLCBpdGVyYXRlZSkgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdW56aXBXaXRoKGFycmF5cywgaXRlcmF0ZWUpO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UgdGhhdCB3cmFwcyBgdmFsdWVgIHdpdGggZXhwbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW4gc2VxdWVuY2VzIGVuYWJsZWQuIFRoZSByZXN1bHQgb2Ygc3VjaCBzZXF1ZW5jZXMgbXVzdCBiZSB1bndyYXBwZWRcbiAgICAgKiB3aXRoIGBfI3ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfXG4gICAgICogICAuY2hhaW4odXNlcnMpXG4gICAgICogICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgLm1hcChmdW5jdGlvbihvKSB7XG4gICAgICogICAgIHJldHVybiBvLnVzZXIgKyAnIGlzICcgKyBvLmFnZTtcbiAgICAgKiAgIH0pXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcyBpcyAxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoKHZhbHVlKTtcbiAgICAgIHJlc3VsdC5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIGBpbnRlcmNlcHRvcmAgYW5kIHJldHVybnMgYHZhbHVlYC4gVGhlIGludGVyY2VwdG9yXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG9cbiAgICAgKiBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4gc2VxdWVuY2UgaW4gb3JkZXIgdG8gbW9kaWZ5IGludGVybWVkaWF0ZSByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKVxuICAgICAqICAudGFwKGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICogICAgLy8gTXV0YXRlIGlucHV0IGFycmF5LlxuICAgICAqICAgIGFycmF5LnBvcCgpO1xuICAgICAqICB9KVxuICAgICAqICAucmV2ZXJzZSgpXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhcCh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnRhcGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJwYXNzIHRocnVcIiB2YWx1ZXMgcmVwbGFjaW5nIGludGVybWVkaWF0ZVxuICAgICAqIHJlc3VsdHMgaW4gYSBtZXRob2QgY2hhaW4gc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKCcgIGFiYyAgJylcbiAgICAgKiAgLmNoYWluKClcbiAgICAgKiAgLnRyaW0oKVxuICAgICAqICAudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAqICB9KVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhydSh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIHJldHVybiBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5hdGAuXG4gICAgICpcbiAgICAgKiBAbmFtZSBhdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gICAgICpcbiAgICAgKiBfKG9iamVjdCkuYXQoWydhWzBdLmIuYycsICdhWzFdJ10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICovXG4gICAgdmFyIHdyYXBwZXJBdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKHBhdGhzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHN0YXJ0ID0gbGVuZ3RoID8gcGF0aHNbMF0gOiAwLFxuICAgICAgICAgIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKG9iamVjdCkgeyByZXR1cm4gYmFzZUF0KG9iamVjdCwgcGF0aHMpOyB9O1xuXG4gICAgICBpZiAobGVuZ3RoID4gMSB8fCB0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCB8fFxuICAgICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikgfHwgIWlzSW5kZXgoc3RhcnQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocnUoaW50ZXJjZXB0b3IpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZShzdGFydCwgK3N0YXJ0ICsgKGxlbmd0aCA/IDEgOiAwKSk7XG4gICAgICB2YWx1ZS5fX2FjdGlvbnNfXy5wdXNoKHtcbiAgICAgICAgJ2Z1bmMnOiB0aHJ1LFxuICAgICAgICAnYXJncyc6IFtpbnRlcmNlcHRvcl0sXG4gICAgICAgICd0aGlzQXJnJzogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSwgdGhpcy5fX2NoYWluX18pLnRocnUoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgaWYgKGxlbmd0aCAmJiAhYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgYXJyYXkucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2Ugd2l0aCBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjaGFpblxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBBIHNlcXVlbmNlIHdpdGhvdXQgZXhwbGljaXQgY2hhaW5pbmcuXG4gICAgICogXyh1c2VycykuaGVhZCgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIEEgc2VxdWVuY2Ugd2l0aCBleHBsaWNpdCBjaGFpbmluZy5cbiAgICAgKiBfKHVzZXJzKVxuICAgICAqICAgLmNoYWluKClcbiAgICAgKiAgIC5oZWFkKClcbiAgICAgKiAgIC5waWNrKCd1c2VyJylcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNoYWluKCkge1xuICAgICAgcmV0dXJuIGNoYWluKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbiBzZXF1ZW5jZSBhbmQgcmV0dXJucyB0aGUgd3JhcHBlZCByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjb21taXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDJdO1xuICAgICAqIHZhciB3cmFwcGVkID0gXyhhcnJheSkucHVzaCgzKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQgPSB3cmFwcGVkLmNvbW1pdCgpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubGFzdCgpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ29tbWl0KCkge1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHRoaXMudmFsdWUoKSwgdGhpcy5fX2NoYWluX18pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5leHQgdmFsdWUgb24gYSB3cmFwcGVkIG9iamVjdCBmb2xsb3dpbmcgdGhlXG4gICAgICogW2l0ZXJhdG9yIHByb3RvY29sXShodHRwczovL21kbi5pby9pdGVyYXRpb25fcHJvdG9jb2xzI2l0ZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBuYW1lIG5leHRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXh0IGl0ZXJhdG9yIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKTtcbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiBmYWxzZSwgJ3ZhbHVlJzogMSB9XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDIgfVxuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IHRydWUsICd2YWx1ZSc6IHVuZGVmaW5lZCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlck5leHQoKSB7XG4gICAgICBpZiAodGhpcy5fX3ZhbHVlc19fID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdG9BcnJheSh0aGlzLnZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgdmFyIGRvbmUgPSB0aGlzLl9faW5kZXhfXyA+PSB0aGlzLl9fdmFsdWVzX18ubGVuZ3RoLFxuICAgICAgICAgIHZhbHVlID0gZG9uZSA/IHVuZGVmaW5lZCA6IHRoaXMuX192YWx1ZXNfX1t0aGlzLl9faW5kZXhfXysrXTtcblxuICAgICAgcmV0dXJuIHsgJ2RvbmUnOiBkb25lLCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIHdyYXBwZXIgdG8gYmUgaXRlcmFibGUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBTeW1ib2wuaXRlcmF0b3JcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XG4gICAgICpcbiAgICAgKiB3cmFwcGVkW1N5bWJvbC5pdGVyYXRvcl0oKSA9PT0gd3JhcHBlZDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBBcnJheS5mcm9tKHdyYXBwZWQpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJUb0l0ZXJhdG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBjaGFpbiBzZXF1ZW5jZSBwbGFudGluZyBgdmFsdWVgIGFzIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgcGxhbnRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwbGFudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKS5tYXAoc3F1YXJlKTtcbiAgICAgKiB2YXIgb3RoZXIgPSB3cmFwcGVkLnBsYW50KFszLCA0XSk7XG4gICAgICpcbiAgICAgKiBvdGhlci52YWx1ZSgpO1xuICAgICAqIC8vID0+IFs5LCAxNl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUGxhbnQodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgcGFyZW50ID0gdGhpcztcblxuICAgICAgd2hpbGUgKHBhcmVudCBpbnN0YW5jZW9mIGJhc2VMb2Rhc2gpIHtcbiAgICAgICAgdmFyIGNsb25lID0gd3JhcHBlckNsb25lKHBhcmVudCk7XG4gICAgICAgIGNsb25lLl9faW5kZXhfXyA9IDA7XG4gICAgICAgIGNsb25lLl9fdmFsdWVzX18gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IGNsb25lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGNsb25lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91cyA9IGNsb25lO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX193cmFwcGVkX187XG4gICAgICB9XG4gICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgd3JhcHBlciB2ZXJzaW9uIG9mIGBfLnJldmVyc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgdGhlIHdyYXBwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8oYXJyYXkpLnJldmVyc2UoKS52YWx1ZSgpXG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclJldmVyc2UoKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgdmFyIHdyYXBwZWQgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoKSB7XG4gICAgICAgICAgd3JhcHBlZCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5yZXZlcnNlKCk7XG4gICAgICAgIHdyYXBwZWQuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICAgJ2Z1bmMnOiB0aHJ1LFxuICAgICAgICAgICdhcmdzJzogW3JldmVyc2VdLFxuICAgICAgICAgICd0aGlzQXJnJzogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlZCwgdGhpcy5fX2NoYWluX18pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudGhydShyZXZlcnNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyB0b0pTT04sIHZhbHVlT2ZcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclZhbHVlKCkge1xuICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUodGhpcy5fX3dyYXBwZWRfXywgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXG4gICAgICogZWFjaCBrZXkgaXMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUga2V5IHdhcyByZXR1cm5lZCBieSBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzYuMSwgNC4yLCA2LjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uY291bnRCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiAyLCAnNSc6IDEgfVxuICAgICAqL1xuICAgIHZhciBjb3VudEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICArK3Jlc3VsdFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCAxKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgKiBbZW1wdHkgY29sbGVjdGlvbnNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VtcHR5X3NldCkgYmVjYXVzZVxuICAgICAqIFtldmVyeXRoaW5nIGlzIHRydWVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZhY3VvdXNfdHJ1dGgpIG9mXG4gICAgICogZWxlbWVudHMgb2YgZW1wdHkgY29sbGVjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUV2ZXJ5IDogYmFzZUV2ZXJ5O1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5yZW1vdmVgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBzZWUgXy5yZWplY3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICAgICAqL1xuICAgIHZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9Y29sbGVjdGlvbi5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgdmFyIGZpbmRMYXN0ID0gY3JlYXRlRmluZChmaW5kTGFzdEluZGV4KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmbGF0dGVuZWQgYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYFxuICAgICAqIHRocnUgYGl0ZXJhdGVlYCBhbmQgZmxhdHRlbmluZyB0aGUgbWFwcGVkIHJlc3VsdHMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbbiwgbl07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMiwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbGF0TWFwYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBmbGF0dGVucyB0aGVcbiAgICAgKiBtYXBwZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlZXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xuICAgICAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZWVwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgSU5GSU5JVFkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXG4gICAgICogbWFwcGVkIHJlc3VsdHMgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlcHRoKFsxLCAyXSwgZHVwbGljYXRlLCAyKTtcbiAgICAgKiAvLyA9PiBbWzEsIDFdLCBbMiwgMl1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcERlcHRoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBkZXB0aCkge1xuICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgZGVwdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gICAgICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcbiAgICAgKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBzZWUgXy5mb3JFYWNoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaFJpZ2h0KFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzIGAyYCB0aGVuIGAxYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaFJpZ2h0IDogYmFzZUVhY2hSaWdodDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBvcmRlciBvZiBncm91cGVkIHZhbHVlc1xuICAgICAqIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gYGNvbGxlY3Rpb25gLiBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqIHZhbHVlIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZVxuICAgICAqIGtleS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjNdIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL1xuICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgW3ZhbHVlXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBhIHN0cmluZywgaXQnc1xuICAgICAqIGNoZWNrZWQgZm9yIGEgc3Vic3RyaW5nIG9mIGB2YWx1ZWAsIG90aGVyd2lzZVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogaXMgdXNlZCBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXNcbiAgICAgKiB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyh7ICdhJzogMSwgJ2InOiAyIH0sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoJ2FiY2QnLCAnYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICAgIGNvbGxlY3Rpb24gPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4ICYmICFndWFyZCkgPyB0b0ludGVnZXIoZnJvbUluZGV4KSA6IDA7XG5cbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgIGZyb21JbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pXG4gICAgICAgID8gKGZyb21JbmRleCA8PSBsZW5ndGggJiYgY29sbGVjdGlvbi5pbmRleE9mKHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpXG4gICAgICAgIDogKCEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nXG4gICAgICogYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogYXJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBwYXRoYCBpcyBhIGZ1bmN0aW9uLCBpdCdzIGludm9rZWRcbiAgICAgKiBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuICAgICAqICB0aGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGVhY2ggbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZU1hcChbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgdmFyIGludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXNGdW5jID8gYXBwbHkocGF0aCwgdmFsdWUsIGFyZ3MpIDogYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtcbiAgICAgKiAgIHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LFxuICAgICAqICAgeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmtleUJ5KGFycmF5LCBmdW5jdGlvbihvKSB7XG4gICAgICogICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvLmNvZGUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksICdkaXInKTtcbiAgICAgKiAvLyA9PiB7ICdsZWZ0JzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdyaWdodCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqL1xuICAgIHZhciBrZXlCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXJ5YCwgYGNodW5rYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZXZlcnlgLFxuICAgICAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICAgICAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5tYXAoWzQsIDhdLCBzcXVhcmUpO1xuICAgICAqIC8vID0+IFsxNiwgNjRdXG4gICAgICpcbiAgICAgKiBfLm1hcCh7ICdhJzogNCwgJ2InOiA4IH0sIHNxdWFyZSk7XG4gICAgICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRCeWAgZXhjZXB0IHRoYXQgaXQgYWxsb3dzIHNwZWNpZnlpbmcgdGhlIHNvcnRcbiAgICAgKiBvcmRlcnMgb2YgdGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlc1xuICAgICAqIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yXG4gICAgICogZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlciBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXlbXXxGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFtvcmRlcnNdIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBTb3J0IGJ5IGB1c2VyYCBpbiBhc2NlbmRpbmcgb3JkZXIgYW5kIGJ5IGBhZ2VgIGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICogXy5vcmRlckJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10sIFsnYXNjJywgJ2Rlc2MnXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycywgZ3VhcmQpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KGl0ZXJhdGVlcykpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gaXRlcmF0ZWVzID09IG51bGwgPyBbXSA6IFtpdGVyYXRlZXNdO1xuICAgICAgfVxuICAgICAgb3JkZXJzID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBvcmRlcnM7XG4gICAgICBpZiAoIWlzQXJyYXkob3JkZXJzKSkge1xuICAgICAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byB0d28gZ3JvdXBzLCB0aGUgZmlyc3Qgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IsIHRoZSBzZWNvbmQgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleSBmb3IuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydwZWJibGVzJ10sIFsnYmFybmV5JywgJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsICdwZWJibGVzJ10sIFsnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKi9cbiAgICB2YXIgcGFydGl0aW9uID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXkgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24oKSB7IHJldHVybiBbW10sIFtdXTsgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2VzIGBjb2xsZWN0aW9uYCB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gICAgICogaXMgbm90IGdpdmVuLCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICAgICAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICAgICAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgb3JkZXJCeWAsXG4gICAgICogYW5kIGBzb3J0QnlgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG47XG4gICAgICogfSwgMCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZSA6IGJhc2VSZWR1Y2UsXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmVkdWNlYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLnJlZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICpcbiAgICAgKiBfLnJlZHVjZVJpZ2h0KGFycmF5LCBmdW5jdGlvbihmbGF0dGVuZWQsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gZmxhdHRlbmVkLmNvbmNhdChvdGhlcik7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2VSaWdodCA6IGJhc2VSZWR1Y2UsXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2hSaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmA7IHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYFxuICAgICAqIHRoYXQgYHByZWRpY2F0ZWAgZG9lcyAqKm5vdCoqIHJldHVybiB0cnV0aHkgZm9yLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBzZWUgXy5maWx0ZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5yZWplY3QodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcmFuZG9tIGVsZW1lbnQgZnJvbSBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZSA6IGJhc2VTYW1wbGU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGBuYCByYW5kb20gZWxlbWVudHMgYXQgdW5pcXVlIGtleXMgZnJvbSBgY29sbGVjdGlvbmAgdXAgdG8gdGhlXG4gICAgICogc2l6ZSBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGVTaXplKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCA0KTtcbiAgICAgKiAvLyA9PiBbMiwgMywgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGVTaXplKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICB9XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZVNpemUgOiBiYXNlU2FtcGxlU2l6ZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gICAgICogW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICAgICAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIHNpemUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gc3RyaW5nU2l6ZShjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyhjb2xsZWN0aW9uKTtcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlS2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFueSoqIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U29tZSA6IGJhc2VTb21lO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhydSBlYWNoIGl0ZXJhdGVlLiBUaGlzIG1ldGhvZFxuICAgICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICAgICAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyOyB9XSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF0sIFsnZnJlZCcsIDQ4XV1cbiAgICAgKi9cbiAgICB2YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtdO1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcywgMSksIFtdKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICAgICAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IERhdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gICAgICogfSwgXy5ub3coKSk7XG4gICAgICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgbm93ID0gY3R4Tm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmJlZm9yZWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiBgZnVuY2Agb25jZSBpdCdzIGNhbGxlZCBgbmAgb3IgbW9yZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnZG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdkb25lIHNhdmluZyEnIGFmdGVyIHRoZSB0d28gYXN5bmMgc2F2ZXMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIobiwgZnVuYykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHVwIHRvIGBuYCBhcmd1bWVudHMsXG4gICAgICogaWdub3JpbmcgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgY2FwLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLmFyeShwYXJzZUludCwgMSkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnkoZnVuYywgbiwgZ3VhcmQpIHtcbiAgICAgIG4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IG47XG4gICAgICBuID0gKGZ1bmMgJiYgbiA9PSBudWxsKSA/IGZ1bmMubGVuZ3RoIDogbjtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQVJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHNcbiAgICAgKiBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hpbGUgaXQncyBjYWxsZWQgbGVzcyB0aGFuIGBuYCB0aW1lcy4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBhdCB3aGljaCBgZnVuY2AgaXMgbm8gbG9uZ2VyIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uYmVmb3JlKDUsIGFkZENvbnRhY3RUb0xpc3QpKTtcbiAgICAgKiAvLyA9PiBBbGxvd3MgYWRkaW5nIHVwIHRvIDQgY29udGFjdHMgdG8gdGhlIGxpc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmVmb3JlKG4sIGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uID4gMCkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgICAgZnVuYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCwgdGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKGJpbmQpKTtcbiAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gIHdpdGggYHBhcnRpYWxzYFxuICAgICAqIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0byByZWZlcmVuY2VcbiAgICAgKiBtZXRob2RzIHRoYXQgbWF5IGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuIFNlZVxuICAgICAqIFtQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZV0oaHR0cDovL3BldGVyLm1pY2hhdXguY2EvYXJ0aWNsZXMvbGF6eS1mdW5jdGlvbi1kZWZpbml0aW9uLXBhdHRlcm4pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kS2V5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52b2tlIHRoZSBtZXRob2Qgb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAndXNlcic6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICd5YSAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kS2V5ID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBrZXksIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZEtleSkpO1xuICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoa2V5LCBiaXRtYXNrLCBvYmplY3QsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYXJndW1lbnRzIG9mIGBmdW5jYCBhbmQgZWl0aGVyIGludm9rZXNcbiAgICAgKiBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGF0IGxlYXN0IGBhcml0eWAgbnVtYmVyIG9mIGFyZ3VtZW50cyBoYXZlXG4gICAgICogYmVlbiBwcm92aWRlZCwgb3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgcmVtYWluaW5nIGBmdW5jYFxuICAgICAqIGFyZ3VtZW50cywgYW5kIHNvIG9uLiBUaGUgYXJpdHkgb2YgYGZ1bmNgIG1heSBiZSBzcGVjaWZpZWQgaWYgYGZ1bmMubGVuZ3RoYFxuICAgICAqIGlzIG5vdCBzdWZmaWNpZW50LlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyBDdXJyaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIGN1cnJpZWQoMSkoXywgMykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeS5wbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jdXJyeWAgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFyZSBhcHBsaWVkIHRvIGBmdW5jYFxuICAgICAqIGluIHRoZSBtYW5uZXIgb2YgYF8ucGFydGlhbFJpZ2h0YCBpbnN0ZWFkIG9mIGBfLnBhcnRpYWxgLlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5UmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnlSaWdodChhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgzKSgyKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMiwgMykoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiBjdXJyaWVkKDMpKDEsIF8pKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5UmlnaHQoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeVJpZ2h0LnBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAgICAgKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAgICAgKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gICAgICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gICAgICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gICAgICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICAgICAqIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICAgICAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAgICogICAnbGVhZGluZyc6IHRydWUsXG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gICAgICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gICAgICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICAgICAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAgICAgKlxuICAgICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxhc3RBcmdzLFxuICAgICAgICAgIGxhc3RUaGlzLFxuICAgICAgICAgIG1heFdhaXQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHRpbWVySWQsXG4gICAgICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgICAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICAgICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgICAgICByZXR1cm4gbWF4aW5nXG4gICAgICAgICAgPyBuYXRpdmVNaW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKVxuICAgICAgICAgIDogdGltZVdhaXRpbmc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICAgICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgICAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAgICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICAgICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICAgICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgICAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgICByZXR1cm4gZGVib3VuY2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmVycyBpbnZva2luZyB0aGUgYGZ1bmNgIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuIEFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWZlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAnZGVmZXJyZWQnKTtcbiAgICAgKiAvLyA9PiBMb2dzICdkZWZlcnJlZCcgYWZ0ZXIgb25lIG1pbGxpc2Vjb25kLlxuICAgICAqL1xuICAgIHZhciBkZWZlciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgMSwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBmdW5jYCBhZnRlciBgd2FpdGAgbWlsbGlzZWNvbmRzLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAxMDAwLCAnbGF0ZXInKTtcbiAgICAgKiAvLyA9PiBMb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZC5cbiAgICAgKi9cbiAgICB2YXIgZGVsYXkgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHRvTnVtYmVyKHdhaXQpIHx8IDAsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgcmV2ZXJzZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBmbGlwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxpcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZsaXBwZWQgPSBfLmZsaXAoZnVuY3Rpb24oKSB7XG4gICAgICogICByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBmbGlwcGVkKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gWydkJywgJ2MnLCAnYicsICdhJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGlwKGZ1bmMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfRkxJUF9GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgICAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAgICAgKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICAgICAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICAgICAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gICAgICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAgICAgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICAgICAqXG4gICAgICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB2YWx1ZXMob3RoZXIpO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqXG4gICAgICogb2JqZWN0LmEgPSAyO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gICAgICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKlxuICAgICAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gICAgICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9XG5cbiAgICAvLyBFeHBvc2UgYE1hcENhY2hlYC5cbiAgICBtZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBuZWdhdGVzIHRoZSByZXN1bHQgb2YgdGhlIHByZWRpY2F0ZSBgZnVuY2AuIFRoZVxuICAgICAqIGBmdW5jYCBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBuZWdhdGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbmVnYXRlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNFdmVuKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgXy5uZWdhdGUoaXNFdmVuKSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRlKHByZWRpY2F0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGludm9raW5nIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHNcbiAgICAgKiB0byB0aGUgZnVuY3Rpb24gcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgaW52b2NhdGlvbi4gVGhlIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIC8vID0+IGBjcmVhdGVBcHBsaWNhdGlvbmAgaXMgaW52b2tlZCBvbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50cyB0cmFuc2Zvcm1lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFt0cmFuc2Zvcm1zPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGFyZ3VtZW50IHRyYW5zZm9ybXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGRvdWJsZWQobikge1xuICAgICAqICAgcmV0dXJuIG4gKiAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJBcmdzKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiBbeCwgeV07XG4gICAgICogfSwgW3NxdWFyZSwgZG91YmxlZF0pO1xuICAgICAqXG4gICAgICogZnVuYyg5LCAzKTtcbiAgICAgKiAvLyA9PiBbODEsIDZdXG4gICAgICpcbiAgICAgKiBmdW5jKDEwLCA1KTtcbiAgICAgKiAvLyA9PiBbMTAwLCAxMF1cbiAgICAgKi9cbiAgICB2YXIgb3ZlckFyZ3MgPSBjYXN0UmVzdChmdW5jdGlvbihmdW5jLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB0cmFuc2Zvcm1zID0gKHRyYW5zZm9ybXMubGVuZ3RoID09IDEgJiYgaXNBcnJheSh0cmFuc2Zvcm1zWzBdKSlcbiAgICAgICAgPyBhcnJheU1hcCh0cmFuc2Zvcm1zWzBdLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpXG4gICAgICAgIDogYXJyYXlNYXAoYmFzZUZsYXR0ZW4odHJhbnNmb3JtcywgMSksIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG5cbiAgICAgIHZhciBmdW5jc0xlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oYXJncy5sZW5ndGgsIGZ1bmNzTGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gdHJhbnNmb3Jtc1tpbmRleF0uY2FsbCh0aGlzLCBhcmdzW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZVxuICAgICAqIGFyZ3VtZW50cyBpdCByZWNlaXZlcy4gVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5iaW5kYCBleGNlcHQgaXQgZG9lcyAqKm5vdCoqXG4gICAgICogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWwucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWwoZ3JlZXQsICdoZWxsbycpO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWwoZ3JlZXQsIF8sICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsKSk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnBhcnRpYWxgIGV4Y2VwdCB0aGF0IHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50c1xuICAgICAqIGFyZSBhcHBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWxSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2hlbGxvJywgXyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsUmlnaHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWxSaWdodCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgYXJyYW5nZWQgYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIHNwZWNpZmllZCBgaW5kZXhlc2Agd2hlcmUgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBmaXJzdCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBzZWNvbmQgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZWFycmFuZ2UgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcmd1bWVudCBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcmVhcmdlZCA9IF8ucmVhcmcoZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9LCBbMiwgMCwgMV0pO1xuICAgICAqXG4gICAgICogcmVhcmdlZCgnYicsICdjJywgJ2EnKVxuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIHZhciByZWFyZyA9IGZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmMsIGluZGV4ZXMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUkVBUkdfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaW5kZXhlcyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIGFuZCBhcmd1bWVudHMgZnJvbSBgc3RhcnRgIGFuZCBiZXlvbmQgcHJvdmlkZWQgYXNcbiAgICAgKiBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBbcmVzdCBwYXJhbWV0ZXJdKGh0dHBzOi8vbWRuLmlvL3Jlc3RfcGFyYW1ldGVycykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8ucmVzdChmdW5jdGlvbih3aGF0LCBuYW1lcykge1xuICAgICAqICAgcmV0dXJuIHdoYXQgKyAnICcgKyBfLmluaXRpYWwobmFtZXMpLmpvaW4oJywgJykgK1xuICAgICAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3QoZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jLCBzdGFydCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlIGZ1bmN0aW9uIGFuZCBhbiBhcnJheSBvZiBhcmd1bWVudHMgbXVjaCBsaWtlXG4gICAgICogW2BGdW5jdGlvbiNhcHBseWBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICAgICAqIFtzcHJlYWQgb3BlcmF0b3JdKGh0dHBzOi8vbWRuLmlvL3NwcmVhZF9vcGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBzcHJlYWQgYXJndW1lbnRzIG92ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHNwcmVhZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8uc3ByZWFkKGZ1bmN0aW9uKHdobywgd2hhdCkge1xuICAgICAqICAgcmV0dXJuIHdobyArICcgc2F5cyAnICsgd2hhdDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheShbJ2ZyZWQnLCAnaGVsbG8nXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQgc2F5cyBoZWxsbydcbiAgICAgKlxuICAgICAqIHZhciBudW1iZXJzID0gUHJvbWlzZS5hbGwoW1xuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDQwKSxcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSgzNilcbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIG51bWJlcnMudGhlbihfLnNwcmVhZChmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4geCArIHk7XG4gICAgICogfSkpO1xuICAgICAqIC8vID0+IGEgUHJvbWlzZSBvZiA3NlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwcmVhZChmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IG5hdGl2ZU1heCh0b0ludGVnZXIoc3RhcnQpLCAwKTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFyZ3Nbc3RhcnRdLFxuICAgICAgICAgICAgb3RoZXJBcmdzID0gY2FzdFNsaWNlKGFyZ3MsIDAsIHN0YXJ0KTtcblxuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBhcnJheVB1c2gob3RoZXJBcmdzLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gICAgICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAgICAgKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gICAgICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gICAgICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICAgICAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAgICAgKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gICAgICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICAgICAqXG4gICAgICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gICAgICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICAgICAqXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAgICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIG9uZSBhcmd1bWVudCwgaWdub3JpbmcgYW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8udW5hcnkocGFyc2VJbnQpKTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5hcnkoZnVuYykge1xuICAgICAgcmV0dXJuIGFyeShmdW5jLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBgdmFsdWVgIHRvIGB3cmFwcGVyYCBhcyBpdHMgZmlyc3RcbiAgICAgKiBhcmd1bWVudC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmUgYXBwZW5kZWRcbiAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYHdyYXBwZXJgLiBUaGUgd3JhcHBlciBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFt3cmFwcGVyPWlkZW50aXR5XSBUaGUgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHAgPSBfLndyYXAoXy5lc2NhcGUsIGZ1bmN0aW9uKGZ1bmMsIHRleHQpIHtcbiAgICAgKiAgIHJldHVybiAnPHA+JyArIGZ1bmModGV4dCkgKyAnPC9wPic7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBwKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICc8cD5mcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXM8L3A+J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXAodmFsdWUsIHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBwYXJ0aWFsKGNhc3RGdW5jdGlvbih3cmFwcGVyKSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgYXMgYW4gYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoMSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEgfV1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheShudWxsKTtcbiAgICAgKiAvLyA9PiBbbnVsbF1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZF1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKiBjb25zb2xlLmxvZyhfLmNhc3RBcnJheShhcnJheSkgPT09IGFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEFycmF5KCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gICAgICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwczovL21kbi5pby9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSlcbiAgICAgKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gICAgICogYXJyYXlzLiBUaGUgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBjbG9uZWRcbiAgICAgKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gICAgICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICAgICAqXG4gICAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKG9iamVjdHMpO1xuICAgICAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCxcbiAgICAgKiBjbG9uaW5nIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHVwIHRvIGZvdXIgYXJndW1lbnRzOyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIHN0YWNrXSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xuICAgICAqIC8vID0+ICdCT0RZJ1xuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lV2l0aGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZVdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVEZWVwV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGVsID09PSBkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGNvbnNvbGUubG9nKGVsLm5vZGVOYW1lKTtcbiAgICAgKiAvLyA9PiAnQk9EWSdcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXBXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgb2JqZWN0YCBjb25mb3JtcyB0byBgc291cmNlYCBieSBpbnZva2luZyB0aGUgcHJlZGljYXRlXG4gICAgICogcHJvcGVydGllcyBvZiBgc291cmNlYCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zYCB3aGVuIGBzb3VyY2VgIGlzXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xNC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqXG4gICAgICogXy5jb25mb3Jtc1RvKG9iamVjdCwgeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAxOyB9IH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMjsgfSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2UgPT0gbnVsbCB8fCBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVxKCdhJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVxKE5hTiwgTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmx0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5ndCgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBndCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUd0KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvXG4gICAgICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ubHRlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGd0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gb3RoZXI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheUJ1ZmZlcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheUJ1ZmZlcigyKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheSgyKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheUJ1ZmZlciA9IG5vZGVJc0FycmF5QnVmZmVyID8gYmFzZVVuYXJ5KG5vZGVJc0FycmF5QnVmZmVyKSA6IGJhc2VJc0FycmF5QnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICAgICAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAgICAgKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gICAgICogaXMgYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYm9vbGVhbiBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJvb2xlYW4sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGJvb2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBEYXRlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUobmV3IERhdGUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKCdNb24gQXByaWwgMjMgMjAxMicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzRGF0ZSA9IG5vZGVJc0RhdGUgPyBiYXNlVW5hcnkobm9kZUlzRGF0ZSkgOiBiYXNlSXNEYXRlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoJzxib2R5PicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAgICAgKlxuICAgICAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICAgICAqIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAgICAgKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gICAgICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkodHJ1ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgICAoaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZS5zcGxpY2UgPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8IGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICByZXR1cm4gIXZhbHVlLnNpemU7XG4gICAgICB9XG4gICAgICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAhYmFzZUtleXModmFsdWUpLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgICAqIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXG4gICAgICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICAgICAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gICAgICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXG4gICAgICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogb2JqZWN0ID09PSBvdGhlcjtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzRXF1YWxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXG4gICAgICogYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCB1cCB0b1xuICAgICAqIHNpeCBhcmd1bWVudHM6IChvYmpWYWx1ZSwgb3RoVmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIG90aGVyLCBzdGFja10pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcob3RoVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xuICAgICAqIHZhciBvdGhlciA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsV2l0aChhcnJheSwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsV2l0aCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgb3RoZXIpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCB1bmRlZmluZWQsIGN1c3RvbWl6ZXIpIDogISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCwgYEV2YWxFcnJvcmAsIGBSYW5nZUVycm9yYCwgYFJlZmVyZW5jZUVycm9yYCxcbiAgICAgKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IoRXJyb3IpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgIHJldHVybiB0YWcgPT0gZXJyb3JUYWcgfHwgdGFnID09IGRvbUV4Y1RhZyB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBwcmltaXRpdmUgbnVtYmVyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNGaW5pdGVgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNGaW5pdGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gICAgICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0ludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT0gdG9JbnRlZ2VyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgICAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gICAgICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICAgICAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gICAgICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNNYXAobmV3IE1hcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBgb2JqZWN0YCBhbmQgYHNvdXJjZWAgdG9cbiAgICAgKiBkZXRlcm1pbmUgaWYgYG9iamVjdGAgY29udGFpbnMgZXF1aXZhbGVudCBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5tYXRjaGVzYCB3aGVuIGBzb3VyY2VgIGlzXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaChvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc01hdGNoYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggZml2ZVxuICAgICAqIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwgaW5kZXh8a2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcoc3JjVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdncmVldGluZyc6ICdoZWxsbycgfTtcbiAgICAgKiB2YXIgc291cmNlID0geyAnZ3JlZXRpbmcnOiAnaGknIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaFdpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNOYU5gXShodHRwczovL21kbi5pby9OdW1iZXIvaXNOYU4pIGFuZCBpcyBub3QgdGhlIHNhbWUgYXNcbiAgICAgKiBnbG9iYWwgW2Bpc05hTmBdKGh0dHBzOi8vbWRuLmlvL2lzTmFOKSB3aGljaCByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBhbmQgb3RoZXIgbm9uLW51bWJlciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4oTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgLy8gQW4gYE5hTmAgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZi5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGB0b1N0cmluZ1RhZ2AgY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZVxuICAgICAgLy8gQWN0aXZlWCBvYmplY3RzIGluIElFLlxuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcmlzdGluZSBuYXRpdmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgY2FuJ3QgcmVsaWFibHkgZGV0ZWN0IG5hdGl2ZSBmdW5jdGlvbnMgaW4gdGhlIHByZXNlbmNlXG4gICAgICogb2YgdGhlIGNvcmUtanMgcGFja2FnZSBiZWNhdXNlIGNvcmUtanMgY2lyY3VtdmVudHMgdGhpcyBraW5kIG9mIGRldGVjdGlvbi5cbiAgICAgKiBEZXNwaXRlIG11bHRpcGxlIHJlcXVlc3RzLCB0aGUgY29yZS1qcyBtYWludGFpbmVyIGhhcyBtYWRlIGl0IGNsZWFyOiBhbnlcbiAgICAgKiBhdHRlbXB0IHRvIGZpeCB0aGUgZGV0ZWN0aW9uIHdpbGwgYmUgb2JzdHJ1Y3RlZC4gQXMgYSByZXN1bHQsIHdlJ3JlIGxlZnRcbiAgICAgKiB3aXRoIGxpdHRsZSBjaG9pY2UgYnV0IHRvIHRocm93IGFuIGVycm9yLiBVbmZvcnR1bmF0ZWx5LCB0aGlzIGFsc28gYWZmZWN0c1xuICAgICAqIHBhY2thZ2VzLCBsaWtlIFtiYWJlbC1wb2x5ZmlsbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYmFiZWwtcG9seWZpbGwpLFxuICAgICAqIHdoaWNoIHJlbHkgb24gY29yZS1qcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShfKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAoaXNNYXNrYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKENPUkVfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbCh2b2lkIDApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBudWxsaXNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05pbCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE51bWJlcmAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZVxuICAgICAqIGNsYXNzaWZpZWQgYXMgbnVtYmVycywgdXNlIHRoZSBgXy5pc0Zpbml0ZWAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gbnVtYmVyVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gICAgICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuOC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICAgICAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBSZWdFeHBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgvYWJjLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgnL2FiYy8nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1JlZ0V4cCA9IG5vZGVJc1JlZ0V4cCA/IGJhc2VVbmFyeShub2RlSXNSZWdFeHApIDogYmFzZUlzUmVnRXhwO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBzYWZlIGludGVnZXIuIEFuIGludGVnZXIgaXMgc2FmZSBpZiBpdCdzIGFuIElFRUUtNzU0XG4gICAgICogZG91YmxlIHByZWNpc2lvbiBudW1iZXIgd2hpY2ggaXNuJ3QgdGhlIHJlc3VsdCBvZiBhIHJvdW5kZWQgdW5zYWZlIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc1NhZmVJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzU2FmZUludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNhZmUgaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0ludGVnZXIodmFsdWUpICYmIHZhbHVlID49IC1NQVhfU0FGRV9JTlRFR0VSICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFdlYWtNYXBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB3ZWFrIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgV2Vha01hcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtNYXAobmV3IE1hcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gd2Vha01hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFdlYWtTZXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB3ZWFrIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgV2Vha1NldCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtTZXQobmV3IFNldCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHdlYWtTZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5ndFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0KDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHQoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8ubHQoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHQgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VMdCk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmd0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDw9IG90aGVyO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0FycmF5KHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KDEpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkobnVsbCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSA/IHN0cmluZ1RvQXJyYXkodmFsdWUpIDogY29weUFycmF5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzeW1JdGVyYXRvciAmJiB2YWx1ZVtzeW1JdGVyYXRvcl0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVG9BcnJheSh2YWx1ZVtzeW1JdGVyYXRvcl0oKSk7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICBmdW5jID0gdGFnID09IG1hcFRhZyA/IG1hcFRvQXJyYXkgOiAodGFnID09IHNldFRhZyA/IHNldFRvQXJyYXkgOiB2YWx1ZXMpO1xuXG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoMy4yKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gNWUtMzI0XG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICAgICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcigzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlciBzdWl0YWJsZSBmb3IgdXNlIGFzIHRoZSBsZW5ndGggb2YgYW5cbiAgICAgKiBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDQyOTQ5NjcyOTVcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIDAsIE1BWF9BUlJBWV9MRU5HVEgpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b051bWJlcigzLjIpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqXG4gICAgICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiA1ZS0zMjRcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IEluZmluaXR5XG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBOQU47XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gICAgICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICAgICAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgICAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gICAgICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzYWZlIGludGVnZXIuIEEgc2FmZSBpbnRlZ2VyIGNhbiBiZSBjb21wYXJlZCBhbmRcbiAgICAgKiByZXByZXNlbnRlZCBjb3JyZWN0bHkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcigzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDkwMDcxOTkyNTQ3NDA5OTFcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcignMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUilcbiAgICAgICAgOiAodmFsdWUgPT09IDAgPyB2YWx1ZSA6IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gICAgICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1N0cmluZyhudWxsKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqXG4gICAgICogXy50b1N0cmluZygtMCk7XG4gICAgICogLy8gPT4gJy0wJ1xuICAgICAqXG4gICAgICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+ICcxLDIsMydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgKiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YCBhbmQgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgT2JqZWN0LmFzc2lnbmBdKGh0dHBzOi8vbWRuLmlvL09iamVjdC9hc3NpZ24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduSW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBCYXIoKSB7XG4gICAgICogICB0aGlzLmMgPSAzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gICAgICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgaWYgKGlzUHJvdG90eXBlKHNvdXJjZSkgfHwgaXNBcnJheUxpa2Uoc291cmNlKSkge1xuICAgICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIG93biBhbmRcbiAgICAgKiBpbmhlcml0ZWQgc291cmNlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBleHRlbmRcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcbiAgICAgKiAgIHRoaXMuYyA9IDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgICAqXG4gICAgICogXy5hc3NpZ25Jbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMsICdkJzogNCB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbkluID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduSW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduSW5XaXRoLCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25JbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbkluV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbldpdGgsIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIGBwYXRoc2Agb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcGlja2VkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfSwgNF0gfTtcbiAgICAgKlxuICAgICAqIF8uYXQob2JqZWN0LCBbJ2FbMF0uYi5jJywgJ2FbMV0nXSk7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICovXG4gICAgdmFyIGF0ID0gZmxhdFJlc3QoYmFzZUF0KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBnaXZlbiwgaXRzIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzXG4gICAgICogYXJlIGFzc2lnbmVkIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gVGhlIHByb3BlcnRpZXMgdG8gYXNzaWduIHRvIHRoZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgICogICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIENpcmNsZS5wcm90b3R5cGUgPSBfLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUsIHtcbiAgICAgKiAgICdjb25zdHJ1Y3Rvcic6IENpcmNsZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNpcmNsZSA9IG5ldyBDaXJjbGU7XG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgQ2lyY2xlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIFNoYXBlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXMgPT0gbnVsbCA/IHJlc3VsdCA6IGJhc2VBc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlXG4gICAgICogb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0XG4gICAgICogcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIE9uY2UgYSBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmRlZmF1bHRzRGVlcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0cyA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgdmFyIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoO1xuICAgICAgdmFyIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICB2YXIgcHJvcHMgPSBrZXlzSW4oc291cmNlKTtcbiAgICAgICAgdmFyIHByb3BzSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK3Byb3BzSW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1twcm9wc0luZGV4XTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgIChlcSh2YWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGVmYXVsdHNgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGFzc2lnbnNcbiAgICAgKiBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmRlZmF1bHRzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHNEZWVwKHsgJ2EnOiB7ICdiJzogMiB9IH0sIHsgJ2EnOiB7ICdiJzogMSwgJ2MnOiAzIH0gfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiAyLCAnYyc6IDMgfSB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzRGVlcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIGFyZ3MucHVzaCh1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UpO1xuICAgICAgcmV0dXJuIGFwcGx5KG1lcmdlV2l0aCwgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUga2V5IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsXG4gICAgICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5JyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmRLZXkob2JqZWN0LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBiYXNlRm9yT3duKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRLZXlgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBhIGNvbGxlY3Rpb24gaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsXG4gICAgICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gcmV0dXJucyAncGViYmxlcycgYXNzdW1pbmcgYF8uZmluZEtleWAgcmV0dXJucyAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd25SaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuXG4gICAgICogb2JqZWN0IGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXRcbiAgICAgKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvckluUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJywgJ2InLCB0aGVuICdjJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGxcbiAgICAgICAgPyBvYmplY3RcbiAgICAgICAgOiBiYXNlRm9yKG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9ySW5gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvckluXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdjJywgJ2InLCB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JJbmAgbG9ncyAnYScsICdiJywgdGhlbiAnYycuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW5SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGxcbiAgICAgICAgPyBvYmplY3RcbiAgICAgICAgOiBiYXNlRm9yUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgYW5kXG4gICAgICogaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvblxuICAgICAqIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JPd25SaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JPd24obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duKG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvck93bmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9yT3duXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYicgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9yT3duYCBsb2dzICdhJyB0aGVuICdiJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAgICAgKiBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqIEBzZWUgXy5mdW5jdGlvbnNJblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSBfLmNvbnN0YW50KCdhJyk7XG4gICAgICogICB0aGlzLmIgPSBfLmNvbnN0YW50KCdiJyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gXy5jb25zdGFudCgnYycpO1xuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9ucyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIG93biBhbmQgaW5oZXJpdGVkXG4gICAgICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSBfLmNvbnN0YW50KCdhJyk7XG4gICAgICogICB0aGlzLmIgPSBfLmNvbnN0YW50KCdiJyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gXy5jb25zdGFudCgnYycpO1xuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICAgICAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiB7ICdiJzogMiB9IH07XG4gICAgICogdmFyIG90aGVyID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob3RoZXIsICdhJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqIElmIGBvYmplY3RgIGNvbnRhaW5zIGR1cGxpY2F0ZSB2YWx1ZXMsIHN1YnNlcXVlbnQgdmFsdWVzIG92ZXJ3cml0ZVxuICAgICAqIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6ICdjJywgJzInOiAnYicgfVxuICAgICAqL1xuICAgIHZhciBpbnZlcnQgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0W3ZhbHVlXSA9IGtleTtcbiAgICB9LCBjb25zdGFudChpZGVudGl0eSkpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnZlcnRgIGV4Y2VwdCB0aGF0IHRoZSBpbnZlcnRlZCBvYmplY3QgaXMgZ2VuZXJhdGVkXG4gICAgICogZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nIGVhY2ggZWxlbWVudCBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgaW52ZXJ0ZWQgdmFsdWUgb2YgZWFjaCBpbnZlcnRlZCBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5c1xuICAgICAqIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBpbnZlcnRlZCB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqXG4gICAgICogXy5pbnZlcnRCeShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gJ2dyb3VwJyArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2dyb3VwMSc6IFsnYScsICdjJ10sICdncm91cDInOiBbJ2InXSB9XG4gICAgICovXG4gICAgdmFyIGludmVydEJ5ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdFt2YWx1ZV0ucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IFtrZXldO1xuICAgICAgfVxuICAgIH0sIGdldEl0ZXJhdGVlKTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiBbMSwgMiwgMywgNF0gfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5pbnZva2Uob2JqZWN0LCAnYVswXS5iLmMuc2xpY2UnLCAxLCAzKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICB2YXIgaW52b2tlID0gYmFzZVJlc3QoYmFzZUludm9rZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gICAgICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy5rZXlzKCdoaScpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5c0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tYXBWYWx1ZXNgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZVxuICAgICAqIHNhbWUgdmFsdWVzIGFzIGBvYmplY3RgIGFuZCBrZXlzIGdlbmVyYXRlZCBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGVcbiAgICAgKiBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgXy5tYXBWYWx1ZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXBLZXlzKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgcmV0dXJuIGtleSArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ExJzogMSwgJ2IyJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwS2V5cyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkXG4gICAgICogYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAc2VlIF8ubWFwS2V5c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnZnJlZCc6ICAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAgICAgKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICAgICAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICAgICAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlciA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lcmdlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb24gYW5kIHNvdXJjZVxuICAgICAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXG4gICAgICogbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHNpeCBhcmd1bWVudHM6XG4gICAgICogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFsxXSwgJ2InOiBbMl0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogWzNdLCAnYic6IFs0XSB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZVdpdGgob2JqZWN0LCBvdGhlciwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4geyAnYSc6IFsxLCAzXSwgJ2InOiBbMiwgNF0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZVdpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGVcbiAgICAgKiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IHBhdGhzIG9mIGBvYmplY3RgIHRoYXQgYXJlIG5vdCBvbWl0dGVkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGNvbnNpZGVyYWJseSBzbG93ZXIgdGhhbiBgXy5waWNrYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIG9taXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXQob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cbiAgICAgKi9cbiAgICB2YXIgb21pdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgcGF0aHMgPSBhcnJheU1hcChwYXRocywgZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgaXNEZWVwIHx8IChpc0RlZXAgPSBwYXRoLmxlbmd0aCA+IDEpO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH0pO1xuICAgICAgY29weU9iamVjdChvYmplY3QsIGdldEFsbEtleXNJbihvYmplY3QpLCByZXN1bHQpO1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICByZXN1bHQgPSBiYXNlQ2xvbmUocmVzdWx0LCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9GTEFUX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbU9taXRDbG9uZSk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGJhc2VVbnNldChyZXN1bHQsIHBhdGhzW2xlbmd0aF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrQnlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZlxuICAgICAqIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgIHRoYXRcbiAgICAgKiBgcHJlZGljYXRlYCBkb2Vzbid0IHJldHVybiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d29cbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5vbWl0Qnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbWl0Qnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBwaWNrQnkob2JqZWN0LCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICB2YXIgcGljayA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgYG9iamVjdGAgcHJvcGVydGllcyBgcHJlZGljYXRlYCByZXR1cm5zXG4gICAgICogdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2tCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2tCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wcyA9IGFycmF5TWFwKGdldEFsbEtleXNJbihvYmplY3QpLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHJldHVybiBbcHJvcF07XG4gICAgICB9KTtcbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSk7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHByb3BzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlKHZhbHVlLCBwYXRoWzBdKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZ2V0YCBleGNlcHQgdGhhdCBpZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXMgYVxuICAgICAqIGZ1bmN0aW9uIGl0J3MgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBpdHMgcGFyZW50IG9iamVjdCBhbmRcbiAgICAgKiBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MxJzogMywgJ2MyJzogXy5jb25zdGFudCg0KSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzEnKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzInKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMzJywgXy5jb25zdGFudCgnZGVmYXVsdCcpKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgLy8gRW5zdXJlIHRoZSBsb29wIGlzIGVudGVyZWQgd2hlbiBwYXRoIGlzIGVtcHR5LlxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgb2JqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3RbdG9LZXkocGF0aFtpbmRleF0pXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcbiAgICAgKiBpdCdzIGNyZWF0ZWQuIEFycmF5cyBhcmUgY3JlYXRlZCBmb3IgbWlzc2luZyBpbmRleCBwcm9wZXJ0aWVzIHdoaWxlIG9iamVjdHNcbiAgICAgKiBhcmUgY3JlYXRlZCBmb3IgYWxsIG90aGVyIG1pc3NpbmcgcHJvcGVydGllcy4gVXNlIGBfLnNldFdpdGhgIHRvIGN1c3RvbWl6ZVxuICAgICAqIGBwYXRoYCBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsIFsneCcsICcwJywgJ3knLCAneiddLCA1KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xuICAgICAqXG4gICAgICogXy5zZXRXaXRoKG9iamVjdCwgJ1swXVsxXScsICdhJywgT2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRXaXRoKG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgXG4gICAgICogd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwIG9yIHNldCwgaXRzXG4gICAgICogZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgdG9QYWlycyA9IGNyZWF0ZVRvUGFpcnMoa2V5cyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkLXZhbHVlIHBhaXJzXG4gICAgICogZm9yIGBvYmplY3RgIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcFxuICAgICAqIG9yIHNldCwgaXRzIGVudHJpZXMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGVudHJpZXNJblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdLCBbJ2MnLCAzXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgdG9QYWlyc0luID0gY3JlYXRlVG9QYWlycyhrZXlzSW4pO1xuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd25cbiAgICAgKiBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIHRocnUgYGl0ZXJhdGVlYCwgd2l0aCBlYWNoIGludm9jYXRpb25cbiAgICAgKiBwb3RlbnRpYWxseSBtdXRhdGluZyB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIElmIGBhY2N1bXVsYXRvcmAgaXMgbm90XG4gICAgICogcHJvdmlkZWQsIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGBbW1Byb3RvdHlwZV1dYCB3aWxsIGJlIHVzZWQuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAgICAgKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDldXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgICAgaXNBcnJMaWtlID0gaXNBcnIgfHwgaXNCdWZmZXIob2JqZWN0KSB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KTtcblxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCk7XG4gICAgICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgICAgICB2YXIgQ3RvciA9IG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICAgIGlmIChpc0Fyckxpa2UpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzQXJyID8gbmV3IEN0b3IgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0Z1bmN0aW9uKEN0b3IpID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSkgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAoaXNBcnJMaWtlID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHByb3BlcnR5IGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVuc2V0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDcgfSB9XSB9O1xuICAgICAqIF8udW5zZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHRydWUgOiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgYWNjZXB0cyBgdXBkYXRlcmAgdG8gcHJvZHVjZSB0aGVcbiAgICAgKiB2YWx1ZSB0byBzZXQuIFVzZSBgXy51cGRhdGVXaXRoYCB0byBjdXN0b21pemUgYHBhdGhgIGNyZWF0aW9uLiBUaGUgYHVwZGF0ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICdhWzBdLmIuYycsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gKiBuOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ3hbMF0ueS56JywgZnVuY3Rpb24obikgeyByZXR1cm4gbiA/IG4gKyAxIDogMDsgfSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlcikge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIGNhc3RGdW5jdGlvbih1cGRhdGVyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51cGRhdGVgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogcGF0aCBjcmVhdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6IChuc1ZhbHVlLCBrZXksIG5zT2JqZWN0KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZVdpdGgob2JqZWN0LCAnWzBdWzFdJywgXy5jb25zdGFudCgnYScpLCBPYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVdpdGgob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLnZhbHVlcygnaGknKTtcbiAgICAgKiAvLyA9PiBbJ2gnLCAnaSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eVxuICAgICAqIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIGBudW1iZXJgIHdpdGhpbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jbGFtcCgtMTAsIC01LCA1KTtcbiAgICAgKiAvLyA9PiAtNVxuICAgICAqXG4gICAgICogXy5jbGFtcCgxMCwgLTUsIDUpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgbG93ZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cHBlciA9IHRvTnVtYmVyKHVwcGVyKTtcbiAgICAgICAgdXBwZXIgPSB1cHBlciA9PT0gdXBwZXIgPyB1cHBlciA6IDA7XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb3dlciA9IHRvTnVtYmVyKGxvd2VyKTtcbiAgICAgICAgbG93ZXIgPSBsb3dlciA9PT0gbG93ZXIgPyBsb3dlciA6IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUNsYW1wKHRvTnVtYmVyKG51bWJlciksIGxvd2VyLCB1cHBlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBuYCBpcyBiZXR3ZWVuIGBzdGFydGAgYW5kIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIElmXG4gICAgICogYGVuZGAgaXMgbm90IHNwZWNpZmllZCwgaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICAgICAqIElmIGBzdGFydGAgaXMgZ3JlYXRlciB0aGFuIGBlbmRgIHRoZSBwYXJhbXMgYXJlIHN3YXBwZWQgdG8gc3VwcG9ydFxuICAgICAqIG5lZ2F0aXZlIHJhbmdlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5yYW5nZSwgXy5yYW5nZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgzLCAyLCA0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgOCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMiwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgxLjIsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg1LjIsIDQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoLTMsIC0yLCAtNik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICAgIH1cbiAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICByZXR1cm4gYmFzZUluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxuICAgICAqIElmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyXG4gICAgICogaXMgcmV0dXJuZWQuIElmIGBmbG9hdGluZ2AgaXMgYHRydWVgLCBvciBlaXRoZXIgYGxvd2VyYCBvciBgdXBwZXJgIGFyZVxuICAgICAqIGZsb2F0cywgYSBmbG9hdGluZy1wb2ludCBudW1iZXIgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcj0wXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt1cHBlcj0xXSBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZmxvYXRpbmddIFNwZWNpZnkgcmV0dXJuaW5nIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDAsIDUpO1xuICAgICAqIC8vID0+IGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1KTtcbiAgICAgKiAvLyA9PiBhbHNvIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1LCB0cnVlKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDEuMiwgNS4yKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDEuMiBhbmQgNS4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tKGxvd2VyLCB1cHBlciwgZmxvYXRpbmcpIHtcbiAgICAgIGlmIChmbG9hdGluZyAmJiB0eXBlb2YgZmxvYXRpbmcgIT0gJ2Jvb2xlYW4nICYmIGlzSXRlcmF0ZWVDYWxsKGxvd2VyLCB1cHBlciwgZmxvYXRpbmcpKSB7XG4gICAgICAgIHVwcGVyID0gZmxvYXRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHVwcGVyID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gdXBwZXI7XG4gICAgICAgICAgdXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxvd2VyID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbG93ZXI7XG4gICAgICAgICAgbG93ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciA9PT0gdW5kZWZpbmVkICYmIHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICB1cHBlciA9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbG93ZXIgPSB0b0Zpbml0ZShsb3dlcik7XG4gICAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBwZXIgPSB0b0Zpbml0ZSh1cHBlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciA+IHVwcGVyKSB7XG4gICAgICAgIHZhciB0ZW1wID0gbG93ZXI7XG4gICAgICAgIGxvd2VyID0gdXBwZXI7XG4gICAgICAgIHVwcGVyID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyB8fCBsb3dlciAlIDEgfHwgdXBwZXIgJSAxKSB7XG4gICAgICAgIHZhciByYW5kID0gbmF0aXZlUmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNaW4obG93ZXIgKyAocmFuZCAqICh1cHBlciAtIGxvd2VyICsgZnJlZVBhcnNlRmxvYXQoJzFlLScgKyAoKHJhbmQgKyAnJykubGVuZ3RoIC0gMSkpKSksIHVwcGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcik7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2NhbWVsIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbWVsQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYW1lbCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqL1xuICAgIHZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gY2FwaXRhbGl6ZSh3b3JkKSA6IHdvcmQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlIGFuZCB0aGUgcmVtYWluaW5nXG4gICAgICogdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXBpdGFsaXplKCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiB1cHBlckZpcnN0KHRvU3RyaW5nKHN0cmluZykudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXG4gICAgICogW0xhdGluLTEgU3VwcGxlbWVudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW4tMV9TdXBwbGVtZW50XyhVbmljb2RlX2Jsb2NrKSNDaGFyYWN0ZXJfdGFibGUpXG4gICAgICogYW5kIFtMYXRpbiBFeHRlbmRlZC1BXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9FeHRlbmRlZC1BKVxuICAgICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcbiAgICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGRlYnVyci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcbiAgICAgKiAvLyA9PiAnZGVqYSB2dSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluLCBkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPXN0cmluZy5sZW5ndGhdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggdXAgdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCBgdGFyZ2V0YCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJywgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGxlbmd0aFxuICAgICAgICA6IGJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLCAwLCBsZW5ndGgpO1xuXG4gICAgICB2YXIgZW5kID0gcG9zaXRpb247XG4gICAgICBwb3NpdGlvbiAtPSB0YXJnZXQubGVuZ3RoO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID49IDAgJiYgc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBlbmQpID09IHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBhbmQgXCInXCIgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWxcbiAgICAgKiBjaGFyYWN0ZXJzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIFRob3VnaCB0aGUgXCI+XCIgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2VcbiAgICAgKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuICAgICAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcbiAgICAgKiBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXG4gICAgICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzXG4gICAgICogW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKSB0byByZWR1Y2VcbiAgICAgKiBYU1MgdmVjdG9ycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlcyB0aGUgYFJlZ0V4cGAgc3BlY2lhbCBjaGFyYWN0ZXJzIFwiXlwiLCBcIiRcIiwgXCJcXFwiLCBcIi5cIiwgXCIqXCIsIFwiK1wiLFxuICAgICAqIFwiP1wiLCBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIl1cIiwgXCJ7XCIsIFwifVwiLCBhbmQgXCJ8XCIgaW4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZVJlZ0V4cCgnW2xvZGFzaF0oaHR0cHM6Ly9sb2Rhc2guY29tLyknKTtcbiAgICAgKiAvLyA9PiAnXFxbbG9kYXNoXFxdXFwoaHR0cHM6Ly9sb2Rhc2hcXC5jb20vXFwpJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1JlZ0V4cENoYXIudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW2tlYmFiIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1NwZWNpYWxfY2FzZV9zdHlsZXMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICovXG4gICAgdmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICctJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCctLUZvby1CYXItLScpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICovXG4gICAgdmFyIGxvd2VyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubG93ZXJGaXJzdCgnRnJlZCcpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ2ZSRUQnXG4gICAgICovXG4gICAgdmFyIGxvd2VyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvTG93ZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlcyBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC5cbiAgICAgKiBQYWRkaW5nIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGNhbid0IGJlIGV2ZW5seSBkaXZpZGVkIGJ5IGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4KTtcbiAgICAgKiAvLyA9PiAnICBhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHN0ckxlbmd0aCA+PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBtaWQgPSAobGVuZ3RoIC0gc3RyTGVuZ3RoKSAvIDI7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBjcmVhdGVQYWRkaW5nKG5hdGl2ZUZsb29yKG1pZCksIGNoYXJzKSArXG4gICAgICAgIHN0cmluZyArXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlQ2VpbChtaWQpLCBjaGFycylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgcmlnaHQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJ2FiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkRW5kKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgPyAoc3RyaW5nICsgY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSlcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICcgICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1fYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWRTdGFydChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICByZXR1cm4gKGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGgpXG4gICAgICAgID8gKGNyZWF0ZVBhZGRpbmcobGVuZ3RoIC0gc3RyTGVuZ3RoLCBjaGFycykgKyBzdHJpbmcpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC4gSWYgYHJhZGl4YCBpc1xuICAgICAqIGB1bmRlZmluZWRgIG9yIGAwYCwgYSBgcmFkaXhgIG9mIGAxMGAgaXMgdXNlZCB1bmxlc3MgYHZhbHVlYCBpcyBhXG4gICAgICogaGV4YWRlY2ltYWwsIGluIHdoaWNoIGNhc2UgYSBgcmFkaXhgIG9mIGAxNmAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhbGlnbnMgd2l0aCB0aGVcbiAgICAgKiBbRVM1IGltcGxlbWVudGF0aW9uXShodHRwczovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuMikgb2YgYHBhcnNlSW50YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4PTEwXSBUaGUgcmFkaXggdG8gaW50ZXJwcmV0IGB2YWx1ZWAgYnkuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYXJzZUludCgnMDgnKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnMDgnLCAnMTAnXSwgXy5wYXJzZUludCk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlSW50KHN0cmluZywgcmFkaXgsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgfHwgcmFkaXggPT0gbnVsbCkge1xuICAgICAgICByYWRpeCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHJhZGl4KSB7XG4gICAgICAgIHJhZGl4ID0gK3JhZGl4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KHRvU3RyaW5nKHN0cmluZykucmVwbGFjZShyZVRyaW1TdGFydCwgJycpLCByYWRpeCB8fCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBlYXRzIHRoZSBnaXZlbiBzdHJpbmcgYG5gIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBlYXQoJyonLCAzKTtcbiAgICAgKiAvLyA9PiAnKioqJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDIpO1xuICAgICAqIC8vID0+ICdhYmNhYmMnXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBuLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJlcGVhdCh0b1N0cmluZyhzdHJpbmcpLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBtYXRjaGVzIGZvciBgcGF0dGVybmAgaW4gYHN0cmluZ2Agd2l0aCBgcmVwbGFjZW1lbnRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BTdHJpbmcjcmVwbGFjZWBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9yZXBsYWNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IHJlcGxhY2VtZW50IFRoZSBtYXRjaCByZXBsYWNlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBtb2RpZmllZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVwbGFjZSgnSGkgRnJlZCcsICdGcmVkJywgJ0Jhcm5leScpO1xuICAgICAqIC8vID0+ICdIaSBCYXJuZXknXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZSgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKGFyZ3NbMF0pO1xuXG4gICAgICByZXR1cm4gYXJncy5sZW5ndGggPCAzID8gc3RyaW5nIDogc3RyaW5nLnJlcGxhY2UoYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBbc25ha2UgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU25ha2VfY2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzbmFrZSBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnLS1GT08tQkFSLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKi9cbiAgICB2YXIgc25ha2VDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJ18nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BTdHJpbmcjc3BsaXRgXShodHRwczovL21kbi5pby9TdHJpbmcvc3BsaXQpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNwbGl0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gc2VwYXJhdG9yIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byBzcGxpdCBieS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBUaGUgbGVuZ3RoIHRvIHRydW5jYXRlIHJlc3VsdHMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzdHJpbmcgc2VnbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3BsaXQoJ2EtYi1jJywgJy0nLCAyKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3BsaXQoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICBpZiAobGltaXQgJiYgdHlwZW9mIGxpbWl0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gbGltaXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBsaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfQVJSQVlfTEVOR1RIIDogbGltaXQgPj4+IDA7XG4gICAgICBpZiAoIWxpbWl0KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChcbiAgICAgICAgICAgIHR5cGVvZiBzZXBhcmF0b3IgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIChzZXBhcmF0b3IgIT0gbnVsbCAmJiAhaXNSZWdFeHAoc2VwYXJhdG9yKSlcbiAgICAgICAgICApKSB7XG4gICAgICAgIHNlcGFyYXRvciA9IGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoIXNlcGFyYXRvciAmJiBoYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICAgICAgICByZXR1cm4gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkoc3RyaW5nKSwgMCwgbGltaXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW3N0YXJ0IGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1N0eWxpc3RpY19vcl9zcGVjaWFsaXNlZF91c2FnZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdGFydCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICovXG4gICAgdmFyIHN0YXJ0Q2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHVwcGVyRmlyc3Qod29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249MF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCBgdGFyZ2V0YCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PSBudWxsXG4gICAgICAgID8gMFxuICAgICAgICA6IGJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLCAwLCBzdHJpbmcubGVuZ3RoKTtcblxuICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIHRhcmdldC5sZW5ndGgpID09IHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCBjYW4gaW50ZXJwb2xhdGUgZGF0YSBwcm9wZXJ0aWVzXG4gICAgICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cbiAgICAgKiBcImVzY2FwZVwiIGRlbGltaXRlcnMsIGFuZCBleGVjdXRlIEphdmFTY3JpcHQgaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuIERhdGFcbiAgICAgKiBwcm9wZXJ0aWVzIG1heSBiZSBhY2Nlc3NlZCBhcyBmcmVlIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUuIElmIGEgc2V0dGluZ1xuICAgICAqIG9iamVjdCBpcyBnaXZlbiwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXG4gICAgICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gICAgICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICAgICAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICAgICAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXNjYXBlXVxuICAgICAqICBUaGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXZhbHVhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmV2YWx1YXRlXVxuICAgICAqICBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0cz1fLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c11cbiAgICAgKiAgQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxuICAgICAqICBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMPSdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzW25dJ11cbiAgICAgKiAgVGhlIHNvdXJjZVVSTCBvZiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhcmlhYmxlPSdvYmonXVxuICAgICAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlciB0byBlc2NhcGUgZGF0YSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBfLmZvckVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBFUyB0ZW1wbGF0ZSBsaXRlcmFsIGRlbGltaXRlciBhcyBhbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIC8vIERpc2FibGUgc3VwcG9ydCBieSByZXBsYWNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dC5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JT0gXCJcXFxcPCUtIHZhbHVlICVcXFxcPlwiICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gICAgICogLy8gPT4gJzwlLSB2YWx1ZSAlPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cbiAgICAgKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAgICAgKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAvLyAgIHJldHVybiBfX3A7XG4gICAgICogLy8gfVxuICAgICAqXG4gICAgICogLy8gVXNlIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLlxuICAgICAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXG4gICAgICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2pzdC5qcycpLCAnXFxcbiAgICAgKiAgIHZhciBKU1QgPSB7XFxcbiAgICAgKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAgICAgKiAgIH07XFxcbiAgICAgKiAnKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG4gICAgICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gICAgICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzIChodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UKS5cbiAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuXG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBvcHRpb25zID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbik7XG5cbiAgICAgIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgICAgIHZhciBpc0VzY2FwaW5nLFxuICAgICAgICAgIGlzRXZhbHVhdGluZyxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgICAgIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgICAgIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICAgICAsICdnJyk7XG5cbiAgICAgIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgIC8vIFRoZSBzb3VyY2VVUkwgZ2V0cyBpbmplY3RlZCBpbnRvIHRoZSBzb3VyY2UgdGhhdCdzIGV2YWwtZWQsIHNvIGJlIGNhcmVmdWxcbiAgICAgIC8vIHdpdGggbG9va3VwIChpbiBjYXNlIG9mIGUuZy4gcHJvdG90eXBlIHBvbGx1dGlvbiksIGFuZCBzdHJpcCBuZXdsaW5lcyBpZiBhbnkuXG4gICAgICAvLyBBIG5ld2xpbmUgd291bGRuJ3QgYmUgYSB2YWxpZCBzb3VyY2VVUkwgYW55d2F5LCBhbmQgaXQnZCBlbmFibGUgY29kZSBpbmplY3Rpb24uXG4gICAgICB2YXIgc291cmNlVVJMID0gJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzb3VyY2VVUkwnKVxuICAgICAgICAgID8gKG9wdGlvbnMuc291cmNlVVJMICsgJycpLnJlcGxhY2UoL1tcXHJcXG5dL2csICcgJylcbiAgICAgICAgICA6ICgnbG9kYXNoLnRlbXBsYXRlU291cmNlc1snICsgKCsrdGVtcGxhdGVDb3VudGVyKSArICddJylcbiAgICAgICAgKSArICdcXG4nO1xuXG4gICAgICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAgICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgICAgIHNvdXJjZSArPSBzdHJpbmcuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxuICAgICAgICAvLyBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlLlxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAgICAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICAgICAgLy8gTGlrZSB3aXRoIHNvdXJjZVVSTCwgd2UgdGFrZSBjYXJlIHRvIG5vdCBjaGVjayB0aGUgb3B0aW9uJ3MgcHJvdG90eXBlLFxuICAgICAgLy8gYXMgdGhpcyBjb25maWd1cmF0aW9uIGlzIGEgY29kZSBpbmplY3Rpb24gdmVjdG9yLlxuICAgICAgdmFyIHZhcmlhYmxlID0gaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAndmFyaWFibGUnKSAmJiBvcHRpb25zLnZhcmlhYmxlO1xuICAgICAgaWYgKCF2YXJpYWJsZSkge1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIENsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5ncy5cbiAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAgICAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgICAgIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAgICAgKHZhcmlhYmxlXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgICAgIChpc0VzY2FwaW5nXG4gICAgICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXG4gICAgICAgICAgIDogJydcbiAgICAgICAgKSArXG4gICAgICAgIChpc0V2YWx1YXRpbmdcbiAgICAgICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgICAgIDogJztcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBzb3VyY2UgK1xuICAgICAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpXG4gICAgICAgICAgLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gICAgICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gbG93ZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvTG93ZXJDYXNlXShodHRwczovL21kbi5pby90b0xvd2VyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignLS1Gb28tQmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1mb28tYmFyLS0nXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29iYXInXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ19fZm9vX2Jhcl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTG93ZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gdXBwZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvVXBwZXJDYXNlXShodHRwczovL21kbi5pby90b1VwcGVyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1GT08tQkFSLS0nXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT09CQVInXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ19fRk9PX0JBUl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvVXBwZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy5tYXAoWycgIGZvbyAgJywgJyAgYmFyICAnXSwgXy50cmltKTtcbiAgICAgKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW0oc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIGNoclN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KGNoYXJzKSxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSxcbiAgICAgICAgICBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpICsgMTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCwgZW5kKS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1FbmQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW1FbmQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICctXy1hYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbUVuZChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1FbmQsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSkgKyAxO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1TdGFydCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMgICdcbiAgICAgKlxuICAgICAqIF8udHJpbVN0YXJ0KCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjLV8tJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1TdGFydChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1TdGFydCwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSk7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyBgc3RyaW5nYCBpZiBpdCdzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogVGhlIGxhc3QgY2hhcmFjdGVycyBvZiB0aGUgdHJ1bmNhdGVkIHN0cmluZyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgb21pc3Npb25cbiAgICAgKiBzdHJpbmcgd2hpY2ggZGVmYXVsdHMgdG8gXCIuLi5cIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cnVuY2F0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGVuZ3RoPTMwXSBUaGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vbWlzc2lvbj0nLi4uJ10gVGhlIHN0cmluZyB0byBpbmRpY2F0ZSB0ZXh0IGlzIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbb3B0aW9ucy5zZXBhcmF0b3JdIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byB0cnVuY2F0ZSB0by5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cnVuY2F0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJyk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hiby4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogJyAnXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6IC8sPyArL1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ29taXNzaW9uJzogJyBbLi4uXSdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnIFsuLi5dJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgdmFyIGxlbmd0aCA9IERFRkFVTFRfVFJVTkNfTEVOR1RILFxuICAgICAgICAgIG9taXNzaW9uID0gREVGQVVMVF9UUlVOQ19PTUlTU0lPTjtcblxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSAnc2VwYXJhdG9yJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zZXBhcmF0b3IgOiBzZXBhcmF0b3I7XG4gICAgICAgIGxlbmd0aCA9ICdsZW5ndGgnIGluIG9wdGlvbnMgPyB0b0ludGVnZXIob3B0aW9ucy5sZW5ndGgpIDogbGVuZ3RoO1xuICAgICAgICBvbWlzc2lvbiA9ICdvbWlzc2lvbicgaW4gb3B0aW9ucyA/IGJhc2VUb1N0cmluZyhvcHRpb25zLm9taXNzaW9uKSA6IG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBpZiAoaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpO1xuICAgICAgICBzdHJMZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPj0gc3RyTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoIC0gc3RyaW5nU2l6ZShvbWlzc2lvbik7XG4gICAgICBpZiAoZW5kIDwgMSkge1xuICAgICAgICByZXR1cm4gb21pc3Npb247XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc3RyU3ltYm9sc1xuICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpXG4gICAgICAgIDogc3RyaW5nLnNsaWNlKDAsIGVuZCk7XG5cbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgICB9XG4gICAgICBpZiAoc3RyU3ltYm9scykge1xuICAgICAgICBlbmQgKz0gKHJlc3VsdC5sZW5ndGggLSBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgaWYgKHN0cmluZy5zbGljZShlbmQpLnNlYXJjaChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgdmFyIG1hdGNoLFxuICAgICAgICAgICAgICBzdWJzdHJpbmcgPSByZXN1bHQ7XG5cbiAgICAgICAgICBpZiAoIXNlcGFyYXRvci5nbG9iYWwpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCB0b1N0cmluZyhyZUZsYWdzLmV4ZWMoc2VwYXJhdG9yKSkgKyAnZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3Vic3RyaW5nKSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbmQgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIG5ld0VuZCA9PT0gdW5kZWZpbmVkID8gZW5kIDogbmV3RW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJpbmcuaW5kZXhPZihiYXNlVG9TdHJpbmcoc2VwYXJhdG9yKSwgZW5kKSAhPSBlbmQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcmVzdWx0Lmxhc3RJbmRleE9mKHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLmVzY2FwZWA7IHRoaXMgbWV0aG9kIGNvbnZlcnRzIHRoZSBIVE1MIGVudGl0aWVzXG4gICAgICogYCZhbXA7YCwgYCZsdDtgLCBgJmd0O2AsIGAmcXVvdDtgLCBhbmQgYCYjMzk7YCBpbiBgc3RyaW5nYCB0b1xuICAgICAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBIVE1MIGVudGl0aWVzIGFyZSB1bmVzY2FwZWQuIFRvIHVuZXNjYXBlIGFkZGl0aW9uYWxcbiAgICAgKiBIVE1MIGVudGl0aWVzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuZXNjYXBlKCdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNFc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVwcGVyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICovXG4gICAgdmFyIHVwcGVyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHdvcmQudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udXBwZXJGaXJzdCgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqXG4gICAgICogXy51cHBlckZpcnN0KCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ0ZSRUQnXG4gICAgICovXG4gICAgdmFyIHVwcGVyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvVXBwZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJywgL1teLCBdKy9nKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBhdHRlcm4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IHBhdHRlcm47XG5cbiAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc1VuaWNvZGVXb3JkKHN0cmluZykgPyB1bmljb2RlV29yZHMoc3RyaW5nKSA6IGFzY2lpV29yZHMoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gaW52b2tlIGBmdW5jYCwgcmV0dXJuaW5nIGVpdGhlciB0aGUgcmVzdWx0IG9yIHRoZSBjYXVnaHQgZXJyb3JcbiAgICAgKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBgZnVuY2AgcmVzdWx0IG9yIGVycm9yIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgdGhyb3dpbmcgZXJyb3JzIGZvciBpbnZhbGlkIHNlbGVjdG9ycy5cbiAgICAgKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgKiB9LCAnPl8+Jyk7XG4gICAgICpcbiAgICAgKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICAgICAqICAgZWxlbWVudHMgPSBbXTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgdmFyIGF0dGVtcHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiaW5kIGFuZCBhc3NpZ24gdGhlIGJvdW5kIG1ldGhvZHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gbWV0aG9kTmFtZXMgVGhlIG9iamVjdCBtZXRob2QgbmFtZXMgdG8gYmluZC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdjbGljayc6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnY2xpY2tlZCAnICsgdGhpcy5sYWJlbCk7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uYmluZEFsbCh2aWV3LCBbJ2NsaWNrJ10pO1xuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB2aWV3LmNsaWNrKTtcbiAgICAgKiAvLyA9PiBMb2dzICdjbGlja2VkIGRvY3MnIHdoZW4gY2xpY2tlZC5cbiAgICAgKi9cbiAgICB2YXIgYmluZEFsbCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgbWV0aG9kTmFtZXMpIHtcbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGtleSA9IHRvS2V5KGtleSk7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgYmluZChvYmplY3Rba2V5XSwgb2JqZWN0KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpdGVyYXRlcyBvdmVyIGBwYWlyc2AgYW5kIGludm9rZXMgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiBmdW5jdGlvbiBvZiB0aGUgZmlyc3QgcHJlZGljYXRlIHRvIHJldHVybiB0cnV0aHkuIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb25cbiAgICAgKiBwYWlycyBhcmUgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb24gcGFpcnMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8uY29uZChbXG4gICAgICogICBbXy5tYXRjaGVzKHsgJ2EnOiAxIH0pLCAgICAgICAgICAgXy5jb25zdGFudCgnbWF0Y2hlcyBBJyldLFxuICAgICAqICAgW18uY29uZm9ybXMoeyAnYic6IF8uaXNOdW1iZXIgfSksIF8uY29uc3RhbnQoJ21hdGNoZXMgQicpXSxcbiAgICAgKiAgIFtfLnN0dWJUcnVlLCAgICAgICAgICAgICAgICAgICAgICBfLmNvbnN0YW50KCdubyBtYXRjaCcpXVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+ICdtYXRjaGVzIEEnXG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAwLCAnYic6IDEgfSk7XG4gICAgICogLy8gPT4gJ21hdGNoZXMgQidcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6ICcxJywgJ2InOiAnMicgfSk7XG4gICAgICogLy8gPT4gJ25vIG1hdGNoJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmQocGFpcnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcbiAgICAgICAgICB0b0l0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoKTtcblxuICAgICAgcGFpcnMgPSAhbGVuZ3RoID8gW10gOiBhcnJheU1hcChwYWlycywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICBpZiAodHlwZW9mIHBhaXJbMV0gIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RvSXRlcmF0ZWUocGFpclswXSksIHBhaXJbMV1dO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICAgIGlmIChhcHBseShwYWlyWzBdLCB0aGlzLCBhcmdzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHBhaXJbMV0sIHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgcHJlZGljYXRlIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aFxuICAgICAqIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBhIGdpdmVuIG9iamVjdCwgcmV0dXJuaW5nIGB0cnVlYCBpZlxuICAgICAqIGFsbCBwcmVkaWNhdGVzIHJldHVybiB0cnV0aHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zVG9gIHdpdGhcbiAgICAgKiBgc291cmNlYCBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAyLCAnYic6IDEgfSxcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLmNvbmZvcm1zKHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlQ29uZm9ybXMoYmFzZUNsb25lKHNvdXJjZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBgdmFsdWVgIHRvIGRldGVybWluZSB3aGV0aGVyIGEgZGVmYXVsdCB2YWx1ZSBzaG91bGQgYmUgcmV0dXJuZWQgaW5cbiAgICAgKiBpdHMgcGxhY2UuIFRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBgbnVsbGAsXG4gICAgICogb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdFRvKDEsIDEwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbyh1bmRlZmluZWQsIDEwKTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRUbyh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gKHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgZ2l2ZW4gZnVuY3Rpb25zXG4gICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIF8uZmxvd1JpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvdyhbXy5hZGQsIHNxdWFyZV0pO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsb3dgIGV4Y2VwdCB0aGF0IGl0IGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogaW52b2tlcyB0aGUgZ2l2ZW4gZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtmdW5jc10gVGhlIGZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgXy5mbG93XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvd1JpZ2h0KFtzcXVhcmUsIF8uYWRkXSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvd1JpZ2h0ID0gY3JlYXRlRmxvdyh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHkgbmFtZSwgdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGVcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LiBJZiBgZnVuY2AgaXMgYW4gYXJyYXkgb3Igb2JqZWN0LCB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGNvbnRhaW4gdGhlIGVxdWl2YWxlbnRcbiAgICAgKiBzb3VyY2UgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKFsndXNlcicsICdmcmVkJ10pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcCh1c2VycywgXy5pdGVyYXRlZSgndXNlcicpKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSBjdXN0b20gaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKiBfLml0ZXJhdGVlID0gXy53cmFwKF8uaXRlcmF0ZWUsIGZ1bmN0aW9uKGl0ZXJhdGVlLCBmdW5jKSB7XG4gICAgICogICByZXR1cm4gIV8uaXNSZWdFeHAoZnVuYykgPyBpdGVyYXRlZShmdW5jKSA6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAqICAgICByZXR1cm4gZnVuYy50ZXN0KHN0cmluZyk7XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIoWydhYmMnLCAnZGVmJ10sIC9lZi8pO1xuICAgICAqIC8vID0+IFsnZGVmJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpdGVyYXRlZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmFzZUl0ZXJhdGVlKHR5cGVvZiBmdW5jID09ICdmdW5jdGlvbicgPyBmdW5jIDogYmFzZUNsb25lKGZ1bmMsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBhIGdpdmVuXG4gICAgICogb2JqZWN0IGFuZCBgc291cmNlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBlcXVpdmFsZW50XG4gICAgICogcHJvcGVydHkgdmFsdWVzLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5pc01hdGNoYCB3aXRoIGBzb3VyY2VgXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ubWF0Y2hlcyh7ICdhJzogNCwgJ2MnOiA2IH0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlTWF0Y2hlcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdGhlXG4gICAgICogdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0IHRvIGBzcmNWYWx1ZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlXG4gICAgICogb2JqZWN0IHZhbHVlIGlzIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdFxuICAgICAqIGBzcmNWYWx1ZWAgdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWVcbiAgICAgKiBgXy5pc0VxdWFsYCBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKG9iamVjdHMsIF8ubWF0Y2hlc1Byb3BlcnR5KCdhJywgNCkpO1xuICAgICAqIC8vID0+IHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBiYXNlQ2xvbmUoc3JjVmFsdWUsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICogQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogXy5jb25zdGFudCgyKSB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMSkgfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKCdhLmInKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZChbJ2EnLCAnYiddKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWV0aG9kYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIHRoZSBtZXRob2QgYXQgYSBnaXZlbiBwYXRoIG9mIGBvYmplY3RgLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludm9rZXIgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IF8udGltZXMoMywgXy5jb25zdGFudCksXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kT2YgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2VcbiAgICAgKiBvYmplY3QgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC4gSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiwgdGhlbiBtZXRob2RzXG4gICAgICogYXJlIGFkZGVkIHRvIGl0cyBwcm90b3R5cGUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVc2UgYF8ucnVuSW5Db250ZXh0YCB0byBjcmVhdGUgYSBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB0b1xuICAgICAqIGF2b2lkIGNvbmZsaWN0cyBjYXVzZWQgYnkgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIG1peGlucyBhcmUgY2hhaW5hYmxlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHZvd2VscyhzdHJpbmcpIHtcbiAgICAgKiAgIHJldHVybiBfLmZpbHRlcihzdHJpbmcsIGZ1bmN0aW9uKHYpIHtcbiAgICAgKiAgICAgcmV0dXJuIC9bYWVpb3VdL2kudGVzdCh2KTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0pO1xuICAgICAqIF8udm93ZWxzKCdmcmVkJyk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9LCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluKG9iamVjdCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSksXG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwgcHJvcHMpO1xuXG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsICYmXG4gICAgICAgICAgIShpc09iamVjdChzb3VyY2UpICYmIChtZXRob2ROYW1lcy5sZW5ndGggfHwgIXByb3BzLmxlbmd0aCkpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBzb3VyY2U7XG4gICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gdGhpcztcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFpbiA9ICEoaXNPYmplY3Qob3B0aW9ucykgJiYgJ2NoYWluJyBpbiBvcHRpb25zKSB8fCAhIW9wdGlvbnMuY2hhaW4sXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihvYmplY3QpO1xuXG4gICAgICBhcnJheUVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBzb3VyY2VbbWV0aG9kTmFtZV07XG4gICAgICAgIG9iamVjdFttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICBvYmplY3QucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0KHRoaXMuX193cmFwcGVkX18pLFxuICAgICAgICAgICAgICAgICAgYWN0aW9ucyA9IHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcblxuICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goeyAnZnVuYyc6IGZ1bmMsICdhcmdzJzogYXJndW1lbnRzLCAndGhpc0FyZyc6IG9iamVjdCB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IGNoYWluQWxsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkob2JqZWN0LCBhcnJheVB1c2goW3RoaXMudmFsdWUoKV0sIGFyZ3VtZW50cykpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydHMgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHMgcHJldmlvdXMgdmFsdWUgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG9cbiAgICAgKiB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsb2Rhc2ggPSBfLm5vQ29uZmxpY3QoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgaWYgKHJvb3QuXyA9PT0gdGhpcykge1xuICAgICAgICByb290Ll8gPSBvbGREYXNoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAgICAgKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyB0aGUgYXJndW1lbnQgYXQgaW5kZXggYG5gLiBJZiBgbmAgaXMgbmVnYXRpdmUsXG4gICAgICogdGhlIG50aCBhcmd1bWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGFyZ3VtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXNzLXRocnUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoMSk7XG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+ICdiJ1xuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm50aEFyZygtMik7XG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+ICdjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aEFyZyhuKSB7XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VOdGgoYXJncywgbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBpdGVyYXRlZXNgIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlc1xuICAgICAqIGFuZCByZXR1cm5zIHRoZWlyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyKFtNYXRoLm1heCwgTWF0aC5taW5dKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoMSwgMiwgMywgNCk7XG4gICAgICogLy8gPT4gWzQsIDFdXG4gICAgICovXG4gICAgdmFyIG92ZXIgPSBjcmVhdGVPdmVyKGFycmF5TWFwKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFsbCoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbcHJlZGljYXRlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlckV2ZXJ5KFtCb29sZWFuLCBpc0Zpbml0ZV0pO1xuICAgICAqXG4gICAgICogZnVuYygnMScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIGZ1bmMoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBvdmVyRXZlcnkgPSBjcmVhdGVPdmVyKGFycmF5RXZlcnkpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmICoqYW55Kiogb2YgdGhlIGBwcmVkaWNhdGVzYCByZXR1cm5cbiAgICAgKiB0cnV0aHkgd2hlbiBpbnZva2VkIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtwcmVkaWNhdGVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIHByZWRpY2F0ZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyU29tZShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBvdmVyU29tZSA9IGNyZWF0ZU92ZXIoYXJyYXlTb21lKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgICAgIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5wcm9wZXJ0eWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAgICAgKiB0aGUgdmFsdWUgYXQgYSBnaXZlbiBwYXRoIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFswLCAxLCAyXSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICAgICAqIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gQSBzdGVwIG9mIGAtMWAgaXMgdXNlZCBpZiBhIG5lZ2F0aXZlXG4gICAgICogYHN0YXJ0YCBpcyBzcGVjaWZpZWQgd2l0aG91dCBhbiBgZW5kYCBvciBgc3RlcGAuIElmIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsXG4gICAgICogaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDQpO1xuICAgICAqIC8vID0+IFswLCAxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgtNCk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgdmFyIHJhbmdlID0gY3JlYXRlUmFuZ2UoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmFuZ2VgIGV4Y2VwdCB0aGF0IGl0IHBvcHVsYXRlcyB2YWx1ZXMgaW5cbiAgICAgKiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCg0KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgtNCk7XG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNSk7XG4gICAgICogLy8gPT4gWzQsIDMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFsxNSwgMTAsIDUsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbLTMsIC0yLCAtMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIHZhciByYW5nZVJpZ2h0ID0gY3JlYXRlUmFuZ2UodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gICAgICogLy8gPT4gW1tdLCBbXV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAgICAgKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLnN0dWJPYmplY3QpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3t9LCB7fV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1Yk9iamVjdCgpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJTdHJpbmcpO1xuICAgICAqIC8vID0+IFsnJywgJyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YlN0cmluZygpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJUcnVlKTtcbiAgICAgKiAvLyA9PiBbdHJ1ZSwgdHJ1ZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViVHJ1ZSgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGl0ZXJhdGVlIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mXG4gICAgICogZWFjaCBpbnZvY2F0aW9uLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgU3RyaW5nKTtcbiAgICAgKiAvLyA9PiBbJzAnLCAnMScsICcyJ11cbiAgICAgKlxuICAgICAqICBfLnRpbWVzKDQsIF8uY29uc3RhbnQoMCkpO1xuICAgICAqIC8vID0+IFswLCAwLCAwLCAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgaWYgKG4gPCAxIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IE1BWF9BUlJBWV9MRU5HVEgsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpO1xuXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlKTtcbiAgICAgIG4gLT0gTUFYX0FSUkFZX0xFTkdUSDtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VUaW1lcyhsZW5ndGgsIGl0ZXJhdGVlKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICBpdGVyYXRlZShpbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9QYXRoKCdhLmIuYycpO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogXy50b1BhdGgoJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gWydhJywgJzAnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BhdGgodmFsdWUpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIHRvS2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1N5bWJvbCh2YWx1ZSkgPyBbdmFsdWVdIDogY29weUFycmF5KHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIGdpdmVuLCB0aGUgSUQgaXMgYXBwZW5kZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4PScnXSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAgICAgKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCk7XG4gICAgICogLy8gPT4gJzEwNSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHByZWZpeCkgKyBpZDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXVnZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhbiBhZGRpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0b3RhbC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hZGQoNiwgNCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICB2YXIgYWRkID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihhdWdlbmQsIGFkZGVuZCkge1xuICAgICAgcmV0dXJuIGF1Z2VuZCArIGFkZGVuZDtcbiAgICB9LCAwKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdXAgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgdXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIHVwIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jZWlsKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICpcbiAgICAgKiBfLmNlaWwoNi4wMDQsIDIpO1xuICAgICAqIC8vID0+IDYuMDFcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2MDQwLCAtMik7XG4gICAgICogLy8gPT4gNjEwMFxuICAgICAqL1xuICAgIHZhciBjZWlsID0gY3JlYXRlUm91bmQoJ2NlaWwnKTtcblxuICAgIC8qKlxuICAgICAqIERpdmlkZSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlkZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aXNvciBUaGUgc2Vjb25kIG51bWJlciBpbiBhIGRpdmlzaW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHF1b3RpZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpdmlkZSg2LCA0KTtcbiAgICAgKiAvLyA9PiAxLjVcbiAgICAgKi9cbiAgICB2YXIgZGl2aWRlID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgICAgcmV0dXJuIGRpdmlkZW5kIC8gZGl2aXNvcjtcbiAgICB9LCAxKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgZG93biB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZCBkb3duLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgZG93biB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIGRvd24gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDAuMDQ2LCAyKTtcbiAgICAgKiAvLyA9PiAwLjA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MDAwXG4gICAgICovXG4gICAgdmFyIGZsb29yID0gY3JlYXRlUm91bmQoJ2Zsb29yJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1heChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlR3QpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWF4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWF4Qnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1heEJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heEJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VHdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1lYW4gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWVhbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFuKGFycmF5KSB7XG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGlkZW50aXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lYW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBhdmVyYWdlZC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLm1lYW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLm1pbihbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlTHQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWluQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDEgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VMdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aXBsaWVyIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGljYW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcHJvZHVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tdWx0aXBseSg2LCA0KTtcbiAgICAgKiAvLyA9PiAyNFxuICAgICAqL1xuICAgIHZhciBtdWx0aXBseSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obXVsdGlwbGllciwgbXVsdGlwbGljYW5kKSB7XG4gICAgICByZXR1cm4gbXVsdGlwbGllciAqIG11bHRpcGxpY2FuZDtcbiAgICB9LCAxKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNiwgMik7XG4gICAgICogLy8gPT4gNC4wMVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDEwMFxuICAgICAqL1xuICAgIHZhciByb3VuZCA9IGNyZWF0ZVJvdW5kKCdyb3VuZCcpO1xuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW51ZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBzdWJ0cmFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3VidHJhaGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIHN1YnRyYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGRpZmZlcmVuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VidHJhY3QoNiwgNCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIHZhciBzdWJ0cmFjdCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obWludWVuZCwgc3VidHJhaGVuZCkge1xuICAgICAgcmV0dXJuIG1pbnVlbmQgLSBzdWJ0cmFoZW5kO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHN1bSBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1bShbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBpZGVudGl0eSlcbiAgICAgICAgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc3VtYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgc3VtbWVkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5zdW1CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW1CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiAwO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgICBsb2Rhc2guYXJ5ID0gYXJ5O1xuICAgIGxvZGFzaC5hc3NpZ24gPSBhc3NpZ247XG4gICAgbG9kYXNoLmFzc2lnbkluID0gYXNzaWduSW47XG4gICAgbG9kYXNoLmFzc2lnbkluV2l0aCA9IGFzc2lnbkluV2l0aDtcbiAgICBsb2Rhc2guYXNzaWduV2l0aCA9IGFzc2lnbldpdGg7XG4gICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgbG9kYXNoLmJlZm9yZSA9IGJlZm9yZTtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2FzdEFycmF5ID0gY2FzdEFycmF5O1xuICAgIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xuICAgIGxvZGFzaC5jaHVuayA9IGNodW5rO1xuICAgIGxvZGFzaC5jb21wYWN0ID0gY29tcGFjdDtcbiAgICBsb2Rhc2guY29uY2F0ID0gY29uY2F0O1xuICAgIGxvZGFzaC5jb25kID0gY29uZDtcbiAgICBsb2Rhc2guY29uZm9ybXMgPSBjb25mb3JtcztcbiAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICBsb2Rhc2guY291bnRCeSA9IGNvdW50Qnk7XG4gICAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICBsb2Rhc2guY3VycnlSaWdodCA9IGN1cnJ5UmlnaHQ7XG4gICAgbG9kYXNoLmRlYm91bmNlID0gZGVib3VuY2U7XG4gICAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgbG9kYXNoLmRlZmF1bHRzRGVlcCA9IGRlZmF1bHRzRGVlcDtcbiAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2VCeSA9IGRpZmZlcmVuY2VCeTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZVdpdGggPSBkaWZmZXJlbmNlV2l0aDtcbiAgICBsb2Rhc2guZHJvcCA9IGRyb3A7XG4gICAgbG9kYXNoLmRyb3BSaWdodCA9IGRyb3BSaWdodDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0V2hpbGUgPSBkcm9wUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2guZHJvcFdoaWxlID0gZHJvcFdoaWxlO1xuICAgIGxvZGFzaC5maWxsID0gZmlsbDtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0TWFwID0gZmxhdE1hcDtcbiAgICBsb2Rhc2guZmxhdE1hcERlZXAgPSBmbGF0TWFwRGVlcDtcbiAgICBsb2Rhc2guZmxhdE1hcERlcHRoID0gZmxhdE1hcERlcHRoO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZmxhdHRlbkRlZXAgPSBmbGF0dGVuRGVlcDtcbiAgICBsb2Rhc2guZmxhdHRlbkRlcHRoID0gZmxhdHRlbkRlcHRoO1xuICAgIGxvZGFzaC5mbGlwID0gZmxpcDtcbiAgICBsb2Rhc2guZmxvdyA9IGZsb3c7XG4gICAgbG9kYXNoLmZsb3dSaWdodCA9IGZsb3dSaWdodDtcbiAgICBsb2Rhc2guZnJvbVBhaXJzID0gZnJvbVBhaXJzO1xuICAgIGxvZGFzaC5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLmZ1bmN0aW9uc0luID0gZnVuY3Rpb25zSW47XG4gICAgbG9kYXNoLmdyb3VwQnkgPSBncm91cEJ5O1xuICAgIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25CeSA9IGludGVyc2VjdGlvbkJ5O1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25XaXRoID0gaW50ZXJzZWN0aW9uV2l0aDtcbiAgICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xuICAgIGxvZGFzaC5pbnZlcnRCeSA9IGludmVydEJ5O1xuICAgIGxvZGFzaC5pbnZva2VNYXAgPSBpbnZva2VNYXA7XG4gICAgbG9kYXNoLml0ZXJhdGVlID0gaXRlcmF0ZWU7XG4gICAgbG9kYXNoLmtleUJ5ID0ga2V5Qnk7XG4gICAgbG9kYXNoLmtleXMgPSBrZXlzO1xuICAgIGxvZGFzaC5rZXlzSW4gPSBrZXlzSW47XG4gICAgbG9kYXNoLm1hcCA9IG1hcDtcbiAgICBsb2Rhc2gubWFwS2V5cyA9IG1hcEtleXM7XG4gICAgbG9kYXNoLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbiAgICBsb2Rhc2gubWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgbG9kYXNoLm1hdGNoZXNQcm9wZXJ0eSA9IG1hdGNoZXNQcm9wZXJ0eTtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1lcmdlV2l0aCA9IG1lcmdlV2l0aDtcbiAgICBsb2Rhc2gubWV0aG9kID0gbWV0aG9kO1xuICAgIGxvZGFzaC5tZXRob2RPZiA9IG1ldGhvZE9mO1xuICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgIGxvZGFzaC5uZWdhdGUgPSBuZWdhdGU7XG4gICAgbG9kYXNoLm50aEFyZyA9IG50aEFyZztcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9taXRCeSA9IG9taXRCeTtcbiAgICBsb2Rhc2gub25jZSA9IG9uY2U7XG4gICAgbG9kYXNoLm9yZGVyQnkgPSBvcmRlckJ5O1xuICAgIGxvZGFzaC5vdmVyID0gb3ZlcjtcbiAgICBsb2Rhc2gub3ZlckFyZ3MgPSBvdmVyQXJncztcbiAgICBsb2Rhc2gub3ZlckV2ZXJ5ID0gb3ZlckV2ZXJ5O1xuICAgIGxvZGFzaC5vdmVyU29tZSA9IG92ZXJTb21lO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4gICAgbG9kYXNoLnBpY2sgPSBwaWNrO1xuICAgIGxvZGFzaC5waWNrQnkgPSBwaWNrQnk7XG4gICAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgbG9kYXNoLnByb3BlcnR5T2YgPSBwcm9wZXJ0eU9mO1xuICAgIGxvZGFzaC5wdWxsID0gcHVsbDtcbiAgICBsb2Rhc2gucHVsbEFsbCA9IHB1bGxBbGw7XG4gICAgbG9kYXNoLnB1bGxBbGxCeSA9IHB1bGxBbGxCeTtcbiAgICBsb2Rhc2gucHVsbEFsbFdpdGggPSBwdWxsQWxsV2l0aDtcbiAgICBsb2Rhc2gucHVsbEF0ID0gcHVsbEF0O1xuICAgIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICAgIGxvZGFzaC5yYW5nZVJpZ2h0ID0gcmFuZ2VSaWdodDtcbiAgICBsb2Rhc2gucmVhcmcgPSByZWFyZztcbiAgICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xuICAgIGxvZGFzaC5yZW1vdmUgPSByZW1vdmU7XG4gICAgbG9kYXNoLnJlc3QgPSByZXN0O1xuICAgIGxvZGFzaC5yZXZlcnNlID0gcmV2ZXJzZTtcbiAgICBsb2Rhc2guc2FtcGxlU2l6ZSA9IHNhbXBsZVNpemU7XG4gICAgbG9kYXNoLnNldCA9IHNldDtcbiAgICBsb2Rhc2guc2V0V2l0aCA9IHNldFdpdGg7XG4gICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgIGxvZGFzaC5zbGljZSA9IHNsaWNlO1xuICAgIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG4gICAgbG9kYXNoLnNvcnRlZFVuaXEgPSBzb3J0ZWRVbmlxO1xuICAgIGxvZGFzaC5zb3J0ZWRVbmlxQnkgPSBzb3J0ZWRVbmlxQnk7XG4gICAgbG9kYXNoLnNwbGl0ID0gc3BsaXQ7XG4gICAgbG9kYXNoLnNwcmVhZCA9IHNwcmVhZDtcbiAgICBsb2Rhc2gudGFpbCA9IHRhaWw7XG4gICAgbG9kYXNoLnRha2UgPSB0YWtlO1xuICAgIGxvZGFzaC50YWtlUmlnaHQgPSB0YWtlUmlnaHQ7XG4gICAgbG9kYXNoLnRha2VSaWdodFdoaWxlID0gdGFrZVJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLnRha2VXaGlsZSA9IHRha2VXaGlsZTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aHJ1ID0gdGhydTtcbiAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgbG9kYXNoLnRvUGFpcnMgPSB0b1BhaXJzO1xuICAgIGxvZGFzaC50b1BhaXJzSW4gPSB0b1BhaXJzSW47XG4gICAgbG9kYXNoLnRvUGF0aCA9IHRvUGF0aDtcbiAgICBsb2Rhc2gudG9QbGFpbk9iamVjdCA9IHRvUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsb2Rhc2gudW5hcnkgPSB1bmFyeTtcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgICBsb2Rhc2gudW5pb25CeSA9IHVuaW9uQnk7XG4gICAgbG9kYXNoLnVuaW9uV2l0aCA9IHVuaW9uV2l0aDtcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuaXFCeSA9IHVuaXFCeTtcbiAgICBsb2Rhc2gudW5pcVdpdGggPSB1bmlxV2l0aDtcbiAgICBsb2Rhc2gudW5zZXQgPSB1bnNldDtcbiAgICBsb2Rhc2gudW56aXAgPSB1bnppcDtcbiAgICBsb2Rhc2gudW56aXBXaXRoID0gdW56aXBXaXRoO1xuICAgIGxvZGFzaC51cGRhdGUgPSB1cGRhdGU7XG4gICAgbG9kYXNoLnVwZGF0ZVdpdGggPSB1cGRhdGVXaXRoO1xuICAgIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgbG9kYXNoLnZhbHVlc0luID0gdmFsdWVzSW47XG4gICAgbG9kYXNoLndpdGhvdXQgPSB3aXRob3V0O1xuICAgIGxvZGFzaC53b3JkcyA9IHdvcmRzO1xuICAgIGxvZGFzaC53cmFwID0gd3JhcDtcbiAgICBsb2Rhc2gueG9yID0geG9yO1xuICAgIGxvZGFzaC54b3JCeSA9IHhvckJ5O1xuICAgIGxvZGFzaC54b3JXaXRoID0geG9yV2l0aDtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnppcE9iamVjdERlZXAgPSB6aXBPYmplY3REZWVwO1xuICAgIGxvZGFzaC56aXBXaXRoID0gemlwV2l0aDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5lbnRyaWVzID0gdG9QYWlycztcbiAgICBsb2Rhc2guZW50cmllc0luID0gdG9QYWlyc0luO1xuICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ25JbjtcbiAgICBsb2Rhc2guZXh0ZW5kV2l0aCA9IGFzc2lnbkluV2l0aDtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBtaXhpbihsb2Rhc2gsIGxvZGFzaCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgICBsb2Rhc2guYWRkID0gYWRkO1xuICAgIGxvZGFzaC5hdHRlbXB0ID0gYXR0ZW1wdDtcbiAgICBsb2Rhc2guY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xuICAgIGxvZGFzaC5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZTtcbiAgICBsb2Rhc2guY2VpbCA9IGNlaWw7XG4gICAgbG9kYXNoLmNsYW1wID0gY2xhbXA7XG4gICAgbG9kYXNoLmNsb25lID0gY2xvbmU7XG4gICAgbG9kYXNoLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcbiAgICBsb2Rhc2guY2xvbmVEZWVwV2l0aCA9IGNsb25lRGVlcFdpdGg7XG4gICAgbG9kYXNoLmNsb25lV2l0aCA9IGNsb25lV2l0aDtcbiAgICBsb2Rhc2guY29uZm9ybXNUbyA9IGNvbmZvcm1zVG87XG4gICAgbG9kYXNoLmRlYnVyciA9IGRlYnVycjtcbiAgICBsb2Rhc2guZGVmYXVsdFRvID0gZGVmYXVsdFRvO1xuICAgIGxvZGFzaC5kaXZpZGUgPSBkaXZpZGU7XG4gICAgbG9kYXNoLmVuZHNXaXRoID0gZW5kc1dpdGg7XG4gICAgbG9kYXNoLmVxID0gZXE7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuICAgIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5maW5kID0gZmluZDtcbiAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgIGxvZGFzaC5maW5kS2V5ID0gZmluZEtleTtcbiAgICBsb2Rhc2guZmluZExhc3QgPSBmaW5kTGFzdDtcbiAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLmZpbmRMYXN0S2V5ID0gZmluZExhc3RLZXk7XG4gICAgbG9kYXNoLmZsb29yID0gZmxvb3I7XG4gICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG4gICAgbG9kYXNoLmdldCA9IGdldDtcbiAgICBsb2Rhc2guZ3QgPSBndDtcbiAgICBsb2Rhc2guZ3RlID0gZ3RlO1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmhhc0luID0gaGFzSW47XG4gICAgbG9kYXNoLmhlYWQgPSBoZWFkO1xuICAgIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIGxvZGFzaC5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuICAgIGxvZGFzaC5pbmRleE9mID0gaW5kZXhPZjtcbiAgICBsb2Rhc2guaW5SYW5nZSA9IGluUmFuZ2U7XG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgbG9kYXNoLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuICAgIGxvZGFzaC5pc0FycmF5TGlrZSA9IGlzQXJyYXlMaWtlO1xuICAgIGxvZGFzaC5pc0FycmF5TGlrZU9iamVjdCA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuICAgIGxvZGFzaC5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG4gICAgbG9kYXNoLmlzQnVmZmVyID0gaXNCdWZmZXI7XG4gICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBsb2Rhc2guaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuICAgIGxvZGFzaC5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gICAgbG9kYXNoLmlzRXF1YWxXaXRoID0gaXNFcXVhbFdpdGg7XG4gICAgbG9kYXNoLmlzRXJyb3IgPSBpc0Vycm9yO1xuICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBsb2Rhc2guaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xuICAgIGxvZGFzaC5pc0xlbmd0aCA9IGlzTGVuZ3RoO1xuICAgIGxvZGFzaC5pc01hcCA9IGlzTWFwO1xuICAgIGxvZGFzaC5pc01hdGNoID0gaXNNYXRjaDtcbiAgICBsb2Rhc2guaXNNYXRjaFdpdGggPSBpc01hdGNoV2l0aDtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOYXRpdmUgPSBpc05hdGl2ZTtcbiAgICBsb2Rhc2guaXNOaWwgPSBpc05pbDtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc09iamVjdExpa2UgPSBpc09iamVjdExpa2U7XG4gICAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuICAgIGxvZGFzaC5pc1NhZmVJbnRlZ2VyID0gaXNTYWZlSW50ZWdlcjtcbiAgICBsb2Rhc2guaXNTZXQgPSBpc1NldDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNTeW1ib2wgPSBpc1N5bWJvbDtcbiAgICBsb2Rhc2guaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuICAgIGxvZGFzaC5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuICAgIGxvZGFzaC5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG4gICAgbG9kYXNoLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcbiAgICBsb2Rhc2guam9pbiA9IGpvaW47XG4gICAgbG9kYXNoLmtlYmFiQ2FzZSA9IGtlYmFiQ2FzZTtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLmxvd2VyQ2FzZSA9IGxvd2VyQ2FzZTtcbiAgICBsb2Rhc2gubG93ZXJGaXJzdCA9IGxvd2VyRmlyc3Q7XG4gICAgbG9kYXNoLmx0ID0gbHQ7XG4gICAgbG9kYXNoLmx0ZSA9IGx0ZTtcbiAgICBsb2Rhc2gubWF4ID0gbWF4O1xuICAgIGxvZGFzaC5tYXhCeSA9IG1heEJ5O1xuICAgIGxvZGFzaC5tZWFuID0gbWVhbjtcbiAgICBsb2Rhc2gubWVhbkJ5ID0gbWVhbkJ5O1xuICAgIGxvZGFzaC5taW4gPSBtaW47XG4gICAgbG9kYXNoLm1pbkJ5ID0gbWluQnk7XG4gICAgbG9kYXNoLnN0dWJBcnJheSA9IHN0dWJBcnJheTtcbiAgICBsb2Rhc2guc3R1YkZhbHNlID0gc3R1YkZhbHNlO1xuICAgIGxvZGFzaC5zdHViT2JqZWN0ID0gc3R1Yk9iamVjdDtcbiAgICBsb2Rhc2guc3R1YlN0cmluZyA9IHN0dWJTdHJpbmc7XG4gICAgbG9kYXNoLnN0dWJUcnVlID0gc3R1YlRydWU7XG4gICAgbG9kYXNoLm11bHRpcGx5ID0gbXVsdGlwbHk7XG4gICAgbG9kYXNoLm50aCA9IG50aDtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhZCA9IHBhZDtcbiAgICBsb2Rhc2gucGFkRW5kID0gcGFkRW5kO1xuICAgIGxvZGFzaC5wYWRTdGFydCA9IHBhZFN0YXJ0O1xuICAgIGxvZGFzaC5wYXJzZUludCA9IHBhcnNlSW50O1xuICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG4gICAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcbiAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2gucmVwZWF0ID0gcmVwZWF0O1xuICAgIGxvZGFzaC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICAgIGxvZGFzaC5yb3VuZCA9IHJvdW5kO1xuICAgIGxvZGFzaC5ydW5JbkNvbnRleHQgPSBydW5JbkNvbnRleHQ7XG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNuYWtlQ2FzZSA9IHNuYWtlQ2FzZTtcbiAgICBsb2Rhc2guc29tZSA9IHNvbWU7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4ID0gc29ydGVkSW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4QnkgPSBzb3J0ZWRJbmRleEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleE9mID0gc29ydGVkSW5kZXhPZjtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4ID0gc29ydGVkTGFzdEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhCeSA9IHNvcnRlZExhc3RJbmRleEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhPZiA9IHNvcnRlZExhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5zdGFydENhc2UgPSBzdGFydENhc2U7XG4gICAgbG9kYXNoLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xuICAgIGxvZGFzaC5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuICAgIGxvZGFzaC5zdW0gPSBzdW07XG4gICAgbG9kYXNoLnN1bUJ5ID0gc3VtQnk7XG4gICAgbG9kYXNoLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgbG9kYXNoLnRpbWVzID0gdGltZXM7XG4gICAgbG9kYXNoLnRvRmluaXRlID0gdG9GaW5pdGU7XG4gICAgbG9kYXNoLnRvSW50ZWdlciA9IHRvSW50ZWdlcjtcbiAgICBsb2Rhc2gudG9MZW5ndGggPSB0b0xlbmd0aDtcbiAgICBsb2Rhc2gudG9Mb3dlciA9IHRvTG93ZXI7XG4gICAgbG9kYXNoLnRvTnVtYmVyID0gdG9OdW1iZXI7XG4gICAgbG9kYXNoLnRvU2FmZUludGVnZXIgPSB0b1NhZmVJbnRlZ2VyO1xuICAgIGxvZGFzaC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIGxvZGFzaC50b1VwcGVyID0gdG9VcHBlcjtcbiAgICBsb2Rhc2gudHJpbSA9IHRyaW07XG4gICAgbG9kYXNoLnRyaW1FbmQgPSB0cmltRW5kO1xuICAgIGxvZGFzaC50cmltU3RhcnQgPSB0cmltU3RhcnQ7XG4gICAgbG9kYXNoLnRydW5jYXRlID0gdHJ1bmNhdGU7XG4gICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4gICAgbG9kYXNoLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgbG9kYXNoLnVwcGVyQ2FzZSA9IHVwcGVyQ2FzZTtcbiAgICBsb2Rhc2gudXBwZXJGaXJzdCA9IHVwcGVyRmlyc3Q7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZmlyc3QgPSBoZWFkO1xuXG4gICAgbWl4aW4obG9kYXNoLCAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0ge307XG4gICAgICBiYXNlRm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLnByb3RvdHlwZSwgbWV0aG9kTmFtZSkpIHtcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSgpKSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgbG9kYXNoLlZFUlNJT04gPSBWRVJTSU9OO1xuXG4gICAgLy8gQXNzaWduIGRlZmF1bHQgcGxhY2Vob2xkZXJzLlxuICAgIGFycmF5RWFjaChbJ2JpbmQnLCAnYmluZEtleScsICdjdXJyeScsICdjdXJyeVJpZ2h0JywgJ3BhcnRpYWwnLCAncGFydGlhbFJpZ2h0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIGxvZGFzaFttZXRob2ROYW1lXS5wbGFjZWhvbGRlciA9IGxvZGFzaDtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmRyb3BgIGFuZCBgXy50YWtlYCB2YXJpYW50cy5cbiAgICBhcnJheUVhY2goWydkcm9wJywgJ3Rha2UnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgbiA9IG4gPT09IHVuZGVmaW5lZCA/IDEgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKG4pLCAwKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gKHRoaXMuX19maWx0ZXJlZF9fICYmICFpbmRleClcbiAgICAgICAgICA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKVxuICAgICAgICAgIDogdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fKSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSBuYXRpdmVNaW4obiwgcmVzdWx0Ll9fdGFrZUNvdW50X18pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5fX3ZpZXdzX18ucHVzaCh7XG4gICAgICAgICAgICAnc2l6ZSc6IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKSxcbiAgICAgICAgICAgICd0eXBlJzogbWV0aG9kTmFtZSArIChyZXN1bHQuX19kaXJfXyA8IDAgPyAnUmlnaHQnIDogJycpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lICsgJ1JpZ2h0J10gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKVttZXRob2ROYW1lXShuKS5yZXZlcnNlKCk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0aGF0IGFjY2VwdCBhbiBgaXRlcmF0ZWVgIHZhbHVlLlxuICAgIGFycmF5RWFjaChbJ2ZpbHRlcicsICdtYXAnLCAndGFrZVdoaWxlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdHlwZSA9IGluZGV4ICsgMSxcbiAgICAgICAgICBpc0ZpbHRlciA9IHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRyB8fCB0eXBlID09IExBWllfV0hJTEVfRkxBRztcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18ucHVzaCh7XG4gICAgICAgICAgJ2l0ZXJhdGVlJzogZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLFxuICAgICAgICAgICd0eXBlJzogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHJlc3VsdC5fX2ZpbHRlcmVkX18gfHwgaXNGaWx0ZXI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaGVhZGAgYW5kIGBfLmxhc3RgLlxuICAgIGFycmF5RWFjaChbJ2hlYWQnLCAnbGFzdCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHRha2VOYW1lID0gJ3Rha2UnICsgKGluZGV4ID8gJ1JpZ2h0JyA6ICcnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3Rha2VOYW1lXSgxKS52YWx1ZSgpWzBdO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmluaXRpYWxgIGFuZCBgXy50YWlsYC5cbiAgICBhcnJheUVhY2goWydpbml0aWFsJywgJ3RhaWwnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciBkcm9wTmFtZSA9ICdkcm9wJyArIChpbmRleCA/ICcnIDogJ1JpZ2h0Jyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2ZpbHRlcmVkX18gPyBuZXcgTGF6eVdyYXBwZXIodGhpcykgOiB0aGlzW2Ryb3BOYW1lXSgxKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGlkZW50aXR5KTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihwcmVkaWNhdGUpLmhlYWQoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmRMYXN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmluZChwcmVkaWNhdGUpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24ocGF0aCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xuICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18gJiYgKHN0YXJ0ID4gMCB8fCBlbmQgPCAwKSkge1xuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC50YWtlUmlnaHQoLXN0YXJ0KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRyb3Aoc3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHRvSW50ZWdlcihlbmQpO1xuICAgICAgICByZXN1bHQgPSBlbmQgPCAwID8gcmVzdWx0LmRyb3BSaWdodCgtZW5kKSA6IHJlc3VsdC50YWtlKGVuZCAtIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50YWtlUmlnaHRXaGlsZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLnRha2VXaGlsZShwcmVkaWNhdGUpLnJldmVyc2UoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRha2UoTUFYX0FSUkFZX0xFTkdUSCk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgY2hlY2tJdGVyYXRlZSA9IC9eKD86ZmlsdGVyfGZpbmR8bWFwfHJlamVjdCl8V2hpbGUkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGlzVGFrZXIgPSAvXig/OmhlYWR8bGFzdCkkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbaXNUYWtlciA/ICgndGFrZScgKyAobWV0aG9kTmFtZSA9PSAnbGFzdCcgPyAnUmlnaHQnIDogJycpKSA6IG1ldGhvZE5hbWVdLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IGlzVGFrZXIgfHwgL15maW5kLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBpZiAoIWxvZGFzaEZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgICAgYXJncyA9IGlzVGFrZXIgPyBbMV0gOiBhcmd1bWVudHMsXG4gICAgICAgICAgICBpc0xhenkgPSB2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyLFxuICAgICAgICAgICAgaXRlcmF0ZWUgPSBhcmdzWzBdLFxuICAgICAgICAgICAgdXNlTGF6eSA9IGlzTGF6eSB8fCBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgICB2YXIgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2hGdW5jLmFwcGx5KGxvZGFzaCwgYXJyYXlQdXNoKFt2YWx1ZV0sIGFyZ3MpKTtcbiAgICAgICAgICByZXR1cm4gKGlzVGFrZXIgJiYgY2hhaW5BbGwpID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh1c2VMYXp5ICYmIGNoZWNrSXRlcmF0ZWUgJiYgdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgaXRlcmF0ZWUubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICAvLyBBdm9pZCBsYXp5IHVzZSBpZiB0aGUgaXRlcmF0ZWUgaGFzIGEgXCJsZW5ndGhcIiB2YWx1ZSBvdGhlciB0aGFuIGAxYC5cbiAgICAgICAgICBpc0xhenkgPSB1c2VMYXp5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICBpc0h5YnJpZCA9ICEhdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgsXG4gICAgICAgICAgICBpc1Vud3JhcHBlZCA9IHJldFVud3JhcHBlZCAmJiAhY2hhaW5BbGwsXG4gICAgICAgICAgICBvbmx5TGF6eSA9IGlzTGF6eSAmJiAhaXNIeWJyaWQ7XG5cbiAgICAgICAgaWYgKCFyZXRVbndyYXBwZWQgJiYgdXNlTGF6eSkge1xuICAgICAgICAgIHZhbHVlID0gb25seUxhenkgPyB2YWx1ZSA6IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fLnB1c2goeyAnZnVuYyc6IHRocnUsICdhcmdzJzogW2ludGVyY2VwdG9yXSwgJ3RoaXNBcmcnOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vud3JhcHBlZCAmJiBvbmx5TGF6eSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICAgIHJldHVybiBpc1Vud3JhcHBlZCA/IChpc1Rha2VyID8gcmVzdWx0LnZhbHVlKClbMF0gOiByZXN1bHQudmFsdWUoKSkgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBBcnJheWAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYXJyYXlFYWNoKFsncG9wJywgJ3B1c2gnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UHJvdG9bbWV0aG9kTmFtZV0sXG4gICAgICAgICAgY2hhaW5OYW1lID0gL14oPzpwdXNofHNvcnR8dW5zaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpID8gJ3RhcCcgOiAndGhydScsXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gL14oPzpwb3B8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJldFVud3JhcHBlZCAmJiAhdGhpcy5fX2NoYWluX18pIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1tjaGFpbk5hbWVdKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gTWFwIG1pbmlmaWVkIG1ldGhvZCBuYW1lcyB0byB0aGVpciByZWFsIG5hbWVzLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgbG9kYXNoRnVuYyA9IGxvZGFzaFttZXRob2ROYW1lXTtcbiAgICAgIGlmIChsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHZhciBrZXkgPSBsb2Rhc2hGdW5jLm5hbWUgKyAnJztcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYWxOYW1lcywga2V5KSkge1xuICAgICAgICAgIHJlYWxOYW1lc1trZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmVhbE5hbWVzW2tleV0ucHVzaCh7ICduYW1lJzogbWV0aG9kTmFtZSwgJ2Z1bmMnOiBsb2Rhc2hGdW5jIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVhbE5hbWVzW2NyZWF0ZUh5YnJpZCh1bmRlZmluZWQsIFdSQVBfQklORF9LRVlfRkxBRykubmFtZV0gPSBbe1xuICAgICAgJ25hbWUnOiAnd3JhcHBlcicsXG4gICAgICAnZnVuYyc6IHVuZGVmaW5lZFxuICAgIH1dO1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYExhenlXcmFwcGVyYC5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY2xvbmUgPSBsYXp5Q2xvbmU7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJldmVyc2UgPSBsYXp5UmV2ZXJzZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudmFsdWUgPSBsYXp5VmFsdWU7XG5cbiAgICAvLyBBZGQgY2hhaW4gc2VxdWVuY2UgbWV0aG9kcyB0byB0aGUgYGxvZGFzaGAgd3JhcHBlci5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmF0ID0gd3JhcHBlckF0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY2hhaW4gPSB3cmFwcGVyQ2hhaW47XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb21taXQgPSB3cmFwcGVyQ29tbWl0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUubmV4dCA9IHdyYXBwZXJOZXh0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucGxhbnQgPSB3cmFwcGVyUGxhbnQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5yZXZlcnNlID0gd3JhcHBlclJldmVyc2U7XG4gICAgbG9kYXNoLnByb3RvdHlwZS50b0pTT04gPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlO1xuXG4gICAgLy8gQWRkIGxhenkgYWxpYXNlcy5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmZpcnN0ID0gbG9kYXNoLnByb3RvdHlwZS5oZWFkO1xuXG4gICAgaWYgKHN5bUl0ZXJhdG9yKSB7XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW3N5bUl0ZXJhdG9yXSA9IHdyYXBwZXJUb0l0ZXJhdG9yO1xuICAgIH1cbiAgICByZXR1cm4gbG9kYXNoO1xuICB9KTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBFeHBvcnQgbG9kYXNoLlxuICB2YXIgXyA9IHJ1bkluQ29udGV4dCgpO1xuXG4gIC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlOlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBFeHBvc2UgTG9kYXNoIG9uIHRoZSBnbG9iYWwgb2JqZWN0IHRvIHByZXZlbnQgZXJyb3JzIHdoZW4gTG9kYXNoIGlzXG4gICAgLy8gbG9hZGVkIGJ5IGEgc2NyaXB0IHRhZyBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EIGxvYWRlci5cbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9lcnJvcnMuaHRtbCNtaXNtYXRjaCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIC8vIFVzZSBgXy5ub0NvbmZsaWN0YCB0byByZW1vdmUgTG9kYXNoIGZyb20gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5fID0gXztcblxuICAgIC8vIERlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXG4gICAgLy8gcmVmZXJlbmNlZCBhcyB0aGUgXCJ1bmRlcnNjb3JlXCIgbW9kdWxlLlxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG4gIC8vIENoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGl0LlxuICBlbHNlIGlmIChmcmVlTW9kdWxlKSB7XG4gICAgLy8gRXhwb3J0IGZvciBOb2RlLmpzLlxuICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBfKS5fID0gXztcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIHN1cHBvcnQuXG4gICAgZnJlZUV4cG9ydHMuXyA9IF87XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gRXhwb3J0IHRvIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIHJvb3QuXyA9IF87XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VNYXAgPSByZXF1aXJlKCcuL19iYXNlTWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAqICAgcmV0dXJuIG4gKiBuO1xuICogfVxuICpcbiAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdXG4gKlxuICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAqIF07XG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICovXG5mdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXA7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbm9vcDtcbiIsInZhciBiYXNlUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHknKSxcbiAgICBiYXNlUHJvcGVydHlEZWVwID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5RGVlcCcpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9wZXJ0eTtcbiIsInZhciBhcnJheVJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5UmVkdWNlJyksXG4gICAgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VSZWR1Y2UgPSByZXF1aXJlKCcuL19iYXNlUmVkdWNlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gKiBpcyBub3QgZ2l2ZW4sIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXG4gKiB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgb3JkZXJCeWAsXG4gKiBhbmQgYHNvcnRCeWBcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIF8ucmVkdWNlUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbihzdW0sIG4pIHtcbiAqICAgcmV0dXJuIHN1bSArIG47XG4gKiB9LCAwKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gKiAgIHJldHVybiByZXN1bHQ7XG4gKiB9LCB7fSk7XG4gKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2UgOiBiYXNlUmVkdWNlLFxuICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZHVjZTtcbiIsInZhciBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNTdHJpbmcgPSByZXF1aXJlKCcuL2lzU3RyaW5nJyksXG4gICAgc3RyaW5nU2l6ZSA9IHJlcXVpcmUoJy4vX3N0cmluZ1NpemUnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gKiB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIHNpemUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICogLy8gPT4gMlxuICpcbiAqIF8uc2l6ZSgncGViYmxlcycpO1xuICogLy8gPT4gN1xuICovXG5mdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKSA/IHN0cmluZ1NpemUoY29sbGVjdGlvbikgOiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgfVxuICByZXR1cm4gYmFzZUtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNpemU7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcbiIsInZhciBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKipcbiAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWA7IHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd25cbiAqIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgdGhydSBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvblxuICogcG90ZW50aWFsbHkgbXV0YXRpbmcgdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBJZiBgYWNjdW11bGF0b3JgIGlzIG5vdFxuICogcHJvdmlkZWQsIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGBbW1Byb3RvdHlwZV1dYCB3aWxsIGJlIHVzZWQuIFRoZVxuICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjMuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udHJhbnNmb3JtKFsyLCAzLCA0XSwgZnVuY3Rpb24ocmVzdWx0LCBuKSB7XG4gKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG4gKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICogfSwgW10pO1xuICogLy8gPT4gWzQsIDldXG4gKlxuICogXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICogfSwge30pO1xuICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgaXNBcnJMaWtlID0gaXNBcnIgfHwgaXNCdWZmZXIob2JqZWN0KSB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KTtcblxuICBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgNCk7XG4gIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgdmFyIEN0b3IgPSBvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgIGlmIChpc0Fyckxpa2UpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnIgPyBuZXcgQ3RvciA6IFtdO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdChvYmplY3QpKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGlzRnVuY3Rpb24oQ3RvcikgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKSA6IHt9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFjY3VtdWxhdG9yID0ge307XG4gICAgfVxuICB9XG4gIChpc0Fyckxpa2UgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gIH0pO1xuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtO1xuIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgYmFzZVVuaXEgPSByZXF1aXJlKCcuL19iYXNlVW5pcScpLFxuICAgIGlzQXJyYXlMaWtlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZU9iamVjdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIGZyb20gYWxsIGdpdmVuIGFycmF5cyB1c2luZ1xuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlvbihbMl0sIFsxLCAyXSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqL1xudmFyIHVuaW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmlvbjtcbiIsInZhciBiYXNlVmFsdWVzID0gcmVxdWlyZSgnLi9fYmFzZVZhbHVlcycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsdWVzO1xuIiwiLyohIE5hdGl2ZSBQcm9taXNlIE9ubHlcbiAgICB2MC44LjEgKGMpIEt5bGUgU2ltcHNvblxuICAgIE1JVCBMaWNlbnNlOiBodHRwOi8vZ2V0aWZ5Lm1pdC1saWNlbnNlLm9yZ1xuKi9cblxuKGZ1bmN0aW9uIFVNRChuYW1lLGNvbnRleHQsZGVmaW5pdGlvbil7XG5cdC8vIHNwZWNpYWwgZm9ybSBvZiBVTUQgZm9yIHBvbHlmaWxsaW5nIGFjcm9zcyBldmlyb25tZW50c1xuXHRjb250ZXh0W25hbWVdID0gY29udGV4dFtuYW1lXSB8fCBkZWZpbml0aW9uKCk7XG5cdGlmICh0eXBlb2YgbW9kdWxlICE9IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpIHsgbW9kdWxlLmV4cG9ydHMgPSBjb250ZXh0W25hbWVdOyB9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHsgZGVmaW5lKGZ1bmN0aW9uICRBTUQkKCl7IHJldHVybiBjb250ZXh0W25hbWVdOyB9KTsgfVxufSkoXCJQcm9taXNlXCIsdHlwZW9mIGdsb2JhbCAhPSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdGhpcyxmdW5jdGlvbiBERUYoKXtcblx0Lypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIGJ1aWx0SW5Qcm9wLCBjeWNsZSwgc2NoZWR1bGluZ19xdWV1ZSxcblx0XHRUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG5cdFx0dGltZXIgPSAodHlwZW9mIHNldEltbWVkaWF0ZSAhPSBcInVuZGVmaW5lZFwiKSA/XG5cdFx0XHRmdW5jdGlvbiB0aW1lcihmbikgeyByZXR1cm4gc2V0SW1tZWRpYXRlKGZuKTsgfSA6XG5cdFx0XHRzZXRUaW1lb3V0XG5cdDtcblxuXHQvLyBkYW1taXQsIElFOC5cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJ4XCIse30pO1xuXHRcdGJ1aWx0SW5Qcm9wID0gZnVuY3Rpb24gYnVpbHRJblByb3Aob2JqLG5hbWUsdmFsLGNvbmZpZykge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosbmFtZSx7XG5cdFx0XHRcdHZhbHVlOiB2YWwsXG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IGNvbmZpZyAhPT0gZmFsc2Vcblx0XHRcdH0pO1xuXHRcdH07XG5cdH1cblx0Y2F0Y2ggKGVycikge1xuXHRcdGJ1aWx0SW5Qcm9wID0gZnVuY3Rpb24gYnVpbHRJblByb3Aob2JqLG5hbWUsdmFsKSB7XG5cdFx0XHRvYmpbbmFtZV0gPSB2YWw7XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH07XG5cdH1cblxuXHQvLyBOb3RlOiB1c2luZyBhIHF1ZXVlIGluc3RlYWQgb2YgYXJyYXkgZm9yIGVmZmljaWVuY3lcblx0c2NoZWR1bGluZ19xdWV1ZSA9IChmdW5jdGlvbiBRdWV1ZSgpIHtcblx0XHR2YXIgZmlyc3QsIGxhc3QsIGl0ZW07XG5cblx0XHRmdW5jdGlvbiBJdGVtKGZuLHNlbGYpIHtcblx0XHRcdHRoaXMuZm4gPSBmbjtcblx0XHRcdHRoaXMuc2VsZiA9IHNlbGY7XG5cdFx0XHR0aGlzLm5leHQgPSB2b2lkIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFkZDogZnVuY3Rpb24gYWRkKGZuLHNlbGYpIHtcblx0XHRcdFx0aXRlbSA9IG5ldyBJdGVtKGZuLHNlbGYpO1xuXHRcdFx0XHRpZiAobGFzdCkge1xuXHRcdFx0XHRcdGxhc3QubmV4dCA9IGl0ZW07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Zmlyc3QgPSBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3QgPSBpdGVtO1xuXHRcdFx0XHRpdGVtID0gdm9pZCAwO1xuXHRcdFx0fSxcblx0XHRcdGRyYWluOiBmdW5jdGlvbiBkcmFpbigpIHtcblx0XHRcdFx0dmFyIGYgPSBmaXJzdDtcblx0XHRcdFx0Zmlyc3QgPSBsYXN0ID0gY3ljbGUgPSB2b2lkIDA7XG5cblx0XHRcdFx0d2hpbGUgKGYpIHtcblx0XHRcdFx0XHRmLmZuLmNhbGwoZi5zZWxmKTtcblx0XHRcdFx0XHRmID0gZi5uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSkoKTtcblxuXHRmdW5jdGlvbiBzY2hlZHVsZShmbixzZWxmKSB7XG5cdFx0c2NoZWR1bGluZ19xdWV1ZS5hZGQoZm4sc2VsZik7XG5cdFx0aWYgKCFjeWNsZSkge1xuXHRcdFx0Y3ljbGUgPSB0aW1lcihzY2hlZHVsaW5nX3F1ZXVlLmRyYWluKTtcblx0XHR9XG5cdH1cblxuXHQvLyBwcm9taXNlIGR1Y2sgdHlwaW5nXG5cdGZ1bmN0aW9uIGlzVGhlbmFibGUobykge1xuXHRcdHZhciBfdGhlbiwgb190eXBlID0gdHlwZW9mIG87XG5cblx0XHRpZiAobyAhPSBudWxsICYmXG5cdFx0XHQoXG5cdFx0XHRcdG9fdHlwZSA9PSBcIm9iamVjdFwiIHx8IG9fdHlwZSA9PSBcImZ1bmN0aW9uXCJcblx0XHRcdClcblx0XHQpIHtcblx0XHRcdF90aGVuID0gby50aGVuO1xuXHRcdH1cblx0XHRyZXR1cm4gdHlwZW9mIF90aGVuID09IFwiZnVuY3Rpb25cIiA/IF90aGVuIDogZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBub3RpZnkoKSB7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuY2hhaW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdG5vdGlmeUlzb2xhdGVkKFxuXHRcdFx0XHR0aGlzLFxuXHRcdFx0XHQodGhpcy5zdGF0ZSA9PT0gMSkgPyB0aGlzLmNoYWluW2ldLnN1Y2Nlc3MgOiB0aGlzLmNoYWluW2ldLmZhaWx1cmUsXG5cdFx0XHRcdHRoaXMuY2hhaW5baV1cblx0XHRcdCk7XG5cdFx0fVxuXHRcdHRoaXMuY2hhaW4ubGVuZ3RoID0gMDtcblx0fVxuXG5cdC8vIE5PVEU6IFRoaXMgaXMgYSBzZXBhcmF0ZSBmdW5jdGlvbiB0byBpc29sYXRlXG5cdC8vIHRoZSBgdHJ5Li5jYXRjaGAgc28gdGhhdCBvdGhlciBjb2RlIGNhbiBiZVxuXHQvLyBvcHRpbWl6ZWQgYmV0dGVyXG5cdGZ1bmN0aW9uIG5vdGlmeUlzb2xhdGVkKHNlbGYsY2IsY2hhaW4pIHtcblx0XHR2YXIgcmV0LCBfdGhlbjtcblx0XHR0cnkge1xuXHRcdFx0aWYgKGNiID09PSBmYWxzZSkge1xuXHRcdFx0XHRjaGFpbi5yZWplY3Qoc2VsZi5tc2cpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmIChjYiA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdHJldCA9IHNlbGYubXNnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHJldCA9IGNiLmNhbGwodm9pZCAwLHNlbGYubXNnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChyZXQgPT09IGNoYWluLnByb21pc2UpIHtcblx0XHRcdFx0XHRjaGFpbi5yZWplY3QoVHlwZUVycm9yKFwiUHJvbWlzZS1jaGFpbiBjeWNsZVwiKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoX3RoZW4gPSBpc1RoZW5hYmxlKHJldCkpIHtcblx0XHRcdFx0XHRfdGhlbi5jYWxsKHJldCxjaGFpbi5yZXNvbHZlLGNoYWluLnJlamVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y2hhaW4ucmVzb2x2ZShyZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdGNoYWluLnJlamVjdChlcnIpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlc29sdmUobXNnKSB7XG5cdFx0dmFyIF90aGVuLCBzZWxmID0gdGhpcztcblxuXHRcdC8vIGFscmVhZHkgdHJpZ2dlcmVkP1xuXHRcdGlmIChzZWxmLnRyaWdnZXJlZCkgeyByZXR1cm47IH1cblxuXHRcdHNlbGYudHJpZ2dlcmVkID0gdHJ1ZTtcblxuXHRcdC8vIHVud3JhcFxuXHRcdGlmIChzZWxmLmRlZikge1xuXHRcdFx0c2VsZiA9IHNlbGYuZGVmO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRpZiAoX3RoZW4gPSBpc1RoZW5hYmxlKG1zZykpIHtcblx0XHRcdFx0c2NoZWR1bGUoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR2YXIgZGVmX3dyYXBwZXIgPSBuZXcgTWFrZURlZldyYXBwZXIoc2VsZik7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdF90aGVuLmNhbGwobXNnLFxuXHRcdFx0XHRcdFx0XHRmdW5jdGlvbiAkcmVzb2x2ZSQoKXsgcmVzb2x2ZS5hcHBseShkZWZfd3JhcHBlcixhcmd1bWVudHMpOyB9LFxuXHRcdFx0XHRcdFx0XHRmdW5jdGlvbiAkcmVqZWN0JCgpeyByZWplY3QuYXBwbHkoZGVmX3dyYXBwZXIsYXJndW1lbnRzKTsgfVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0cmVqZWN0LmNhbGwoZGVmX3dyYXBwZXIsZXJyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c2VsZi5tc2cgPSBtc2c7XG5cdFx0XHRcdHNlbGYuc3RhdGUgPSAxO1xuXHRcdFx0XHRpZiAoc2VsZi5jaGFpbi5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0c2NoZWR1bGUobm90aWZ5LHNlbGYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdHJlamVjdC5jYWxsKG5ldyBNYWtlRGVmV3JhcHBlcihzZWxmKSxlcnIpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlamVjdChtc2cpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHQvLyBhbHJlYWR5IHRyaWdnZXJlZD9cblx0XHRpZiAoc2VsZi50cmlnZ2VyZWQpIHsgcmV0dXJuOyB9XG5cblx0XHRzZWxmLnRyaWdnZXJlZCA9IHRydWU7XG5cblx0XHQvLyB1bndyYXBcblx0XHRpZiAoc2VsZi5kZWYpIHtcblx0XHRcdHNlbGYgPSBzZWxmLmRlZjtcblx0XHR9XG5cblx0XHRzZWxmLm1zZyA9IG1zZztcblx0XHRzZWxmLnN0YXRlID0gMjtcblx0XHRpZiAoc2VsZi5jaGFpbi5sZW5ndGggPiAwKSB7XG5cdFx0XHRzY2hlZHVsZShub3RpZnksc2VsZik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixyZXNvbHZlcixyZWplY3Rlcikge1xuXHRcdGZvciAodmFyIGlkeD0wOyBpZHg8YXJyLmxlbmd0aDsgaWR4KyspIHtcblx0XHRcdChmdW5jdGlvbiBJSUZFKGlkeCl7XG5cdFx0XHRcdENvbnN0cnVjdG9yLnJlc29sdmUoYXJyW2lkeF0pXG5cdFx0XHRcdC50aGVuKFxuXHRcdFx0XHRcdGZ1bmN0aW9uICRyZXNvbHZlciQobXNnKXtcblx0XHRcdFx0XHRcdHJlc29sdmVyKGlkeCxtc2cpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0cmVqZWN0ZXJcblx0XHRcdFx0KTtcblx0XHRcdH0pKGlkeCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gTWFrZURlZldyYXBwZXIoc2VsZikge1xuXHRcdHRoaXMuZGVmID0gc2VsZjtcblx0XHR0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gTWFrZURlZihzZWxmKSB7XG5cdFx0dGhpcy5wcm9taXNlID0gc2VsZjtcblx0XHR0aGlzLnN0YXRlID0gMDtcblx0XHR0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuXHRcdHRoaXMuY2hhaW4gPSBbXTtcblx0XHR0aGlzLm1zZyA9IHZvaWQgMDtcblx0fVxuXG5cdGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcblx0XHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX19OUE9fXyAhPT0gMCkge1xuXHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgcHJvbWlzZVwiKTtcblx0XHR9XG5cblx0XHQvLyBpbnN0YW5jZSBzaGFkb3dpbmcgdGhlIGluaGVyaXRlZCBcImJyYW5kXCJcblx0XHQvLyB0byBzaWduYWwgYW4gYWxyZWFkeSBcImluaXRpYWxpemVkXCIgcHJvbWlzZVxuXHRcdHRoaXMuX19OUE9fXyA9IDE7XG5cblx0XHR2YXIgZGVmID0gbmV3IE1ha2VEZWYodGhpcyk7XG5cblx0XHR0aGlzW1widGhlblwiXSA9IGZ1bmN0aW9uIHRoZW4oc3VjY2VzcyxmYWlsdXJlKSB7XG5cdFx0XHR2YXIgbyA9IHtcblx0XHRcdFx0c3VjY2VzczogdHlwZW9mIHN1Y2Nlc3MgPT0gXCJmdW5jdGlvblwiID8gc3VjY2VzcyA6IHRydWUsXG5cdFx0XHRcdGZhaWx1cmU6IHR5cGVvZiBmYWlsdXJlID09IFwiZnVuY3Rpb25cIiA/IGZhaWx1cmUgOiBmYWxzZVxuXHRcdFx0fTtcblx0XHRcdC8vIE5vdGU6IGB0aGVuKC4uKWAgaXRzZWxmIGNhbiBiZSBib3Jyb3dlZCB0byBiZSB1c2VkIGFnYWluc3Rcblx0XHRcdC8vIGEgZGlmZmVyZW50IHByb21pc2UgY29uc3RydWN0b3IgZm9yIG1ha2luZyB0aGUgY2hhaW5lZCBwcm9taXNlLFxuXHRcdFx0Ly8gYnkgc3Vic3RpdHV0aW5nIGEgZGlmZmVyZW50IGB0aGlzYCBiaW5kaW5nLlxuXHRcdFx0by5wcm9taXNlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZnVuY3Rpb24gZXh0cmFjdENoYWluKHJlc29sdmUscmVqZWN0KSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHR0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG8ucmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0XHRcdG8ucmVqZWN0ID0gcmVqZWN0O1xuXHRcdFx0fSk7XG5cdFx0XHRkZWYuY2hhaW4ucHVzaChvKTtcblxuXHRcdFx0aWYgKGRlZi5zdGF0ZSAhPT0gMCkge1xuXHRcdFx0XHRzY2hlZHVsZShub3RpZnksZGVmKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG8ucHJvbWlzZTtcblx0XHR9O1xuXHRcdHRoaXNbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uICRjYXRjaCQoZmFpbHVyZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsZmFpbHVyZSk7XG5cdFx0fTtcblxuXHRcdHRyeSB7XG5cdFx0XHRleGVjdXRvci5jYWxsKFxuXHRcdFx0XHR2b2lkIDAsXG5cdFx0XHRcdGZ1bmN0aW9uIHB1YmxpY1Jlc29sdmUobXNnKXtcblx0XHRcdFx0XHRyZXNvbHZlLmNhbGwoZGVmLG1zZyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIHB1YmxpY1JlamVjdChtc2cpIHtcblx0XHRcdFx0XHRyZWplY3QuY2FsbChkZWYsbXNnKTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Y2F0Y2ggKGVycikge1xuXHRcdFx0cmVqZWN0LmNhbGwoZGVmLGVycik7XG5cdFx0fVxuXHR9XG5cblx0dmFyIFByb21pc2VQcm90b3R5cGUgPSBidWlsdEluUHJvcCh7fSxcImNvbnN0cnVjdG9yXCIsUHJvbWlzZSxcblx0XHQvKmNvbmZpZ3VyYWJsZT0qL2ZhbHNlXG5cdCk7XG5cblx0Ly8gTm90ZTogQW5kcm9pZCA0IGNhbm5vdCB1c2UgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eSguLilgIGhlcmVcblx0UHJvbWlzZS5wcm90b3R5cGUgPSBQcm9taXNlUHJvdG90eXBlO1xuXG5cdC8vIGJ1aWx0LWluIFwiYnJhbmRcIiB0byBzaWduYWwgYW4gXCJ1bmluaXRpYWxpemVkXCIgcHJvbWlzZVxuXHRidWlsdEluUHJvcChQcm9taXNlUHJvdG90eXBlLFwiX19OUE9fX1wiLDAsXG5cdFx0Lypjb25maWd1cmFibGU9Ki9mYWxzZVxuXHQpO1xuXG5cdGJ1aWx0SW5Qcm9wKFByb21pc2UsXCJyZXNvbHZlXCIsZnVuY3Rpb24gUHJvbWlzZSRyZXNvbHZlKG1zZykge1xuXHRcdHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cblx0XHQvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuXHRcdC8vIG5vdGU6IGJlc3QgXCJpc1Byb21pc2VcIiBjaGVjayB0aGF0J3MgcHJhY3RpY2FsIGZvciBub3dcblx0XHRpZiAobXNnICYmIHR5cGVvZiBtc2cgPT0gXCJvYmplY3RcIiAmJiBtc2cuX19OUE9fXyA9PT0gMSkge1xuXHRcdFx0cmV0dXJuIG1zZztcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcblx0XHRcdGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG5cdFx0XHR9XG5cblx0XHRcdHJlc29sdmUobXNnKTtcblx0XHR9KTtcblx0fSk7XG5cblx0YnVpbHRJblByb3AoUHJvbWlzZSxcInJlamVjdFwiLGZ1bmN0aW9uIFByb21pc2UkcmVqZWN0KG1zZykge1xuXHRcdHJldHVybiBuZXcgdGhpcyhmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG5cdFx0XHRpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZWplY3QobXNnKTtcblx0XHR9KTtcblx0fSk7XG5cblx0YnVpbHRJblByb3AoUHJvbWlzZSxcImFsbFwiLGZ1bmN0aW9uIFByb21pc2UkYWxsKGFycikge1xuXHRcdHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cblx0XHQvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuXHRcdGlmIChUb1N0cmluZy5jYWxsKGFycikgIT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG5cdFx0XHRyZXR1cm4gQ29uc3RydWN0b3IucmVqZWN0KFR5cGVFcnJvcihcIk5vdCBhbiBhcnJheVwiKSk7XG5cdFx0fVxuXHRcdGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gQ29uc3RydWN0b3IucmVzb2x2ZShbXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG5cdFx0XHRpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbGVuID0gYXJyLmxlbmd0aCwgbXNncyA9IEFycmF5KGxlbiksIGNvdW50ID0gMDtcblxuXHRcdFx0aXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixmdW5jdGlvbiByZXNvbHZlcihpZHgsbXNnKSB7XG5cdFx0XHRcdG1zZ3NbaWR4XSA9IG1zZztcblx0XHRcdFx0aWYgKCsrY291bnQgPT09IGxlbikge1xuXHRcdFx0XHRcdHJlc29sdmUobXNncyk7XG5cdFx0XHRcdH1cblx0XHRcdH0scmVqZWN0KTtcblx0XHR9KTtcblx0fSk7XG5cblx0YnVpbHRJblByb3AoUHJvbWlzZSxcInJhY2VcIixmdW5jdGlvbiBQcm9taXNlJHJhY2UoYXJyKSB7XG5cdFx0dmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuXHRcdC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG5cdFx0aWYgKFRvU3RyaW5nLmNhbGwoYXJyKSAhPSBcIltvYmplY3QgQXJyYXldXCIpIHtcblx0XHRcdHJldHVybiBDb25zdHJ1Y3Rvci5yZWplY3QoVHlwZUVycm9yKFwiTm90IGFuIGFycmF5XCIpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcblx0XHRcdGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG5cdFx0XHR9XG5cblx0XHRcdGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvcixhcnIsZnVuY3Rpb24gcmVzb2x2ZXIoaWR4LG1zZyl7XG5cdFx0XHRcdHJlc29sdmUobXNnKTtcblx0XHRcdH0scmVqZWN0KTtcblx0XHR9KTtcblx0fSk7XG5cblx0cmV0dXJuIFByb21pc2U7XG59KTtcbiIsIi8qXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgSmVyZW15IFdoaXRsb2NrXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdXBwb3J0ZWRMb2FkZXJzID0ge1xuICBmaWxlOiByZXF1aXJlKCcuL2xpYi9sb2FkZXJzL2ZpbGUnKSxcbiAgaHR0cDogcmVxdWlyZSgnLi9saWIvbG9hZGVycy9odHRwJyksXG4gIGh0dHBzOiByZXF1aXJlKCcuL2xpYi9sb2FkZXJzL2h0dHAnKVxufTtcbnZhciBkZWZhdWx0TG9hZGVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGltcG9ydFNjcmlwdHMgPT09ICdmdW5jdGlvbicgP1xuICAgICAgc3VwcG9ydGVkTG9hZGVycy5odHRwIDpcbiAgICAgIHN1cHBvcnRlZExvYWRlcnMuZmlsZTtcblxuLy8gTG9hZCBwcm9taXNlcyBwb2x5ZmlsbCBpZiBuZWNlc3Nhcnlcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJykge1xuICByZXF1aXJlKCduYXRpdmUtcHJvbWlzZS1vbmx5Jyk7XG59XG5cbmZ1bmN0aW9uIGdldFNjaGVtZSAobG9jYXRpb24pIHtcbiAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uLmluZGV4T2YoJzovLycpID09PSAtMSA/ICcnIDogbG9jYXRpb24uc3BsaXQoJzovLycpWzBdO1xuICB9XG5cbiAgcmV0dXJuIGxvY2F0aW9uO1xufVxuXG4vKipcbiAqIFV0aWxpdHkgdGhhdCBwcm92aWRlcyBhIHNpbmdsZSBBUEkgZm9yIGxvYWRpbmcgdGhlIGNvbnRlbnQgb2YgYSBwYXRoL1VSTC5cbiAqXG4gKiBAbW9kdWxlIHBhdGgtbG9hZGVyXG4gKi9cblxuZnVuY3Rpb24gZ2V0TG9hZGVyIChsb2NhdGlvbikge1xuICB2YXIgc2NoZW1lID0gZ2V0U2NoZW1lKGxvY2F0aW9uKTtcbiAgdmFyIGxvYWRlciA9IHN1cHBvcnRlZExvYWRlcnNbc2NoZW1lXTtcblxuICBpZiAodHlwZW9mIGxvYWRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoc2NoZW1lID09PSAnJykge1xuICAgICAgbG9hZGVyID0gZGVmYXVsdExvYWRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzY2hlbWU6ICcgKyBzY2hlbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2FkZXI7XG59XG5cbi8qKlxuICogTG9hZHMgYSBkb2N1bWVudCBhdCB0aGUgcHJvdmlkZWQgbG9jYXRpb24gYW5kIHJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gLSBUaGUgbG9jYXRpb24gdG8gdGhlIGRvY3VtZW50XG4gKiBAcGFyYW0ge21vZHVsZTpwYXRoLWxvYWRlci5Mb2FkT3B0aW9uc30gW29wdGlvbnNdIC0gVGhlIGxvYWRlciBvcHRpb25zXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8Kj59IEFsd2F5cyByZXR1cm5zIGEgcHJvbWlzZSBldmVuIGlmIHRoZXJlIGlzIGEgY2FsbGJhY2sgcHJvdmlkZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRXhhbXBsZSB1c2luZyBQcm9taXNlc1xuICpcbiAqIFBhdGhMb2FkZXJcbiAqICAgLmxvYWQoJy4vcGFja2FnZS5qc29uJylcbiAqICAgLnRoZW4oSlNPTi5wYXJzZSlcbiAqICAgLnRoZW4oZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gKiAgICAgY29uc29sZS5sb2coZG9jdW1lbnQubmFtZSArICcgKCcgKyBkb2N1bWVudC52ZXJzaW9uICsgJyk6ICcgKyBkb2N1bWVudC5kZXNjcmlwdGlvbik7XG4gKiAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICBjb25zb2xlLmVycm9yKGVyci5zdGFjayk7XG4gKiAgIH0pO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBFeGFtcGxlIHVzaW5nIG9wdGlvbnMucHJlcGFyZVJlcXVlc3QgdG8gcHJvdmlkZSBhdXRoZW50aWNhdGlvbiBkZXRhaWxzIGZvciBhIHJlbW90ZWx5IHNlY3VyZSBVUkxcbiAqXG4gKiBQYXRoTG9hZGVyXG4gKiAgIC5sb2FkKCdodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zL3doaXRsb2NramMvcGF0aC1sb2FkZXInLCB7XG4gKiAgICAgcHJlcGFyZVJlcXVlc3Q6IGZ1bmN0aW9uIChyZXEsIGNhbGxiYWNrKSB7XG4gKiAgICAgICByZXEuYXV0aCgnbXktdXNlcm5hbWUnLCAnbXktcGFzc3dvcmQnKTtcbiAqICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgcmVxKTtcbiAqICAgICB9XG4gKiAgIH0pXG4gKiAgIC50aGVuKEpTT04ucGFyc2UpXG4gKiAgIC50aGVuKGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICogICAgIGNvbnNvbGUubG9nKGRvY3VtZW50LmZ1bGxfbmFtZSArICc6ICcgKyBkb2N1bWVudC5kZXNjcmlwdGlvbik7XG4gKiAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICBjb25zb2xlLmVycm9yKGVyci5zdGFjayk7XG4gKiAgIH0pO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBFeGFtcGxlIGxvYWRpbmcgYSBZQU1MIGZpbGVcbiAqXG4gKiBQYXRoTG9hZGVyXG4gKiAgIC5sb2FkKCcvVXNlcnMvbm90LXlvdS9wcm9qZWN0cy9wYXRoLWxvYWRlci8udHJhdmlzLnltbCcpXG4gKiAgIC50aGVuKFlBTUwuc2FmZUxvYWQpXG4gKiAgIC50aGVuKGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICogICAgIGNvbnNvbGUubG9nKCdwYXRoLWxvYWRlciB1c2VzIHRoZScsIGRvY3VtZW50Lmxhbmd1YWdlLCAnbGFuZ3VhZ2UuJyk7XG4gKiAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICBjb25zb2xlLmVycm9yKGVyci5zdGFjayk7XG4gKiAgIH0pO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBFeGFtcGxlIGxvYWRpbmcgYSBZQU1MIGZpbGUgd2l0aCBvcHRpb25zLnByb2Nlc3NDb250ZW50IChVc2VmdWwgaWYgeW91IG5lZWQgaW5mb3JtYXRpb24gaW4gdGhlIHJhdyByZXNwb25zZSlcbiAqXG4gKiBQYXRoTG9hZGVyXG4gKiAgIC5sb2FkKCcvVXNlcnMvbm90LXlvdS9wcm9qZWN0cy9wYXRoLWxvYWRlci8udHJhdmlzLnltbCcsIHtcbiAqICAgICBwcm9jZXNzQ29udGVudDogZnVuY3Rpb24gKHJlcywgY2FsbGJhY2spIHtcbiAqICAgICAgIGNhbGxiYWNrKFlBTUwuc2FmZUxvYWQocmVzLnRleHQpKTtcbiAqICAgICB9XG4gKiAgIH0pXG4gKiAgIC50aGVuKGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICogICAgIGNvbnNvbGUubG9nKCdwYXRoLWxvYWRlciB1c2VzIHRoZScsIGRvY3VtZW50Lmxhbmd1YWdlLCAnbGFuZ3VhZ2UuJyk7XG4gKiAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICBjb25zb2xlLmVycm9yKGVyci5zdGFjayk7XG4gKiAgIH0pO1xuICovXG5tb2R1bGUuZXhwb3J0cy5sb2FkID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBvcHRpb25zKSB7XG4gIHZhciBhbGxUYXNrcyA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gIC8vIERlZmF1bHQgb3B0aW9ucyB0byBlbXB0eSBvYmplY3RcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIGFyZ3VtZW50c1xuICBhbGxUYXNrcyA9IGFsbFRhc2tzLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsb2NhdGlvbiBpcyByZXF1aXJlZCcpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbG9jYXRpb24gbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5wcm9jZXNzQ29udGVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9wdGlvbnMucHJvY2Vzc0NvbnRlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5wcm9jZXNzQ29udGVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIExvYWQgdGhlIGRvY3VtZW50IGZyb20gdGhlIHByb3ZpZGVkIGxvY2F0aW9uIGFuZCBwcm9jZXNzIGl0XG4gIGFsbFRhc2tzID0gYWxsVGFza3NcbiAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgbG9hZGVyID0gZ2V0TG9hZGVyKGxvY2F0aW9uKTtcblxuICAgICAgICBsb2FkZXIubG9hZChsb2NhdGlvbiwgb3B0aW9ucyB8fCB7fSwgZnVuY3Rpb24gKGVyciwgZG9jdW1lbnQpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShkb2N1bWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgaWYgKG9wdGlvbnMucHJvY2Vzc0NvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAvLyBGb3IgY29uc2lzdGVuY3kgYmV0d2VlbiBmaWxlIGFuZCBodHRwLCBhbHdheXMgc2VuZCBhbiBvYmplY3Qgd2l0aCBhICd0ZXh0JyBwcm9wZXJ0eSBjb250YWluaW5nIHRoZSByYXdcbiAgICAgICAgICAvLyBzdHJpbmcgdmFsdWUgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAgIGlmICh0eXBlb2YgcmVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmVzID0ge3RleHQ6IHJlc307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUGFzcyB0aGUgcGF0aCBiZWluZyBsb2FkZWRcbiAgICAgICAgICByZXMubG9jYXRpb24gPSBsb2NhdGlvbjtcblxuICAgICAgICAgIG9wdGlvbnMucHJvY2Vzc0NvbnRlbnQocmVzLCBmdW5jdGlvbiAoZXJyLCBwcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKHByb2Nlc3NlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIG5vIGNvbnRlbnQgcHJvY2Vzc29yLCB3ZSB3aWxsIGFzc3VtZSB0aGF0IGZvciBhbGwgb2JqZWN0cyB0aGF0IGl0IGlzIGEgU3VwZXJhZ2VudCByZXNwb25zZVxuICAgICAgICAvLyBhbmQgd2lsbCByZXR1cm4gaXRzIGB0ZXh0YCBwcm9wZXJ0eSB2YWx1ZS4gIE90aGVyd2lzZSwgd2Ugd2lsbCByZXR1cm4gdGhlIHJhdyByZXNwb25zZS5cbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZXMgPT09ICdvYmplY3QnID8gcmVzLnRleHQgOiByZXM7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgcmV0dXJuIGFsbFRhc2tzO1xufTtcbiIsIi8qXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgSmVyZW15IFdoaXRsb2NrXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1bnN1cHBvcnRlZEVycm9yID0gbmV3IFR5cGVFcnJvcignVGhlIFxcJ2ZpbGVcXCcgc2NoZW1lIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGJyb3dzZXInKTtcblxuLyoqXG4gKiBUaGUgZmlsZSBsb2FkZXIgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAdGhyb3dzIHtlcnJvcn0gdGhlIGZpbGUgbG9hZGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGJyb3dzZXJcbiAqL1xubW9kdWxlLmV4cG9ydHMuZ2V0QmFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgdW5zdXBwb3J0ZWRFcnJvcjtcbn07XG5cbi8qKlxuICogVGhlIGZpbGUgbG9hZGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGJyb3dzZXIuXG4gKi9cbm1vZHVsZS5leHBvcnRzLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBmbiA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG5cbiAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuKHVuc3VwcG9ydGVkRXJyb3IpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IHVuc3VwcG9ydGVkRXJyb3I7XG4gIH1cbn07XG4iLCIvKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxuLypcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBKZXJlbXkgV2hpdGxvY2tcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVlc3QgPSByZXF1aXJlKCdzdXBlcmFnZW50Jyk7XG5cbnZhciBzdXBwb3J0ZWRIdHRwTWV0aG9kcyA9IFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3BhdGNoJywgJ3Bvc3QnLCAncHV0J107XG5cbi8qKlxuICogTG9hZHMgYSBmaWxlIGZyb20gYW4gaHR0cCBvciBodHRwcyBVUkwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIC0gVGhlIGRvY3VtZW50IFVSTCAoSWYgcmVsYXRpdmUsIGxvY2F0aW9uIGlzIHJlbGF0aXZlIHRvIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgbG9hZGVyIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5tZXRob2Q9Z2V0XSAtIFRoZSBIVFRQIG1ldGhvZCB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcGFyYW0ge21vZHVsZTpQYXRoTG9hZGVyflByZXBhcmVSZXF1ZXN0Q2FsbGJhY2t9IFtvcHRpb25zLnByZXBhcmVSZXF1ZXN0XSAtIFRoZSBjYWxsYmFjayB1c2VkIHRvIHByZXBhcmUgYSByZXF1ZXN0XG4gKiBAcGFyYW0ge21vZHVsZTpQYXRoTG9hZGVyflByb2Nlc3NSZXNwb25zZUNhbGxiYWNrfSBbb3B0aW9ucy5wcm9jZXNzQ29udGVudF0gLSBUaGUgY2FsbGJhY2sgdXNlZCB0byBwcm9jZXNzIHRoZVxuICogcmVzcG9uc2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGVycm9yLWZpcnN0IGNhbGxiYWNrXG4gKi9cbm1vZHVsZS5leHBvcnRzLmxvYWQgPSBmdW5jdGlvbiAobG9jYXRpb24sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciByZWFsTWV0aG9kID0gb3B0aW9ucy5tZXRob2QgPyBvcHRpb25zLm1ldGhvZC50b0xvd2VyQ2FzZSgpIDogJ2dldCc7XG4gIHZhciBlcnI7XG4gIHZhciByZWFsUmVxdWVzdDtcblxuICBmdW5jdGlvbiBtYWtlUmVxdWVzdCAoZXJyLCByZXEpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBidWZmZXIoKSBpcyBvbmx5IGF2YWlsYWJsZSBpbiBOb2RlLmpzXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyA/IHByb2Nlc3MgOiAwKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nICYmXG4gICAgICAgICAgdHlwZW9mIHJlcS5idWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVxLmJ1ZmZlcih0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmVxXG4gICAgICAgIC5lbmQoZnVuY3Rpb24gKGVycjIsIHJlcykge1xuICAgICAgICAgIGlmIChlcnIyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCByZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLm1ldGhvZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubWV0aG9kICE9PSAnc3RyaW5nJykge1xuICAgICAgZXJyID0gbmV3IFR5cGVFcnJvcignb3B0aW9ucy5tZXRob2QgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH0gZWxzZSBpZiAoc3VwcG9ydGVkSHR0cE1ldGhvZHMuaW5kZXhPZihvcHRpb25zLm1ldGhvZCkgPT09IC0xKSB7XG4gICAgICBlcnIgPSBuZXcgVHlwZUVycm9yKCdvcHRpb25zLm1ldGhvZCBtdXN0IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOiAnICtcbiAgICAgICAgc3VwcG9ydGVkSHR0cE1ldGhvZHMuc2xpY2UoMCwgc3VwcG9ydGVkSHR0cE1ldGhvZHMubGVuZ3RoIC0gMSkuam9pbignLCAnKSArICcgb3IgJyArXG4gICAgICAgIHN1cHBvcnRlZEh0dHBNZXRob2RzW3N1cHBvcnRlZEh0dHBNZXRob2RzLmxlbmd0aCAtIDFdKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMucHJlcGFyZVJlcXVlc3QgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRpb25zLnByZXBhcmVSZXF1ZXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgZXJyID0gbmV3IFR5cGVFcnJvcignb3B0aW9ucy5wcmVwYXJlUmVxdWVzdCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICghZXJyKSB7XG4gICAgcmVhbFJlcXVlc3QgPSByZXF1ZXN0W3JlYWxNZXRob2QgPT09ICdkZWxldGUnID8gJ2RlbCcgOiByZWFsTWV0aG9kXShsb2NhdGlvbik7XG5cbiAgICBpZiAob3B0aW9ucy5wcmVwYXJlUmVxdWVzdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb3B0aW9ucy5wcmVwYXJlUmVxdWVzdChyZWFsUmVxdWVzdCwgbWFrZVJlcXVlc3QpO1xuICAgICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgICBjYWxsYmFjayhlcnIyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFrZVJlcXVlc3QodW5kZWZpbmVkLCByZWFsUmVxdWVzdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKGVycik7XG4gIH1cbn07XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHBhdGggPT4ge1xuXHRjb25zdCBpc0V4dGVuZGVkTGVuZ3RoUGF0aCA9IC9eXFxcXFxcXFxcXD9cXFxcLy50ZXN0KHBhdGgpO1xuXHRjb25zdCBoYXNOb25Bc2NpaSA9IC9bXlxcdTAwMDAtXFx1MDA4MF0rLy50ZXN0KHBhdGgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuXHRpZiAoaXNFeHRlbmRlZExlbmd0aFBhdGggfHwgaGFzTm9uQXNjaWkpIHtcblx0XHRyZXR1cm4gcGF0aDtcblx0fVxuXG5cdHJldHVybiBwYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbn07XG4iLCJmdW5jdGlvbiBBZ2VudCgpIHtcbiAgdGhpcy5fZGVmYXVsdHMgPSBbXTtcbn1cblxuW1widXNlXCIsIFwib25cIiwgXCJvbmNlXCIsIFwic2V0XCIsIFwicXVlcnlcIiwgXCJ0eXBlXCIsIFwiYWNjZXB0XCIsIFwiYXV0aFwiLCBcIndpdGhDcmVkZW50aWFsc1wiLCBcInNvcnRRdWVyeVwiLCBcInJldHJ5XCIsIFwib2tcIiwgXCJyZWRpcmVjdHNcIixcbiBcInRpbWVvdXRcIiwgXCJidWZmZXJcIiwgXCJzZXJpYWxpemVcIiwgXCJwYXJzZVwiLCBcImNhXCIsIFwia2V5XCIsIFwicGZ4XCIsIFwiY2VydFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGZuKSB7XG4gIC8qKiBEZWZhdWx0IHNldHRpbmcgZm9yIGFsbCByZXF1ZXN0cyBmcm9tIHRoaXMgYWdlbnQgKi9cbiAgQWdlbnQucHJvdG90eXBlW2ZuXSA9IGZ1bmN0aW9uKC8qdmFyYXJncyovKSB7XG4gICAgdGhpcy5fZGVmYXVsdHMucHVzaCh7Zm46Zm4sIGFyZ3VtZW50czphcmd1bWVudHN9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbkFnZW50LnByb3RvdHlwZS5fc2V0RGVmYXVsdHMgPSBmdW5jdGlvbihyZXEpIHtcbiAgICB0aGlzLl9kZWZhdWx0cy5mb3JFYWNoKGZ1bmN0aW9uKGRlZikge1xuICAgICAgcmVxW2RlZi5mbl0uYXBwbHkocmVxLCBkZWYuYXJndW1lbnRzKTtcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWdlbnQ7XG4iLCIvKipcbiAqIFJvb3QgcmVmZXJlbmNlIGZvciBpZnJhbWVzLlxuICovXG5cbnZhciByb290O1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IC8vIEJyb3dzZXIgd2luZG93XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgeyAvLyBXZWIgV29ya2VyXG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIHsgLy8gT3RoZXIgZW52aXJvbm1lbnRzXG4gIGNvbnNvbGUud2FybihcIlVzaW5nIGJyb3dzZXItb25seSB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG4gIHJvb3QgPSB0aGlzO1xufVxuXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgUmVxdWVzdEJhc2UgPSByZXF1aXJlKCcuL3JlcXVlc3QtYmFzZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pcy1vYmplY3QnKTtcbnZhciBSZXNwb25zZUJhc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlLWJhc2UnKTtcbnZhciBBZ2VudCA9IHJlcXVpcmUoJy4vYWdlbnQtYmFzZScpO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gbm9vcCgpe307XG5cbi8qKlxuICogRXhwb3NlIGByZXF1ZXN0YC5cbiAqL1xuXG52YXIgcmVxdWVzdCA9IGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsKSB7XG4gIC8vIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1cmwpIHtcbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdCgnR0VUJywgbWV0aG9kKS5lbmQodXJsKTtcbiAgfVxuXG4gIC8vIHVybCBmaXJzdFxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QoJ0dFVCcsIG1ldGhvZCk7XG4gIH1cblxuICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdChtZXRob2QsIHVybCk7XG59XG5cbmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRGV0ZXJtaW5lIFhIUi5cbiAqL1xuXG5yZXF1ZXN0LmdldFhIUiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHJvb3QuWE1MSHR0cFJlcXVlc3RcbiAgICAgICYmICghcm9vdC5sb2NhdGlvbiB8fCAnZmlsZTonICE9IHJvb3QubG9jYXRpb24ucHJvdG9jb2xcbiAgICAgICAgICB8fCAhcm9vdC5BY3RpdmVYT2JqZWN0KSkge1xuICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3Q7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC42LjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuMy4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgfVxuICB0aHJvdyBFcnJvcihcIkJyb3dzZXItb25seSB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQgY291bGQgbm90IGZpbmQgWEhSXCIpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGFkZGVkIHRvIHN1cHBvcnQgSUUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciB0cmltID0gJycudHJpbVxuICA/IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMudHJpbSgpOyB9XG4gIDogZnVuY3Rpb24ocykgeyByZXR1cm4gcy5yZXBsYWNlKC8oXlxccyp8XFxzKiQpL2csICcnKTsgfTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShvYmopIHtcbiAgaWYgKCFpc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICB2YXIgcGFpcnMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIG9ialtrZXldKTtcbiAgfVxuICByZXR1cm4gcGFpcnMuam9pbignJicpO1xufVxuXG4vKipcbiAqIEhlbHBzICdzZXJpYWxpemUnIHdpdGggc2VyaWFsaXppbmcgYXJyYXlzLlxuICogTXV0YXRlcyB0aGUgcGFpcnMgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFpcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICovXG5cbmZ1bmN0aW9uIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHZhbCkge1xuICBpZiAodmFsICE9IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB2YWwuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHYpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICBmb3IodmFyIHN1YmtleSBpbiB2YWwpIHtcbiAgICAgICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSArICdbJyArIHN1YmtleSArICddJywgdmFsW3N1YmtleV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpXG4gICAgICAgICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBzZXJpYWxpemF0aW9uIG1ldGhvZC5cbiAqL1xuXG5yZXF1ZXN0LnNlcmlhbGl6ZU9iamVjdCA9IHNlcmlhbGl6ZTtcblxuLyoqXG4gICogUGFyc2UgdGhlIGdpdmVuIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBgc3RyYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cikge1xuICB2YXIgb2JqID0ge307XG4gIHZhciBwYWlycyA9IHN0ci5zcGxpdCgnJicpO1xuICB2YXIgcGFpcjtcbiAgdmFyIHBvcztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFpcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBwYWlyID0gcGFpcnNbaV07XG4gICAgcG9zID0gcGFpci5pbmRleE9mKCc9Jyk7XG4gICAgaWYgKHBvcyA9PSAtMSkge1xuICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChwYWlyKV0gPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChwYWlyLnNsaWNlKDAsIHBvcykpXSA9XG4gICAgICAgIGRlY29kZVVSSUNvbXBvbmVudChwYWlyLnNsaWNlKHBvcyArIDEpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEV4cG9zZSBwYXJzZXIuXG4gKi9cblxucmVxdWVzdC5wYXJzZVN0cmluZyA9IHBhcnNlU3RyaW5nO1xuXG4vKipcbiAqIERlZmF1bHQgTUlNRSB0eXBlIG1hcC5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKi9cblxucmVxdWVzdC50eXBlcyA9IHtcbiAgaHRtbDogJ3RleHQvaHRtbCcsXG4gIGpzb246ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgeG1sOiAndGV4dC94bWwnLFxuICB1cmxlbmNvZGVkOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0nOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0tZGF0YSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG4vKipcbiAqIERlZmF1bHQgc2VyaWFsaXphdGlvbiBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQuc2VyaWFsaXplWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKG9iail7XG4gKiAgICAgICByZXR1cm4gJ2dlbmVyYXRlZCB4bWwgaGVyZSc7XG4gKiAgICAgfTtcbiAqXG4gKi9cblxucmVxdWVzdC5zZXJpYWxpemUgPSB7XG4gICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBzZXJpYWxpemUsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5zdHJpbmdpZnlcbn07XG5cbi8qKlxuICAqIERlZmF1bHQgcGFyc2Vycy5cbiAgKlxuICAqICAgICBzdXBlcmFnZW50LnBhcnNlWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKHN0cil7XG4gICogICAgICAgcmV0dXJuIHsgb2JqZWN0IHBhcnNlZCBmcm9tIHN0ciB9O1xuICAqICAgICB9O1xuICAqXG4gICovXG5cbnJlcXVlc3QucGFyc2UgPSB7XG4gICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBwYXJzZVN0cmluZyxcbiAgJ2FwcGxpY2F0aW9uL2pzb24nOiBKU09OLnBhcnNlXG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBoZWFkZXIgYHN0cmAgaW50b1xuICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1hcHBlZCBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXIoc3RyKSB7XG4gIHZhciBsaW5lcyA9IHN0ci5zcGxpdCgvXFxyP1xcbi8pO1xuICB2YXIgZmllbGRzID0ge307XG4gIHZhciBpbmRleDtcbiAgdmFyIGxpbmU7XG4gIHZhciBmaWVsZDtcbiAgdmFyIHZhbDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG4gICAgaW5kZXggPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7IC8vIGNvdWxkIGJlIGVtcHR5IGxpbmUsIGp1c3Qgc2tpcCBpdFxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZpZWxkID0gbGluZS5zbGljZSgwLCBpbmRleCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB0cmltKGxpbmUuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgZmllbGRzW2ZpZWxkXSA9IHZhbDtcbiAgfVxuXG4gIHJldHVybiBmaWVsZHM7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYG1pbWVgIGlzIGpzb24gb3IgaGFzICtqc29uIHN0cnVjdHVyZWQgc3ludGF4IHN1ZmZpeC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzSlNPTihtaW1lKSB7XG4gIC8vIHNob3VsZCBtYXRjaCAvanNvbiBvciAranNvblxuICAvLyBidXQgbm90IC9qc29uLXNlcVxuICByZXR1cm4gL1tcXC8rXWpzb24oJHxbXi1cXHddKS8udGVzdChtaW1lKTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZWAgd2l0aCB0aGUgZ2l2ZW4gYHhocmAuXG4gKlxuICogIC0gc2V0IGZsYWdzICgub2ssIC5lcnJvciwgZXRjKVxuICogIC0gcGFyc2UgaGVhZGVyXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogIEFsaWFzaW5nIGBzdXBlcmFnZW50YCBhcyBgcmVxdWVzdGAgaXMgbmljZTpcbiAqXG4gKiAgICAgIHJlcXVlc3QgPSBzdXBlcmFnZW50O1xuICpcbiAqICBXZSBjYW4gdXNlIHRoZSBwcm9taXNlLWxpa2UgQVBJLCBvciBwYXNzIGNhbGxiYWNrczpcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvJykuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvJywgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgU2VuZGluZyBkYXRhIGNhbiBiZSBjaGFpbmVkOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBPciBwYXNzZWQgdG8gYC5zZW5kKClgOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0sIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnBvc3QoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJywgeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqIE9yIGZ1cnRoZXIgcmVkdWNlZCB0byBhIHNpbmdsZSBjYWxsIGZvciBzaW1wbGUgY2FzZXM6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJywgeyBuYW1lOiAndGonIH0sIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogQHBhcmFtIHtYTUxIVFRQUmVxdWVzdH0geGhyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2UocmVxKSB7XG4gIHRoaXMucmVxID0gcmVxO1xuICB0aGlzLnhociA9IHRoaXMucmVxLnhocjtcbiAgLy8gcmVzcG9uc2VUZXh0IGlzIGFjY2Vzc2libGUgb25seSBpZiByZXNwb25zZVR5cGUgaXMgJycgb3IgJ3RleHQnIGFuZCBvbiBvbGRlciBicm93c2Vyc1xuICB0aGlzLnRleHQgPSAoKHRoaXMucmVxLm1ldGhvZCAhPSdIRUFEJyAmJiAodGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAnJyB8fCB0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JykpIHx8IHR5cGVvZiB0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICd1bmRlZmluZWQnKVxuICAgICA/IHRoaXMueGhyLnJlc3BvbnNlVGV4dFxuICAgICA6IG51bGw7XG4gIHRoaXMuc3RhdHVzVGV4dCA9IHRoaXMucmVxLnhoci5zdGF0dXNUZXh0O1xuICB2YXIgc3RhdHVzID0gdGhpcy54aHIuc3RhdHVzO1xuICAvLyBoYW5kbGUgSUU5IGJ1ZzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDA0Njk3Mi9tc2llLXJldHVybnMtc3RhdHVzLWNvZGUtb2YtMTIyMy1mb3ItYWpheC1yZXF1ZXN0XG4gIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICBzdGF0dXMgPSAyMDQ7XG4gIH1cbiAgdGhpcy5fc2V0U3RhdHVzUHJvcGVydGllcyhzdGF0dXMpO1xuICB0aGlzLmhlYWRlciA9IHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVyKHRoaXMueGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKTtcbiAgLy8gZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIHNvbWV0aW1lcyBmYWxzZWx5IHJldHVybnMgXCJcIiBmb3IgQ09SUyByZXF1ZXN0cywgYnV0XG4gIC8vIGdldFJlc3BvbnNlSGVhZGVyIHN0aWxsIHdvcmtzLiBzbyB3ZSBnZXQgY29udGVudC10eXBlIGV2ZW4gaWYgZ2V0dGluZ1xuICAvLyBvdGhlciBoZWFkZXJzIGZhaWxzLlxuICB0aGlzLmhlYWRlclsnY29udGVudC10eXBlJ10gPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJyk7XG4gIHRoaXMuX3NldEhlYWRlclByb3BlcnRpZXModGhpcy5oZWFkZXIpO1xuXG4gIGlmIChudWxsID09PSB0aGlzLnRleHQgJiYgcmVxLl9yZXNwb25zZVR5cGUpIHtcbiAgICB0aGlzLmJvZHkgPSB0aGlzLnhoci5yZXNwb25zZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmJvZHkgPSB0aGlzLnJlcS5tZXRob2QgIT0gJ0hFQUQnXG4gICAgICA/IHRoaXMuX3BhcnNlQm9keSh0aGlzLnRleHQgPyB0aGlzLnRleHQgOiB0aGlzLnhoci5yZXNwb25zZSlcbiAgICAgIDogbnVsbDtcbiAgfVxufVxuXG5SZXNwb25zZUJhc2UoUmVzcG9uc2UucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYm9keSBgc3RyYC5cbiAqXG4gKiBVc2VkIGZvciBhdXRvLXBhcnNpbmcgb2YgYm9kaWVzLiBQYXJzZXJzXG4gKiBhcmUgZGVmaW5lZCBvbiB0aGUgYHN1cGVyYWdlbnQucGFyc2VgIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5fcGFyc2VCb2R5ID0gZnVuY3Rpb24oc3RyKSB7XG4gIHZhciBwYXJzZSA9IHJlcXVlc3QucGFyc2VbdGhpcy50eXBlXTtcbiAgaWYgKHRoaXMucmVxLl9wYXJzZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZXEuX3BhcnNlcih0aGlzLCBzdHIpO1xuICB9XG4gIGlmICghcGFyc2UgJiYgaXNKU09OKHRoaXMudHlwZSkpIHtcbiAgICBwYXJzZSA9IHJlcXVlc3QucGFyc2VbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgfVxuICByZXR1cm4gcGFyc2UgJiYgc3RyICYmIChzdHIubGVuZ3RoIHx8IHN0ciBpbnN0YW5jZW9mIE9iamVjdClcbiAgICA/IHBhcnNlKHN0cilcbiAgICA6IG51bGw7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbiBgRXJyb3JgIHJlcHJlc2VudGF0aXZlIG9mIHRoaXMgcmVzcG9uc2UuXG4gKlxuICogQHJldHVybiB7RXJyb3J9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS50b0Vycm9yID0gZnVuY3Rpb24oKXtcbiAgdmFyIHJlcSA9IHRoaXMucmVxO1xuICB2YXIgbWV0aG9kID0gcmVxLm1ldGhvZDtcbiAgdmFyIHVybCA9IHJlcS51cmw7XG5cbiAgdmFyIG1zZyA9ICdjYW5ub3QgJyArIG1ldGhvZCArICcgJyArIHVybCArICcgKCcgKyB0aGlzLnN0YXR1cyArICcpJztcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSBtZXRob2Q7XG4gIGVyci51cmwgPSB1cmw7XG5cbiAgcmV0dXJuIGVycjtcbn07XG5cbi8qKlxuICogRXhwb3NlIGBSZXNwb25zZWAuXG4gKi9cblxucmVxdWVzdC5SZXNwb25zZSA9IFJlc3BvbnNlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlcXVlc3RgIHdpdGggdGhlIGdpdmVuIGBtZXRob2RgIGFuZCBgdXJsYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3QobWV0aG9kLCB1cmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9xdWVyeSA9IHRoaXMuX3F1ZXJ5IHx8IFtdO1xuICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgdGhpcy51cmwgPSB1cmw7XG4gIHRoaXMuaGVhZGVyID0ge307IC8vIHByZXNlcnZlcyBoZWFkZXIgbmFtZSBjYXNlXG4gIHRoaXMuX2hlYWRlciA9IHt9OyAvLyBjb2VyY2VzIGhlYWRlciBuYW1lcyB0byBsb3dlcmNhc2VcbiAgdGhpcy5vbignZW5kJywgZnVuY3Rpb24oKXtcbiAgICB2YXIgZXJyID0gbnVsbDtcbiAgICB2YXIgcmVzID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICByZXMgPSBuZXcgUmVzcG9uc2Uoc2VsZik7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBlcnIgPSBuZXcgRXJyb3IoJ1BhcnNlciBpcyB1bmFibGUgdG8gcGFyc2UgdGhlIHJlc3BvbnNlJyk7XG4gICAgICBlcnIucGFyc2UgPSB0cnVlO1xuICAgICAgZXJyLm9yaWdpbmFsID0gZTtcbiAgICAgIC8vIGlzc3VlICM2NzU6IHJldHVybiB0aGUgcmF3IHJlc3BvbnNlIGlmIHRoZSByZXNwb25zZSBwYXJzaW5nIGZhaWxzXG4gICAgICBpZiAoc2VsZi54aHIpIHtcbiAgICAgICAgLy8gaWU5IGRvZXNuJ3QgaGF2ZSAncmVzcG9uc2UnIHByb3BlcnR5XG4gICAgICAgIGVyci5yYXdSZXNwb25zZSA9IHR5cGVvZiBzZWxmLnhoci5yZXNwb25zZVR5cGUgPT0gJ3VuZGVmaW5lZCcgPyBzZWxmLnhoci5yZXNwb25zZVRleHQgOiBzZWxmLnhoci5yZXNwb25zZTtcbiAgICAgICAgLy8gaXNzdWUgIzg3NjogcmV0dXJuIHRoZSBodHRwIHN0YXR1cyBjb2RlIGlmIHRoZSByZXNwb25zZSBwYXJzaW5nIGZhaWxzXG4gICAgICAgIGVyci5zdGF0dXMgPSBzZWxmLnhoci5zdGF0dXMgPyBzZWxmLnhoci5zdGF0dXMgOiBudWxsO1xuICAgICAgICBlcnIuc3RhdHVzQ29kZSA9IGVyci5zdGF0dXM7IC8vIGJhY2t3YXJkcy1jb21wYXQgb25seVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyLnJhd1Jlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgZXJyLnN0YXR1cyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgc2VsZi5lbWl0KCdyZXNwb25zZScsIHJlcyk7XG5cbiAgICB2YXIgbmV3X2VycjtcbiAgICB0cnkge1xuICAgICAgaWYgKCFzZWxmLl9pc1Jlc3BvbnNlT0socmVzKSkge1xuICAgICAgICBuZXdfZXJyID0gbmV3IEVycm9yKHJlcy5zdGF0dXNUZXh0IHx8ICdVbnN1Y2Nlc3NmdWwgSFRUUCByZXNwb25zZScpO1xuICAgICAgfVxuICAgIH0gY2F0Y2goY3VzdG9tX2Vycikge1xuICAgICAgbmV3X2VyciA9IGN1c3RvbV9lcnI7IC8vIG9rKCkgY2FsbGJhY2sgY2FuIHRocm93XG4gICAgfVxuXG4gICAgLy8gIzEwMDAgZG9uJ3QgY2F0Y2ggZXJyb3JzIGZyb20gdGhlIGNhbGxiYWNrIHRvIGF2b2lkIGRvdWJsZSBjYWxsaW5nIGl0XG4gICAgaWYgKG5ld19lcnIpIHtcbiAgICAgIG5ld19lcnIub3JpZ2luYWwgPSBlcnI7XG4gICAgICBuZXdfZXJyLnJlc3BvbnNlID0gcmVzO1xuICAgICAgbmV3X2Vyci5zdGF0dXMgPSByZXMuc3RhdHVzO1xuICAgICAgc2VsZi5jYWxsYmFjayhuZXdfZXJyLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBNaXhpbiBgRW1pdHRlcmAgYW5kIGBSZXF1ZXN0QmFzZWAuXG4gKi9cblxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5SZXF1ZXN0QmFzZShSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0IENvbnRlbnQtVHlwZSB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgnYXBwbGljYXRpb24veG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odHlwZSl7XG4gIHRoaXMuc2V0KCdDb250ZW50LVR5cGUnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IEFjY2VwdCB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy5qc29uID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcbiAqICAgICAgICAuYWNjZXB0KCdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWNjZXB0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odHlwZSl7XG4gIHRoaXMuc2V0KCdBY2NlcHQnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IEF1dGhvcml6YXRpb24gZmllbGQgdmFsdWUgd2l0aCBgdXNlcmAgYW5kIGBwYXNzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXNlclxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXNzXSBvcHRpb25hbCBpbiBjYXNlIG9mIHVzaW5nICdiZWFyZXInIGFzIHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHdpdGggJ3R5cGUnIHByb3BlcnR5ICdhdXRvJywgJ2Jhc2ljJyBvciAnYmVhcmVyJyAoZGVmYXVsdCAnYmFzaWMnKVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbih1c2VyLCBwYXNzLCBvcHRpb25zKXtcbiAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHBhc3MgPSAnJztcbiAgaWYgKHR5cGVvZiBwYXNzID09PSAnb2JqZWN0JyAmJiBwYXNzICE9PSBudWxsKSB7IC8vIHBhc3MgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZXBsYWNlZCB3aXRoIG9wdGlvbnNcbiAgICBvcHRpb25zID0gcGFzcztcbiAgICBwYXNzID0gJyc7XG4gIH1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHR5cGU6ICdmdW5jdGlvbicgPT09IHR5cGVvZiBidG9hID8gJ2Jhc2ljJyA6ICdhdXRvJyxcbiAgICB9O1xuICB9XG5cbiAgdmFyIGVuY29kZXIgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGJ0b2EpIHtcbiAgICAgIHJldHVybiBidG9hKHN0cmluZyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSBiYXNpYyBhdXRoLCBidG9hIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH07XG5cbiAgcmV0dXJuIHRoaXMuX2F1dGgodXNlciwgcGFzcywgb3B0aW9ucywgZW5jb2Rlcik7XG59O1xuXG4vKipcbiAqIEFkZCBxdWVyeS1zdHJpbmcgYHZhbGAuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICByZXF1ZXN0LmdldCgnL3Nob2VzJylcbiAqICAgICAucXVlcnkoJ3NpemU9MTAnKVxuICogICAgIC5xdWVyeSh7IGNvbG9yOiAnYmx1ZScgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24odmFsKXtcbiAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiB2YWwpIHZhbCA9IHNlcmlhbGl6ZSh2YWwpO1xuICBpZiAodmFsKSB0aGlzLl9xdWVyeS5wdXNoKHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBRdWV1ZSB0aGUgZ2l2ZW4gYGZpbGVgIGFzIGFuIGF0dGFjaG1lbnQgdG8gdGhlIHNwZWNpZmllZCBgZmllbGRgLFxuICogd2l0aCBvcHRpb25hbCBgb3B0aW9uc2AgKG9yIGZpbGVuYW1lKS5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5hdHRhY2goJ2NvbnRlbnQnLCBuZXcgQmxvYihbJzxhIGlkPVwiYVwiPjxiIGlkPVwiYlwiPmhleSE8L2I+PC9hPiddLCB7IHR5cGU6IFwidGV4dC9odG1sXCJ9KSlcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEBwYXJhbSB7QmxvYnxGaWxlfSBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbihmaWVsZCwgZmlsZSwgb3B0aW9ucyl7XG4gIGlmIChmaWxlKSB7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHRocm93IEVycm9yKFwic3VwZXJhZ2VudCBjYW4ndCBtaXggLnNlbmQoKSBhbmQgLmF0dGFjaCgpXCIpO1xuICAgIH1cblxuICAgIHRoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKGZpZWxkLCBmaWxlLCBvcHRpb25zIHx8IGZpbGUubmFtZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5fZ2V0Rm9ybURhdGEgPSBmdW5jdGlvbigpe1xuICBpZiAoIXRoaXMuX2Zvcm1EYXRhKSB7XG4gICAgdGhpcy5fZm9ybURhdGEgPSBuZXcgcm9vdC5Gb3JtRGF0YSgpO1xuICB9XG4gIHJldHVybiB0aGlzLl9mb3JtRGF0YTtcbn07XG5cbi8qKlxuICogSW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIGBlcnJgIGFuZCBgcmVzYFxuICogYW5kIGhhbmRsZSBhcml0eSBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2FsbGJhY2sgPSBmdW5jdGlvbihlcnIsIHJlcyl7XG4gIGlmICh0aGlzLl9zaG91bGRSZXRyeShlcnIsIHJlcykpIHtcbiAgICByZXR1cm4gdGhpcy5fcmV0cnkoKTtcbiAgfVxuXG4gIHZhciBmbiA9IHRoaXMuX2NhbGxiYWNrO1xuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuXG4gIGlmIChlcnIpIHtcbiAgICBpZiAodGhpcy5fbWF4UmV0cmllcykgZXJyLnJldHJpZXMgPSB0aGlzLl9yZXRyaWVzIC0gMTtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxuXG4gIGZuKGVyciwgcmVzKTtcbn07XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIHdpdGggeC1kb21haW4gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3Jvc3NEb21haW5FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1JlcXVlc3QgaGFzIGJlZW4gdGVybWluYXRlZFxcblBvc3NpYmxlIGNhdXNlczogdGhlIG5ldHdvcmsgaXMgb2ZmbGluZSwgT3JpZ2luIGlzIG5vdCBhbGxvd2VkIGJ5IEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbiwgdGhlIHBhZ2UgaXMgYmVpbmcgdW5sb2FkZWQsIGV0Yy4nKTtcbiAgZXJyLmNyb3NzRG9tYWluID0gdHJ1ZTtcblxuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSB0aGlzLm1ldGhvZDtcbiAgZXJyLnVybCA9IHRoaXMudXJsO1xuXG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cbi8vIFRoaXMgb25seSB3YXJucywgYmVjYXVzZSB0aGUgcmVxdWVzdCBpcyBzdGlsbCBsaWtlbHkgdG8gd29ya1xuUmVxdWVzdC5wcm90b3R5cGUuYnVmZmVyID0gUmVxdWVzdC5wcm90b3R5cGUuY2EgPSBSZXF1ZXN0LnByb3RvdHlwZS5hZ2VudCA9IGZ1bmN0aW9uKCl7XG4gIGNvbnNvbGUud2FybihcIlRoaXMgaXMgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyIHZlcnNpb24gb2Ygc3VwZXJhZ2VudFwiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBUaGlzIHRocm93cywgYmVjYXVzZSBpdCBjYW4ndCBzZW5kL3JlY2VpdmUgZGF0YSBhcyBleHBlY3RlZFxuUmVxdWVzdC5wcm90b3R5cGUucGlwZSA9IFJlcXVlc3QucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oKXtcbiAgdGhyb3cgRXJyb3IoXCJTdHJlYW1pbmcgaXMgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyIHZlcnNpb24gb2Ygc3VwZXJhZ2VudFwiKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBob3N0IG9iamVjdCxcbiAqIHdlIGRvbid0IHdhbnQgdG8gc2VyaWFsaXplIHRoZXNlIDopXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5SZXF1ZXN0LnByb3RvdHlwZS5faXNIb3N0ID0gZnVuY3Rpb24gX2lzSG9zdChvYmopIHtcbiAgLy8gTmF0aXZlIG9iamVjdHMgc3RyaW5naWZ5IHRvIFtvYmplY3QgRmlsZV0sIFtvYmplY3QgQmxvYl0sIFtvYmplY3QgRm9ybURhdGFdLCBldGMuXG4gIHJldHVybiBvYmogJiYgJ29iamVjdCcgPT09IHR5cGVvZiBvYmogJiYgIUFycmF5LmlzQXJyYXkob2JqKSAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSAhPT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbi8qKlxuICogSW5pdGlhdGUgcmVxdWVzdCwgaW52b2tpbmcgY2FsbGJhY2sgYGZuKHJlcylgXG4gKiB3aXRoIGFuIGluc3RhbmNlb2YgYFJlc3BvbnNlYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGZuKXtcbiAgaWYgKHRoaXMuX2VuZENhbGxlZCkge1xuICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IC5lbmQoKSB3YXMgY2FsbGVkIHR3aWNlLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gc3VwZXJhZ2VudFwiKTtcbiAgfVxuICB0aGlzLl9lbmRDYWxsZWQgPSB0cnVlO1xuXG4gIC8vIHN0b3JlIGNhbGxiYWNrXG4gIHRoaXMuX2NhbGxiYWNrID0gZm4gfHwgbm9vcDtcblxuICAvLyBxdWVyeXN0cmluZ1xuICB0aGlzLl9maW5hbGl6ZVF1ZXJ5U3RyaW5nKCk7XG5cbiAgcmV0dXJuIHRoaXMuX2VuZCgpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuX2VuZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB4aHIgPSAodGhpcy54aHIgPSByZXF1ZXN0LmdldFhIUigpKTtcbiAgdmFyIGRhdGEgPSB0aGlzLl9mb3JtRGF0YSB8fCB0aGlzLl9kYXRhO1xuXG4gIHRoaXMuX3NldFRpbWVvdXRzKCk7XG5cbiAgLy8gc3RhdGUgY2hhbmdlXG4gIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xuICAgIHZhciByZWFkeVN0YXRlID0geGhyLnJlYWR5U3RhdGU7XG4gICAgaWYgKHJlYWR5U3RhdGUgPj0gMiAmJiBzZWxmLl9yZXNwb25zZVRpbWVvdXRUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3Jlc3BvbnNlVGltZW91dFRpbWVyKTtcbiAgICB9XG4gICAgaWYgKDQgIT0gcmVhZHlTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluIElFOSwgcmVhZHMgdG8gYW55IHByb3BlcnR5IChlLmcuIHN0YXR1cykgb2ZmIG9mIGFuIGFib3J0ZWQgWEhSIHdpbGxcbiAgICAvLyByZXN1bHQgaW4gdGhlIGVycm9yIFwiQ291bGQgbm90IGNvbXBsZXRlIHRoZSBvcGVyYXRpb24gZHVlIHRvIGVycm9yIGMwMGMwMjNmXCJcbiAgICB2YXIgc3RhdHVzO1xuICAgIHRyeSB7IHN0YXR1cyA9IHhoci5zdGF0dXMgfSBjYXRjaChlKSB7IHN0YXR1cyA9IDA7IH1cblxuICAgIGlmICghc3RhdHVzKSB7XG4gICAgICBpZiAoc2VsZi50aW1lZG91dCB8fCBzZWxmLl9hYm9ydGVkKSByZXR1cm47XG4gICAgICByZXR1cm4gc2VsZi5jcm9zc0RvbWFpbkVycm9yKCk7XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZW5kJyk7XG4gIH07XG5cbiAgLy8gcHJvZ3Jlc3NcbiAgdmFyIGhhbmRsZVByb2dyZXNzID0gZnVuY3Rpb24oZGlyZWN0aW9uLCBlKSB7XG4gICAgaWYgKGUudG90YWwgPiAwKSB7XG4gICAgICBlLnBlcmNlbnQgPSBlLmxvYWRlZCAvIGUudG90YWwgKiAxMDA7XG4gICAgfVxuICAgIGUuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIHNlbGYuZW1pdCgncHJvZ3Jlc3MnLCBlKTtcbiAgfTtcbiAgaWYgKHRoaXMuaGFzTGlzdGVuZXJzKCdwcm9ncmVzcycpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHhoci5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3MuYmluZChudWxsLCAnZG93bmxvYWQnKTtcbiAgICAgIGlmICh4aHIudXBsb2FkKSB7XG4gICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzLmJpbmQobnVsbCwgJ3VwbG9hZCcpO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgLy8gQWNjZXNzaW5nIHhoci51cGxvYWQgZmFpbHMgaW4gSUUgZnJvbSBhIHdlYiB3b3JrZXIsIHNvIGp1c3QgcHJldGVuZCBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgLy8gUmVwb3J0ZWQgaGVyZTpcbiAgICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvODM3MjQ1L3htbGh0dHByZXF1ZXN0LXVwbG9hZC10aHJvd3MtaW52YWxpZC1hcmd1bWVudC13aGVuLXVzZWQtZnJvbS13ZWItd29ya2VyLWNvbnRleHRcbiAgICB9XG4gIH1cblxuICAvLyBpbml0aWF0ZSByZXF1ZXN0XG4gIHRyeSB7XG4gICAgaWYgKHRoaXMudXNlcm5hbWUgJiYgdGhpcy5wYXNzd29yZCkge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlLCB0aGlzLnVzZXJuYW1lLCB0aGlzLnBhc3N3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIHNlZSAjMTE0OVxuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrKGVycik7XG4gIH1cblxuICAvLyBDT1JTXG4gIGlmICh0aGlzLl93aXRoQ3JlZGVudGlhbHMpIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXG4gIC8vIGJvZHlcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSAmJiAnR0VUJyAhPSB0aGlzLm1ldGhvZCAmJiAnSEVBRCcgIT0gdGhpcy5tZXRob2QgJiYgJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgJiYgIXRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgIC8vIHNlcmlhbGl6ZSBzdHVmZlxuICAgIHZhciBjb250ZW50VHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG4gICAgdmFyIHNlcmlhbGl6ZSA9IHRoaXMuX3NlcmlhbGl6ZXIgfHwgcmVxdWVzdC5zZXJpYWxpemVbY29udGVudFR5cGUgPyBjb250ZW50VHlwZS5zcGxpdCgnOycpWzBdIDogJyddO1xuICAgIGlmICghc2VyaWFsaXplICYmIGlzSlNPTihjb250ZW50VHlwZSkpIHtcbiAgICAgIHNlcmlhbGl6ZSA9IHJlcXVlc3Quc2VyaWFsaXplWydhcHBsaWNhdGlvbi9qc29uJ107XG4gICAgfVxuICAgIGlmIChzZXJpYWxpemUpIGRhdGEgPSBzZXJpYWxpemUoZGF0YSk7XG4gIH1cblxuICAvLyBzZXQgaGVhZGVyIGZpZWxkc1xuICBmb3IgKHZhciBmaWVsZCBpbiB0aGlzLmhlYWRlcikge1xuICAgIGlmIChudWxsID09IHRoaXMuaGVhZGVyW2ZpZWxkXSkgY29udGludWU7XG5cbiAgICBpZiAodGhpcy5oZWFkZXIuaGFzT3duUHJvcGVydHkoZmllbGQpKVxuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoZmllbGQsIHRoaXMuaGVhZGVyW2ZpZWxkXSk7XG4gIH1cblxuICBpZiAodGhpcy5fcmVzcG9uc2VUeXBlKSB7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IHRoaXMuX3Jlc3BvbnNlVHlwZTtcbiAgfVxuXG4gIC8vIHNlbmQgc3R1ZmZcbiAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgdGhpcyk7XG5cbiAgLy8gSUUxMSB4aHIuc2VuZCh1bmRlZmluZWQpIHNlbmRzICd1bmRlZmluZWQnIHN0cmluZyBhcyBQT1NUIHBheWxvYWQgKGluc3RlYWQgb2Ygbm90aGluZylcbiAgLy8gV2UgbmVlZCBudWxsIGhlcmUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgeGhyLnNlbmQodHlwZW9mIGRhdGEgIT09ICd1bmRlZmluZWQnID8gZGF0YSA6IG51bGwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnJlcXVlc3QuYWdlbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBBZ2VudCgpO1xufTtcblxuW1wiR0VUXCIsIFwiUE9TVFwiLCBcIk9QVElPTlNcIiwgXCJQQVRDSFwiLCBcIlBVVFwiLCBcIkRFTEVURVwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBBZ2VudC5wcm90b3R5cGVbbWV0aG9kLnRvTG93ZXJDYXNlKCldID0gZnVuY3Rpb24odXJsLCBmbikge1xuICAgIHZhciByZXEgPSBuZXcgcmVxdWVzdC5SZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbiAgICB0aGlzLl9zZXREZWZhdWx0cyhyZXEpO1xuICAgIGlmIChmbikge1xuICAgICAgcmVxLmVuZChmbik7XG4gICAgfVxuICAgIHJldHVybiByZXE7XG4gIH07XG59KTtcblxuQWdlbnQucHJvdG90eXBlLmRlbCA9IEFnZW50LnByb3RvdHlwZVsnZGVsZXRlJ107XG5cbi8qKlxuICogR0VUIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5nZXQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdHRVQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEucXVlcnkoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIEhFQUQgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LmhlYWQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdIRUFEJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBPUFRJT05TIHF1ZXJ5IHRvIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5vcHRpb25zID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnT1BUSU9OUycsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBERUxFVEUgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlbCh1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdERUxFVEUnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn1cblxucmVxdWVzdFsnZGVsJ10gPSBkZWw7XG5yZXF1ZXN0WydkZWxldGUnXSA9IGRlbDtcblxuLyoqXG4gKiBQQVRDSCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wYXRjaCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BBVENIJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBPU1QgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucG9zdCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BPU1QnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUFVUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnB1dCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BVVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gbnVsbCAhPT0gb2JqICYmICdvYmplY3QnID09PSB0eXBlb2Ygb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBvZiBtaXhlZC1pbiBmdW5jdGlvbnMgc2hhcmVkIGJldHdlZW4gbm9kZSBhbmQgY2xpZW50IGNvZGVcbiAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pcy1vYmplY3QnKTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlcXVlc3RCYXNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RCYXNlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlcXVlc3RCYXNlYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3RCYXNlKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn1cblxuLyoqXG4gKiBNaXhpbiB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBSZXF1ZXN0QmFzZS5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IFJlcXVlc3RCYXNlLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogQ2xlYXIgcHJldmlvdXMgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uIF9jbGVhclRpbWVvdXQoKXtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyKTtcbiAgZGVsZXRlIHRoaXMuX3RpbWVyO1xuICBkZWxldGUgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXI7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlc3BvbnNlIGJvZHkgcGFyc2VyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGluY29taW5nIGRhdGEgaW50byByZXF1ZXN0LmJvZHlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShmbil7XG4gIHRoaXMuX3BhcnNlciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IGZvcm1hdCBvZiBiaW5hcnkgcmVzcG9uc2UgYm9keS5cbiAqIEluIGJyb3dzZXIgdmFsaWQgZm9ybWF0cyBhcmUgJ2Jsb2InIGFuZCAnYXJyYXlidWZmZXInLFxuICogd2hpY2ggcmV0dXJuIEJsb2IgYW5kIEFycmF5QnVmZmVyLCByZXNwZWN0aXZlbHkuXG4gKlxuICogSW4gTm9kZSBhbGwgdmFsdWVzIHJlc3VsdCBpbiBCdWZmZXIuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAucmVzcG9uc2VUeXBlKCdibG9iJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJlc3BvbnNlVHlwZSA9IGZ1bmN0aW9uKHZhbCl7XG4gIHRoaXMuX3Jlc3BvbnNlVHlwZSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGRlZmF1bHQgcmVxdWVzdCBib2R5IHNlcmlhbGl6ZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIGNvbnZlcnQgZGF0YSBzZXQgdmlhIC5zZW5kIG9yIC5hdHRhY2ggaW50byBwYXlsb2FkIHRvIHNlbmRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKGZuKXtcbiAgdGhpcy5fc2VyaWFsaXplciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRpbWVvdXRzLlxuICpcbiAqIC0gcmVzcG9uc2UgdGltZW91dCBpcyB0aW1lIGJldHdlZW4gc2VuZGluZyByZXF1ZXN0IGFuZCByZWNlaXZpbmcgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIHJlc3BvbnNlLiBJbmNsdWRlcyBETlMgYW5kIGNvbm5lY3Rpb24gdGltZS5cbiAqIC0gZGVhZGxpbmUgaXMgdGhlIHRpbWUgZnJvbSBzdGFydCBvZiB0aGUgcmVxdWVzdCB0byByZWNlaXZpbmcgcmVzcG9uc2UgYm9keSBpbiBmdWxsLiBJZiB0aGUgZGVhZGxpbmUgaXMgdG9vIHNob3J0IGxhcmdlIGZpbGVzIG1heSBub3QgbG9hZCBhdCBhbGwgb24gc2xvdyBjb25uZWN0aW9ucy5cbiAqXG4gKiBWYWx1ZSBvZiAwIG9yIGZhbHNlIG1lYW5zIG5vIHRpbWVvdXQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBtcyBvciB7cmVzcG9uc2UsIGRlYWRsaW5lfVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gdGltZW91dChvcHRpb25zKXtcbiAgaWYgKCFvcHRpb25zIHx8ICdvYmplY3QnICE9PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zO1xuICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmb3IodmFyIG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgc3dpdGNoKG9wdGlvbikge1xuICAgICAgY2FzZSAnZGVhZGxpbmUnOlxuICAgICAgICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucy5kZWFkbGluZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZXNwb25zZSc6XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dCA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biB0aW1lb3V0IG9wdGlvblwiLCBvcHRpb24pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IG51bWJlciBvZiByZXRyeSBhdHRlbXB0cyBvbiBlcnJvci5cbiAqXG4gKiBGYWlsZWQgcmVxdWVzdHMgd2lsbCBiZSByZXRyaWVkICdjb3VudCcgdGltZXMgaWYgdGltZW91dCBvciBlcnIuY29kZSA+PSA1MDAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJldHJ5ID0gZnVuY3Rpb24gcmV0cnkoY291bnQsIGZuKXtcbiAgLy8gRGVmYXVsdCB0byAxIGlmIG5vIGNvdW50IHBhc3NlZCBvciB0cnVlXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IGNvdW50ID09PSB0cnVlKSBjb3VudCA9IDE7XG4gIGlmIChjb3VudCA8PSAwKSBjb3VudCA9IDA7XG4gIHRoaXMuX21heFJldHJpZXMgPSBjb3VudDtcbiAgdGhpcy5fcmV0cmllcyA9IDA7XG4gIHRoaXMuX3JldHJ5Q2FsbGJhY2sgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG52YXIgRVJST1JfQ09ERVMgPSBbXG4gICdFQ09OTlJFU0VUJyxcbiAgJ0VUSU1FRE9VVCcsXG4gICdFQUREUklORk8nLFxuICAnRVNPQ0tFVFRJTUVET1VUJ1xuXTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSByZXF1ZXN0IHNob3VsZCBiZSByZXRyaWVkLlxuICogKEJvcnJvd2VkIGZyb20gc2VnbWVudGlvL3N1cGVyYWdlbnQtcmV0cnkpXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSBbcmVzXVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fc2hvdWxkUmV0cnkgPSBmdW5jdGlvbihlcnIsIHJlcykge1xuICBpZiAoIXRoaXMuX21heFJldHJpZXMgfHwgdGhpcy5fcmV0cmllcysrID49IHRoaXMuX21heFJldHJpZXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRoaXMuX3JldHJ5Q2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgdmFyIG92ZXJyaWRlID0gdGhpcy5fcmV0cnlDYWxsYmFjayhlcnIsIHJlcyk7XG4gICAgICBpZiAob3ZlcnJpZGUgPT09IHRydWUpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKG92ZXJyaWRlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gdW5kZWZpbmVkIGZhbGxzIGJhY2sgdG8gZGVmYXVsdHNcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGlmIChyZXMgJiYgcmVzLnN0YXR1cyAmJiByZXMuc3RhdHVzID49IDUwMCAmJiByZXMuc3RhdHVzICE9IDUwMSkgcmV0dXJuIHRydWU7XG4gIGlmIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgJiYgfkVSUk9SX0NPREVTLmluZGV4T2YoZXJyLmNvZGUpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBTdXBlcmFnZW50IHRpbWVvdXRcbiAgICBpZiAoZXJyLnRpbWVvdXQgJiYgZXJyLmNvZGUgPT0gJ0VDT05OQUJPUlRFRCcpIHJldHVybiB0cnVlO1xuICAgIGlmIChlcnIuY3Jvc3NEb21haW4pIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0cnkgcmVxdWVzdFxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9yZXRyeSA9IGZ1bmN0aW9uKCkge1xuXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG5cbiAgLy8gbm9kZVxuICBpZiAodGhpcy5yZXEpIHtcbiAgICB0aGlzLnJlcSA9IG51bGw7XG4gICAgdGhpcy5yZXEgPSB0aGlzLnJlcXVlc3QoKTtcbiAgfVxuXG4gIHRoaXMuX2Fib3J0ZWQgPSBmYWxzZTtcbiAgdGhpcy50aW1lZG91dCA9IGZhbHNlO1xuXG4gIHJldHVybiB0aGlzLl9lbmQoKTtcbn07XG5cbi8qKlxuICogUHJvbWlzZSBzdXBwb3J0XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlamVjdF1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiB0aGVuKHJlc29sdmUsIHJlamVjdCkge1xuICBpZiAoIXRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLl9lbmRDYWxsZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IHN1cGVyYWdlbnQgcmVxdWVzdCB3YXMgc2VudCB0d2ljZSwgYmVjYXVzZSBib3RoIC5lbmQoKSBhbmQgLnRoZW4oKSB3ZXJlIGNhbGxlZC4gTmV2ZXIgY2FsbCAuZW5kKCkgaWYgeW91IHVzZSBwcm9taXNlc1wiKTtcbiAgICB9XG4gICAgdGhpcy5fZnVsbGZpbGxlZFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihpbm5lclJlc29sdmUsIGlubmVyUmVqZWN0KSB7XG4gICAgICBzZWxmLmVuZChmdW5jdGlvbihlcnIsIHJlcykge1xuICAgICAgICBpZiAoZXJyKSBpbm5lclJlamVjdChlcnIpO1xuICAgICAgICBlbHNlIGlubmVyUmVzb2x2ZShyZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uKGNiKSB7XG4gIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBjYik7XG59O1xuXG4vKipcbiAqIEFsbG93IGZvciBleHRlbnNpb25cbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZuKSB7XG4gIGZuKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5vayA9IGZ1bmN0aW9uKGNiKSB7XG4gIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgY2IpIHRocm93IEVycm9yKFwiQ2FsbGJhY2sgcmVxdWlyZWRcIik7XG4gIHRoaXMuX29rQ2FsbGJhY2sgPSBjYjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2lzUmVzcG9uc2VPSyA9IGZ1bmN0aW9uKHJlcykge1xuICBpZiAoIXJlcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl9va0NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX29rQ2FsbGJhY2socmVzKTtcbiAgfVxuXG4gIHJldHVybiByZXMuc3RhdHVzID49IDIwMCAmJiByZXMuc3RhdHVzIDwgMzAwO1xufTtcblxuLyoqXG4gKiBHZXQgcmVxdWVzdCBoZWFkZXIgYGZpZWxkYC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIHJldHVybiB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGhlYWRlciBgZmllbGRgIHZhbHVlLlxuICogVGhpcyBpcyBhIGRlcHJlY2F0ZWQgaW50ZXJuYWwgQVBJLiBVc2UgYC5nZXQoZmllbGQpYCBpbnN0ZWFkLlxuICpcbiAqIChnZXRIZWFkZXIgaXMgbm8gbG9uZ2VyIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgc3VwZXJhZ2VudCBjb2RlIGJhc2UpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldEhlYWRlciA9IFJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXQ7XG5cbi8qKlxuICogU2V0IGhlYWRlciBgZmllbGRgIHRvIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0LlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuc2V0KCdYLUFQSS1LZXknLCAnZm9vYmFyJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJywgJ1gtQVBJLUtleSc6ICdmb29iYXInIH0pXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihmaWVsZCwgdmFsKXtcbiAgaWYgKGlzT2JqZWN0KGZpZWxkKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBmaWVsZCkge1xuICAgICAgdGhpcy5zZXQoa2V5LCBmaWVsZFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldID0gdmFsO1xuICB0aGlzLmhlYWRlcltmaWVsZF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAudW5zZXQoJ1VzZXItQWdlbnQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIGRlbGV0ZSB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG4gIGRlbGV0ZSB0aGlzLmhlYWRlcltmaWVsZF07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXcml0ZSB0aGUgZmllbGQgYG5hbWVgIGFuZCBgdmFsYCwgb3IgbXVsdGlwbGUgZmllbGRzIHdpdGggb25lIG9iamVjdFxuICogZm9yIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIHJlcXVlc3QgYm9kaWVzLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmZpZWxkKCdmb28nLCAnYmFyJylcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmZpZWxkKHsgZm9vOiAnYmFyJywgYmF6OiAncXV4JyB9KVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd8QmxvYnxGaWxlfEJ1ZmZlcnxmcy5SZWFkU3RyZWFtfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLmZpZWxkID0gZnVuY3Rpb24obmFtZSwgdmFsKSB7XG4gIC8vIG5hbWUgc2hvdWxkIGJlIGVpdGhlciBhIHN0cmluZyBvciBhbiBvYmplY3QuXG4gIGlmIChudWxsID09PSBuYW1lIHx8IHVuZGVmaW5lZCA9PT0gbmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignLmZpZWxkKG5hbWUsIHZhbCkgbmFtZSBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCIuZmllbGQoKSBjYW4ndCBiZSB1c2VkIGlmIC5zZW5kKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiKTtcbiAgfVxuXG4gIGlmIChpc09iamVjdChuYW1lKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG4gICAgICB0aGlzLmZpZWxkKGtleSwgbmFtZVtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgZm9yICh2YXIgaSBpbiB2YWwpIHtcbiAgICAgIHRoaXMuZmllbGQobmFtZSwgdmFsW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB2YWwgc2hvdWxkIGJlIGRlZmluZWQgbm93XG4gIGlmIChudWxsID09PSB2YWwgfHwgdW5kZWZpbmVkID09PSB2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5maWVsZChuYW1lLCB2YWwpIHZhbCBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cbiAgaWYgKCdib29sZWFuJyA9PT0gdHlwZW9mIHZhbCkge1xuICAgIHZhbCA9ICcnICsgdmFsO1xuICB9XG4gIHRoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKG5hbWUsIHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBYm9ydCB0aGUgcmVxdWVzdCwgYW5kIGNsZWFyIHBvdGVudGlhbCB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2Fib3J0ZWQgPSB0cnVlO1xuICB0aGlzLnhociAmJiB0aGlzLnhoci5hYm9ydCgpOyAvLyBicm93c2VyXG4gIHRoaXMucmVxICYmIHRoaXMucmVxLmFib3J0KCk7IC8vIG5vZGVcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgdGhpcy5lbWl0KCdhYm9ydCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fYXV0aCA9IGZ1bmN0aW9uKHVzZXIsIHBhc3MsIG9wdGlvbnMsIGJhc2U2NEVuY29kZXIpIHtcbiAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICBjYXNlICdiYXNpYyc6XG4gICAgICB0aGlzLnNldCgnQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgYmFzZTY0RW5jb2Rlcih1c2VyICsgJzonICsgcGFzcykpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhdXRvJzpcbiAgICAgIHRoaXMudXNlcm5hbWUgPSB1c2VyO1xuICAgICAgdGhpcy5wYXNzd29yZCA9IHBhc3M7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JlYXJlcic6IC8vIHVzYWdlIHdvdWxkIGJlIC5hdXRoKGFjY2Vzc1Rva2VuLCB7IHR5cGU6ICdiZWFyZXInIH0pXG4gICAgICB0aGlzLnNldCgnQXV0aG9yaXphdGlvbicsICdCZWFyZXIgJyArIHVzZXIpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZSB0cmFuc21pc3Npb24gb2YgY29va2llcyB3aXRoIHgtZG9tYWluIHJlcXVlc3RzLlxuICpcbiAqIE5vdGUgdGhhdCBmb3IgdGhpcyB0byB3b3JrIHRoZSBvcmlnaW4gbXVzdCBub3QgYmVcbiAqIHVzaW5nIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIgd2l0aCBhIHdpbGRjYXJkLFxuICogYW5kIGFsc28gbXVzdCBzZXQgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiXG4gKiB0byBcInRydWVcIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS53aXRoQ3JlZGVudGlhbHMgPSBmdW5jdGlvbihvbikge1xuICAvLyBUaGlzIGlzIGJyb3dzZXItb25seSBmdW5jdGlvbmFsaXR5LiBOb2RlIHNpZGUgaXMgbm8tb3AuXG4gIGlmIChvbiA9PSB1bmRlZmluZWQpIG9uID0gdHJ1ZTtcbiAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gb247XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heCByZWRpcmVjdHMgdG8gYG5gLiBEb2VzIG5vdGluZyBpbiBicm93c2VyIFhIUiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZWRpcmVjdHMgPSBmdW5jdGlvbihuKXtcbiAgdGhpcy5fbWF4UmVkaXJlY3RzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1heGltdW0gc2l6ZSBvZiBidWZmZXJlZCByZXNwb25zZSBib2R5LCBpbiBieXRlcy4gQ291bnRzIHVuY29tcHJlc3NlZCBzaXplLlxuICogRGVmYXVsdCAyMDBNQi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5tYXhSZXNwb25zZVNpemUgPSBmdW5jdGlvbihuKXtcbiAgaWYgKCdudW1iZXInICE9PSB0eXBlb2Ygbikge1xuICAgIHRocm93IFR5cGVFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7XG4gIH1cbiAgdGhpcy5fbWF4UmVzcG9uc2VTaXplID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdG8gYSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCAobm90IEpTT04gc3RyaW5nKSBvZiBzY2FsYXIgcHJvcGVydGllcy5cbiAqIE5vdGUgYXMgdGhpcyBtZXRob2QgaXMgZGVzaWduZWQgdG8gcmV0dXJuIGEgdXNlZnVsIG5vbi10aGlzIHZhbHVlLFxuICogaXQgY2Fubm90IGJlIGNoYWluZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZXNjcmliaW5nIG1ldGhvZCwgdXJsLCBhbmQgZGF0YSBvZiB0aGlzIHJlcXVlc3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgdXJsOiB0aGlzLnVybCxcbiAgICBkYXRhOiB0aGlzLl9kYXRhLFxuICAgIGhlYWRlcnM6IHRoaXMuX2hlYWRlcixcbiAgfTtcbn07XG5cbi8qKlxuICogU2VuZCBgZGF0YWAgYXMgdGhlIHJlcXVlc3QgYm9keSwgZGVmYXVsdGluZyB0aGUgYC50eXBlKClgIHRvIFwianNvblwiIHdoZW5cbiAqIGFuIG9iamVjdCBpcyBnaXZlbi5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBtYW51YWwganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdqc29uJylcbiAqICAgICAgICAgLnNlbmQoJ3tcIm5hbWVcIjpcInRqXCJ9JylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBtYW51YWwgeC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCgnbmFtZT10aicpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGRlZmF1bHRzIHRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCgnbmFtZT10b2JpJylcbiAqICAgICAgICAuc2VuZCgnc3BlY2llcz1mZXJyZXQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKXtcbiAgdmFyIGlzT2JqID0gaXNPYmplY3QoZGF0YSk7XG4gIHZhciB0eXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcblxuICBpZiAodGhpcy5fZm9ybURhdGEpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiLnNlbmQoKSBjYW4ndCBiZSB1c2VkIGlmIC5hdHRhY2goKSBvciAuZmllbGQoKSBpcyB1c2VkLiBQbGVhc2UgdXNlIG9ubHkgLnNlbmQoKSBvciBvbmx5IC5maWVsZCgpICYgLmF0dGFjaCgpXCIpO1xuICB9XG5cbiAgaWYgKGlzT2JqICYmICF0aGlzLl9kYXRhKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB7fTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGF0YSAmJiB0aGlzLl9kYXRhICYmIHRoaXMuX2lzSG9zdCh0aGlzLl9kYXRhKSkge1xuICAgIHRocm93IEVycm9yKFwiQ2FuJ3QgbWVyZ2UgdGhlc2Ugc2VuZCBjYWxsc1wiKTtcbiAgfVxuXG4gIC8vIG1lcmdlXG4gIGlmIChpc09iaiAmJiBpc09iamVjdCh0aGlzLl9kYXRhKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhW2tleV0gPSBkYXRhW2tleV07XG4gICAgfVxuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBkYXRhKSB7XG4gICAgLy8gZGVmYXVsdCB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnZm9ybScpO1xuICAgIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICAgIGlmICgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyA9PSB0eXBlKSB7XG4gICAgICB0aGlzLl9kYXRhID0gdGhpcy5fZGF0YVxuICAgICAgICA/IHRoaXMuX2RhdGEgKyAnJicgKyBkYXRhXG4gICAgICAgIDogZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGF0YSA9ICh0aGlzLl9kYXRhIHx8ICcnKSArIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG5cbiAgaWYgKCFpc09iaiB8fCB0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGRlZmF1bHQgdG8ganNvblxuICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnanNvbicpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU29ydCBgcXVlcnlzdHJpbmdgIGJ5IHRoZSBzb3J0IGZ1bmN0aW9uXG4gKlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIGRlZmF1bHQgb3JkZXJcbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvdXNlcicpXG4gKiAgICAgICAgIC5xdWVyeSgnbmFtZT1OaWNrJylcbiAqICAgICAgICAgLnF1ZXJ5KCdzZWFyY2g9TWFubnknKVxuICogICAgICAgICAuc29ydFF1ZXJ5KClcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBjdXN0b21pemVkIHNvcnQgZnVuY3Rpb25cbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvdXNlcicpXG4gKiAgICAgICAgIC5xdWVyeSgnbmFtZT1OaWNrJylcbiAqICAgICAgICAgLnF1ZXJ5KCdzZWFyY2g9TWFubnknKVxuICogICAgICAgICAuc29ydFF1ZXJ5KGZ1bmN0aW9uKGEsIGIpe1xuICogICAgICAgICAgIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICogICAgICAgICB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNvcnRRdWVyeSA9IGZ1bmN0aW9uKHNvcnQpIHtcbiAgLy8gX3NvcnQgZGVmYXVsdCB0byB0cnVlIGJ1dCBvdGhlcndpc2UgY2FuIGJlIGEgZnVuY3Rpb24gb3IgYm9vbGVhblxuICB0aGlzLl9zb3J0ID0gdHlwZW9mIHNvcnQgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IHNvcnQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb21wb3NlIHF1ZXJ5c3RyaW5nIHRvIGFwcGVuZCB0byByZXEudXJsXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fZmluYWxpemVRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBxdWVyeSA9IHRoaXMuX3F1ZXJ5LmpvaW4oJyYnKTtcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgdGhpcy51cmwgKz0gKHRoaXMudXJsLmluZGV4T2YoJz8nKSA+PSAwID8gJyYnIDogJz8nKSArIHF1ZXJ5O1xuICB9XG4gIHRoaXMuX3F1ZXJ5Lmxlbmd0aCA9IDA7IC8vIE1ha2VzIHRoZSBjYWxsIGlkZW1wb3RlbnRcblxuICBpZiAodGhpcy5fc29ydCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMudXJsLmluZGV4T2YoJz8nKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIHF1ZXJ5QXJyID0gdGhpcy51cmwuc3Vic3RyaW5nKGluZGV4ICsgMSkuc3BsaXQoJyYnKTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdGhpcy5fc29ydCkge1xuICAgICAgICBxdWVyeUFyci5zb3J0KHRoaXMuX3NvcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnlBcnIuc29ydCgpO1xuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSB0aGlzLnVybC5zdWJzdHJpbmcoMCwgaW5kZXgpICsgJz8nICsgcXVlcnlBcnIuam9pbignJicpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRm9yIGJhY2t3YXJkcyBjb21wYXQgb25seVxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9hcHBlbmRRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKCkge2NvbnNvbGUudHJhY2UoXCJVbnN1cHBvcnRlZFwiKTt9XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIHdpdGggdGltZW91dCBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3RpbWVvdXRFcnJvciA9IGZ1bmN0aW9uKHJlYXNvbiwgdGltZW91dCwgZXJybm8pe1xuICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZXJyID0gbmV3IEVycm9yKHJlYXNvbiArIHRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnKTtcbiAgZXJyLnRpbWVvdXQgPSB0aW1lb3V0O1xuICBlcnIuY29kZSA9ICdFQ09OTkFCT1JURUQnO1xuICBlcnIuZXJybm8gPSBlcnJubztcbiAgdGhpcy50aW1lZG91dCA9IHRydWU7XG4gIHRoaXMuYWJvcnQoKTtcbiAgdGhpcy5jYWxsYmFjayhlcnIpO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9zZXRUaW1lb3V0cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gZGVhZGxpbmVcbiAgaWYgKHRoaXMuX3RpbWVvdXQgJiYgIXRoaXMuX3RpbWVyKSB7XG4gICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLl90aW1lb3V0RXJyb3IoJ1RpbWVvdXQgb2YgJywgc2VsZi5fdGltZW91dCwgJ0VUSU1FJyk7XG4gICAgfSwgdGhpcy5fdGltZW91dCk7XG4gIH1cbiAgLy8gcmVzcG9uc2UgdGltZW91dFxuICBpZiAodGhpcy5fcmVzcG9uc2VUaW1lb3V0ICYmICF0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcikge1xuICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgc2VsZi5fdGltZW91dEVycm9yKCdSZXNwb25zZSB0aW1lb3V0IG9mICcsIHNlbGYuX3Jlc3BvbnNlVGltZW91dCwgJ0VUSU1FRE9VVCcpO1xuICAgIH0sIHRoaXMuX3Jlc3BvbnNlVGltZW91dCk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogRXhwb3NlIGBSZXNwb25zZUJhc2VgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVzcG9uc2VCYXNlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlQmFzZWAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXNwb25zZUJhc2Uob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufVxuXG4vKipcbiAqIE1peGluIHRoZSBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIFJlc3BvbnNlQmFzZS5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IFJlc3BvbnNlQmFzZS5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGBmaWVsZGAgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlc3BvbnNlQmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIHRoaXMuaGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIHJlbGF0ZWQgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYC50eXBlYCB0aGUgY29udGVudCB0eXBlIHdpdGhvdXQgcGFyYW1zXG4gKlxuICogQSByZXNwb25zZSBvZiBcIkNvbnRlbnQtVHlwZTogdGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gKiB3aWxsIHByb3ZpZGUgeW91IHdpdGggYSBgLnR5cGVgIG9mIFwidGV4dC9wbGFpblwiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlQmFzZS5wcm90b3R5cGUuX3NldEhlYWRlclByb3BlcnRpZXMgPSBmdW5jdGlvbihoZWFkZXIpe1xuICAgIC8vIFRPRE86IG1vYXIhXG4gICAgLy8gVE9ETzogbWFrZSB0aGlzIGEgdXRpbFxuXG4gICAgLy8gY29udGVudC10eXBlXG4gICAgdmFyIGN0ID0gaGVhZGVyWydjb250ZW50LXR5cGUnXSB8fCAnJztcbiAgICB0aGlzLnR5cGUgPSB1dGlscy50eXBlKGN0KTtcblxuICAgIC8vIHBhcmFtc1xuICAgIHZhciBwYXJhbXMgPSB1dGlscy5wYXJhbXMoY3QpO1xuICAgIGZvciAodmFyIGtleSBpbiBwYXJhbXMpIHRoaXNba2V5XSA9IHBhcmFtc1trZXldO1xuXG4gICAgdGhpcy5saW5rcyA9IHt9O1xuXG4gICAgLy8gbGlua3NcbiAgICB0cnkge1xuICAgICAgICBpZiAoaGVhZGVyLmxpbmspIHtcbiAgICAgICAgICAgIHRoaXMubGlua3MgPSB1dGlscy5wYXJzZUxpbmtzKGhlYWRlci5saW5rKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCBmbGFncyBzdWNoIGFzIGAub2tgIGJhc2VkIG9uIGBzdGF0dXNgLlxuICpcbiAqIEZvciBleGFtcGxlIGEgMnh4IHJlc3BvbnNlIHdpbGwgZ2l2ZSB5b3UgYSBgLm9rYCBvZiBfX3RydWVfX1xuICogd2hlcmVhcyA1eHggd2lsbCBiZSBfX2ZhbHNlX18gYW5kIGAuZXJyb3JgIHdpbGwgYmUgX190cnVlX18uIFRoZVxuICogYC5jbGllbnRFcnJvcmAgYW5kIGAuc2VydmVyRXJyb3JgIGFyZSBhbHNvIGF2YWlsYWJsZSB0byBiZSBtb3JlXG4gKiBzcGVjaWZpYywgYW5kIGAuc3RhdHVzVHlwZWAgaXMgdGhlIGNsYXNzIG9mIGVycm9yIHJhbmdpbmcgZnJvbSAxLi41XG4gKiBzb21ldGltZXMgdXNlZnVsIGZvciBtYXBwaW5nIHJlc3BvbmQgY29sb3JzIGV0Yy5cbiAqXG4gKiBcInN1Z2FyXCIgcHJvcGVydGllcyBhcmUgYWxzbyBkZWZpbmVkIGZvciBjb21tb24gY2FzZXMuIEN1cnJlbnRseSBwcm92aWRpbmc6XG4gKlxuICogICAtIC5ub0NvbnRlbnRcbiAqICAgLSAuYmFkUmVxdWVzdFxuICogICAtIC51bmF1dGhvcml6ZWRcbiAqICAgLSAubm90QWNjZXB0YWJsZVxuICogICAtIC5ub3RGb3VuZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlQmFzZS5wcm90b3R5cGUuX3NldFN0YXR1c1Byb3BlcnRpZXMgPSBmdW5jdGlvbihzdGF0dXMpe1xuICAgIHZhciB0eXBlID0gc3RhdHVzIC8gMTAwIHwgMDtcblxuICAgIC8vIHN0YXR1cyAvIGNsYXNzXG4gICAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXM7XG4gICAgdGhpcy5zdGF0dXNUeXBlID0gdHlwZTtcblxuICAgIC8vIGJhc2ljc1xuICAgIHRoaXMuaW5mbyA9IDEgPT0gdHlwZTtcbiAgICB0aGlzLm9rID0gMiA9PSB0eXBlO1xuICAgIHRoaXMucmVkaXJlY3QgPSAzID09IHR5cGU7XG4gICAgdGhpcy5jbGllbnRFcnJvciA9IDQgPT0gdHlwZTtcbiAgICB0aGlzLnNlcnZlckVycm9yID0gNSA9PSB0eXBlO1xuICAgIHRoaXMuZXJyb3IgPSAoNCA9PSB0eXBlIHx8IDUgPT0gdHlwZSlcbiAgICAgICAgPyB0aGlzLnRvRXJyb3IoKVxuICAgICAgICA6IGZhbHNlO1xuXG4gICAgLy8gc3VnYXJcbiAgICB0aGlzLmNyZWF0ZWQgPSAyMDEgPT0gc3RhdHVzO1xuICAgIHRoaXMuYWNjZXB0ZWQgPSAyMDIgPT0gc3RhdHVzO1xuICAgIHRoaXMubm9Db250ZW50ID0gMjA0ID09IHN0YXR1cztcbiAgICB0aGlzLmJhZFJlcXVlc3QgPSA0MDAgPT0gc3RhdHVzO1xuICAgIHRoaXMudW5hdXRob3JpemVkID0gNDAxID09IHN0YXR1cztcbiAgICB0aGlzLm5vdEFjY2VwdGFibGUgPSA0MDYgPT0gc3RhdHVzO1xuICAgIHRoaXMuZm9yYmlkZGVuID0gNDAzID09IHN0YXR1cztcbiAgICB0aGlzLm5vdEZvdW5kID0gNDA0ID09IHN0YXR1cztcbiAgICB0aGlzLnVucHJvY2Vzc2FibGVFbnRpdHkgPSA0MjIgPT0gc3RhdHVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG1pbWUgdHlwZSBmb3IgdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIuc3BsaXQoLyAqOyAqLykuc2hpZnQoKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhlYWRlciBmaWVsZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucGFyYW1zID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvICo7ICovKS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBzdHIpe1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo9ICovKTtcbiAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKTtcbiAgICB2YXIgdmFsID0gcGFydHMuc2hpZnQoKTtcblxuICAgIGlmIChrZXkgJiYgdmFsKSBvYmpba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIExpbmsgaGVhZGVyIGZpZWxkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnBhcnNlTGlua3MgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnNwbGl0KC8gKiwgKi8pLnJlZHVjZShmdW5jdGlvbihvYmosIHN0cil7XG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KC8gKjsgKi8pO1xuICAgIHZhciB1cmwgPSBwYXJ0c1swXS5zbGljZSgxLCAtMSk7XG4gICAgdmFyIHJlbCA9IHBhcnRzWzFdLnNwbGl0KC8gKj0gKi8pWzFdLnNsaWNlKDEsIC0xKTtcbiAgICBvYmpbcmVsXSA9IHVybDtcbiAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG59O1xuXG4vKipcbiAqIFN0cmlwIGNvbnRlbnQgcmVsYXRlZCBmaWVsZHMgZnJvbSBgaGVhZGVyYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAcmV0dXJuIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5jbGVhbkhlYWRlciA9IGZ1bmN0aW9uKGhlYWRlciwgY2hhbmdlc09yaWdpbil7XG4gIGRlbGV0ZSBoZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICBkZWxldGUgaGVhZGVyWydjb250ZW50LWxlbmd0aCddO1xuICBkZWxldGUgaGVhZGVyWyd0cmFuc2Zlci1lbmNvZGluZyddO1xuICBkZWxldGUgaGVhZGVyWydob3N0J107XG4gIC8vIHNlY3VpcnR5XG4gIGlmIChjaGFuZ2VzT3JpZ2luKSB7XG4gICAgZGVsZXRlIGhlYWRlclsnYXV0aG9yaXphdGlvbiddO1xuICAgIGRlbGV0ZSBoZWFkZXJbJ2Nvb2tpZSddO1xuICB9XG4gIHJldHVybiBoZWFkZXI7XG59O1xuIiwidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iLCJleHBvcnQgZnVuY3Rpb24gbWVyZ2UoLi4uc2V0czpBcnJheTxzdHJpbmc+KTpzdHJpbmcge1xuXHRpZiAoc2V0cy5sZW5ndGggPiAxKSB7XG5cdFx0c2V0c1swXSA9IHNldHNbMF0uc2xpY2UoMCwgLTEpO1xuXHRcdGNvbnN0IHhsID0gc2V0cy5sZW5ndGggLSAxO1xuXHRcdGZvciAobGV0IHggPSAxOyB4IDwgeGw7ICsreCkge1xuXHRcdFx0c2V0c1t4XSA9IHNldHNbeF0uc2xpY2UoMSwgLTEpO1xuXHRcdH1cblx0XHRzZXRzW3hsXSA9IHNldHNbeGxdLnNsaWNlKDEpO1xuXHRcdHJldHVybiBzZXRzLmpvaW4oJycpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBzZXRzWzBdO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJleHAoc3RyOnN0cmluZyk6c3RyaW5nIHtcblx0cmV0dXJuIFwiKD86XCIgKyBzdHIgKyBcIilcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVPZihvOmFueSk6c3RyaW5nIHtcblx0cmV0dXJuIG8gPT09IHVuZGVmaW5lZCA/IFwidW5kZWZpbmVkXCIgOiAobyA9PT0gbnVsbCA/IFwibnVsbFwiIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNwbGl0KFwiIFwiKS5wb3AoKS5zcGxpdChcIl1cIikuc2hpZnQoKS50b0xvd2VyQ2FzZSgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvVXBwZXJDYXNlKHN0cjpzdHJpbmcpOnN0cmluZyB7XG5cdHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvQXJyYXkob2JqOmFueSk6QXJyYXk8YW55PiB7XG5cdHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGwgPyAob2JqIGluc3RhbmNlb2YgQXJyYXkgPyBvYmogOiAodHlwZW9mIG9iai5sZW5ndGggIT09IFwibnVtYmVyXCIgfHwgb2JqLnNwbGl0IHx8IG9iai5zZXRJbnRlcnZhbCB8fCBvYmouY2FsbCA/IFtvYmpdIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKSkpIDogW107XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQ6IG9iamVjdCwgc291cmNlOiBhbnkpOiBhbnkge1xuXHRjb25zdCBvYmogPSB0YXJnZXQgYXMgYW55O1xuXHRpZiAoc291cmNlKSB7XG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG5cdFx0XHRvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb2JqO1xufSIsImltcG9ydCB7IFVSSVJlZ0V4cHMgfSBmcm9tIFwiLi91cmlcIjtcbmltcG9ydCB7IG1lcmdlLCBzdWJleHAgfSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEV4cHMoaXNJUkk6Ym9vbGVhbik6VVJJUmVnRXhwcyB7XG5cdGNvbnN0XG5cdFx0QUxQSEEkJCA9IFwiW0EtWmEtel1cIixcblx0XHRDUiQgPSBcIltcXFxceDBEXVwiLFxuXHRcdERJR0lUJCQgPSBcIlswLTldXCIsXG5cdFx0RFFVT1RFJCQgPSBcIltcXFxceDIyXVwiLFxuXHRcdEhFWERJRyQkID0gbWVyZ2UoRElHSVQkJCwgXCJbQS1GYS1mXVwiKSwgIC8vY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdExGJCQgPSBcIltcXFxceDBBXVwiLFxuXHRcdFNQJCQgPSBcIltcXFxceDIwXVwiLFxuXHRcdFBDVF9FTkNPREVEJCA9IHN1YmV4cChzdWJleHAoXCIlW0VGZWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVbODlBLUZhLWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpKSwgIC8vZXhwYW5kZWRcblx0XHRHRU5fREVMSU1TJCQgPSBcIltcXFxcOlxcXFwvXFxcXD9cXFxcI1xcXFxbXFxcXF1cXFxcQF1cIixcblx0XHRTVUJfREVMSU1TJCQgPSBcIltcXFxcIVxcXFwkXFxcXCZcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw9XVwiLFxuXHRcdFJFU0VSVkVEJCQgPSBtZXJnZShHRU5fREVMSU1TJCQsIFNVQl9ERUxJTVMkJCksXG5cdFx0VUNTQ0hBUiQkID0gaXNJUkkgPyBcIltcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdXCIgOiBcIltdXCIsICAvL3N1YnNldCwgZXhjbHVkZXMgYmlkaSBjb250cm9sIGNoYXJhY3RlcnNcblx0XHRJUFJJVkFURSQkID0gaXNJUkkgPyBcIltcXFxcdUUwMDAtXFxcXHVGOEZGXVwiIDogXCJbXVwiLCAgLy9zdWJzZXRcblx0XHRVTlJFU0VSVkVEJCQgPSBtZXJnZShBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcLVxcXFwuXFxcXF9cXFxcfl1cIiwgVUNTQ0hBUiQkKSxcblx0XHRTQ0hFTUUkID0gc3ViZXhwKEFMUEhBJCQgKyBtZXJnZShBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcK1xcXFwtXFxcXC5dXCIpICsgXCIqXCIpLFxuXHRcdFVTRVJJTkZPJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpKSArIFwiKlwiKSxcblx0XHRERUNfT0NURVQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiWzEtOV1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBESUdJVCQkKSxcblx0XHRERUNfT0NURVRfUkVMQVhFRCQgPSBzdWJleHAoc3ViZXhwKFwiMjVbMC01XVwiKSArIFwifFwiICsgc3ViZXhwKFwiMlswLTRdXCIgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMVwiICsgRElHSVQkJCArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIwP1sxLTldXCIgKyBESUdJVCQkKSArIFwifDA/MD9cIiArIERJR0lUJCQpLCAgLy9yZWxheGVkIHBhcnNpbmcgcnVsZXNcblx0XHRJUFY0QUREUkVTUyQgPSBzdWJleHAoREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkKSxcblx0XHRIMTYkID0gc3ViZXhwKEhFWERJRyQkICsgXCJ7MSw0fVwiKSxcblx0XHRMUzMyJCA9IHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIiArIEgxNiQpICsgXCJ8XCIgKyBJUFY0QUREUkVTUyQpLFxuXHRcdElQVjZBRERSRVNTMSQgPSBzdWJleHAoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Nn1cIiArIExTMzIkKSwgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICA2KCBoMTYgXCI6XCIgKSBsczMyXG5cdFx0SVBWNkFERFJFU1MyJCA9IHN1YmV4cCggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns1fVwiICsgTFMzMiQpLCAvLyAgICAgICAgICAgICAgICAgICAgICBcIjo6XCIgNSggaDE2IFwiOlwiICkgbHMzMlxuXHRcdElQVjZBRERSRVNTMyQgPSBzdWJleHAoc3ViZXhwKCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7NH1cIiArIExTMzIkKSwgLy9bICAgICAgICAgICAgICAgaDE2IF0gXCI6OlwiIDQoIGgxNiBcIjpcIiApIGxzMzJcblx0XHRJUFY2QUREUkVTUzQkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDF9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezN9XCIgKyBMUzMyJCksIC8vWyAqMSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDMoIGgxNiBcIjpcIiApIGxzMzJcblx0XHRJUFY2QUREUkVTUzUkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDJ9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezJ9XCIgKyBMUzMyJCksIC8vWyAqMiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDIoIGgxNiBcIjpcIiApIGxzMzJcblx0XHRJUFY2QUREUkVTUzYkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDN9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArICAgICAgICBIMTYkICsgXCJcXFxcOlwiICAgICAgICAgICsgTFMzMiQpLCAvL1sgKjMoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICBoMTYgXCI6XCIgICBsczMyXG5cdFx0SVBWNkFERFJFU1M3JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCw0fVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgTFMzMiQpLCAvL1sgKjQoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgbHMzMlxuXHRcdElQVjZBRERSRVNTOCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIEgxNiQgKSwgLy9bICo1KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGgxNlxuXHRcdElQVjZBRERSRVNTOSQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNn1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSwgLy9bICo2KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCJcblx0XHRJUFY2QUREUkVTUyQgPSBzdWJleHAoW0lQVjZBRERSRVNTMSQsIElQVjZBRERSRVNTMiQsIElQVjZBRERSRVNTMyQsIElQVjZBRERSRVNTNCQsIElQVjZBRERSRVNTNSQsIElQVjZBRERSRVNTNiQsIElQVjZBRERSRVNTNyQsIElQVjZBRERSRVNTOCQsIElQVjZBRERSRVNTOSRdLmpvaW4oXCJ8XCIpKSxcblx0XHRaT05FSUQkID0gc3ViZXhwKHN1YmV4cChVTlJFU0VSVkVEJCQgKyBcInxcIiArIFBDVF9FTkNPREVEJCkgKyBcIitcIiksICAvL1JGQyA2ODc0XG5cdFx0SVBWNkFERFJaJCA9IHN1YmV4cChJUFY2QUREUkVTUyQgKyBcIlxcXFwlMjVcIiArIFpPTkVJRCQpLCAgLy9SRkMgNjg3NFxuXHRcdElQVjZBRERSWl9SRUxBWEVEJCA9IHN1YmV4cChJUFY2QUREUkVTUyQgKyBzdWJleHAoXCJcXFxcJTI1fFxcXFwlKD8hXCIgKyBIRVhESUckJCArIFwiezJ9KVwiKSArIFpPTkVJRCQpLCAgLy9SRkMgNjg3NCwgd2l0aCByZWxheGVkIHBhcnNpbmcgcnVsZXNcblx0XHRJUFZGVVRVUkUkID0gc3ViZXhwKFwiW3ZWXVwiICsgSEVYRElHJCQgKyBcIitcXFxcLlwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XVwiKSArIFwiK1wiKSxcblx0XHRJUF9MSVRFUkFMJCA9IHN1YmV4cChcIlxcXFxbXCIgKyBzdWJleHAoSVBWNkFERFJaX1JFTEFYRUQkICsgXCJ8XCIgKyBJUFY2QUREUkVTUyQgKyBcInxcIiArIElQVkZVVFVSRSQpICsgXCJcXFxcXVwiKSwgIC8vUkZDIDY4NzRcblx0XHRSRUdfTkFNRSQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpKSArIFwiKlwiKSxcblx0XHRIT1NUJCA9IHN1YmV4cChJUF9MSVRFUkFMJCArIFwifFwiICsgSVBWNEFERFJFU1MkICsgXCIoPyFcIiArIFJFR19OQU1FJCArIFwiKVwiICsgXCJ8XCIgKyBSRUdfTkFNRSQpLFxuXHRcdFBPUlQkID0gc3ViZXhwKERJR0lUJCQgKyBcIipcIiksXG5cdFx0QVVUSE9SSVRZJCA9IHN1YmV4cChzdWJleHAoVVNFUklORk8kICsgXCJAXCIpICsgXCI/XCIgKyBIT1NUJCArIHN1YmV4cChcIlxcXFw6XCIgKyBQT1JUJCkgKyBcIj9cIiksXG5cdFx0UENIQVIkID0gc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBdXCIpKSxcblx0XHRTRUdNRU5UJCA9IHN1YmV4cChQQ0hBUiQgKyBcIipcIiksXG5cdFx0U0VHTUVOVF9OWiQgPSBzdWJleHAoUENIQVIkICsgXCIrXCIpLFxuXHRcdFNFR01FTlRfTlpfTkMkID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcQF1cIikpICsgXCIrXCIpLFxuXHRcdFBBVEhfQUJFTVBUWSQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cIiArIFNFR01FTlQkKSArIFwiKlwiKSxcblx0XHRQQVRIX0FCU09MVVRFJCA9IHN1YmV4cChcIlxcXFwvXCIgKyBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSArIFwiP1wiKSwgIC8vc2ltcGxpZmllZFxuXHRcdFBBVEhfTk9TQ0hFTUUkID0gc3ViZXhwKFNFR01FTlRfTlpfTkMkICsgUEFUSF9BQkVNUFRZJCksICAvL3NpbXBsaWZpZWRcblx0XHRQQVRIX1JPT1RMRVNTJCA9IHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpLCAgLy9zaW1wbGlmaWVkXG5cdFx0UEFUSF9FTVBUWSQgPSBcIig/IVwiICsgUENIQVIkICsgXCIpXCIsXG5cdFx0UEFUSCQgPSBzdWJleHAoUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuXHRcdFFVRVJZJCA9IHN1YmV4cChzdWJleHAoUENIQVIkICsgXCJ8XCIgKyBtZXJnZShcIltcXFxcL1xcXFw/XVwiLCBJUFJJVkFURSQkKSkgKyBcIipcIiksXG5cdFx0RlJBR01FTlQkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxbXFxcXC9cXFxcP11cIikgKyBcIipcIiksXG5cdFx0SElFUl9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuXHRcdFVSSSQgPSBzdWJleHAoU0NIRU1FJCArIFwiXFxcXDpcIiArIEhJRVJfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCNcIiArIEZSQUdNRU5UJCkgKyBcIj9cIiksXG5cdFx0UkVMQVRJVkVfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcblx0XHRSRUxBVElWRSQgPSBzdWJleHAoUkVMQVRJVkVfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCNcIiArIEZSQUdNRU5UJCkgKyBcIj9cIiksXG5cdFx0VVJJX1JFRkVSRU5DRSQgPSBzdWJleHAoVVJJJCArIFwifFwiICsgUkVMQVRJVkUkKSxcblx0XHRBQlNPTFVURV9VUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiksXG5cblx0XHRHRU5FUklDX1JFRiQgPSBcIl4oXCIgKyBTQ0hFTUUkICsgXCIpXFxcXDpcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG5cdFx0UkVMQVRJVkVfUkVGJCA9IFwiXigpezB9XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuXHRcdEFCU09MVVRFX1JFRiQgPSBcIl4oXCIgKyBTQ0hFTUUkICsgXCIpXFxcXDpcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiPyRcIixcblx0XHRTQU1FRE9DX1JFRiQgPSBcIl5cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuXHRcdEFVVEhPUklUWV9SRUYkID0gXCJeXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8kXCJcblx0O1xuXG5cdHJldHVybiB7XG5cdFx0Tk9UX1NDSEVNRSA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXCtcXFxcLVxcXFwuXVwiKSwgXCJnXCIpLFxuXHRcdE5PVF9VU0VSSU5GTyA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXDpdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuXHRcdE5PVF9IT1NUIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcW1xcXFxdXFxcXDpdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuXHRcdE5PVF9QQVRIIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcL1xcXFw6XFxcXEBdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuXHRcdE5PVF9QQVRIX05PU0NIRU1FIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcL1xcXFxAXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcblx0XHROT1RfUVVFUlkgOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBcXFxcL1xcXFw/XVwiLCBJUFJJVkFURSQkKSwgXCJnXCIpLFxuXHRcdE5PVF9GUkFHTUVOVCA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQFxcXFwvXFxcXD9dXCIpLCBcImdcIiksXG5cdFx0RVNDQVBFIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcblx0XHRVTlJFU0VSVkVEIDogbmV3IFJlZ0V4cChVTlJFU0VSVkVEJCQsIFwiZ1wiKSxcblx0XHRPVEhFUl9DSEFSUyA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFJFU0VSVkVEJCQpLCBcImdcIiksXG5cdFx0UENUX0VOQ09ERUQgOiBuZXcgUmVnRXhwKFBDVF9FTkNPREVEJCwgXCJnXCIpLFxuXHRcdElQVjRBRERSRVNTIDogbmV3IFJlZ0V4cChcIl4oXCIgKyBJUFY0QUREUkVTUyQgKyBcIikkXCIpLFxuXHRcdElQVjZBRERSRVNTIDogbmV3IFJlZ0V4cChcIl5cXFxcWz8oXCIgKyBJUFY2QUREUkVTUyQgKyBcIilcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcJTI1fFxcXFwlKD8hXCIgKyBIRVhESUckJCArIFwiezJ9KVwiKSArIFwiKFwiICsgWk9ORUlEJCArIFwiKVwiKSArIFwiP1xcXFxdPyRcIikgIC8vUkZDIDY4NzQsIHdpdGggcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJ1aWxkRXhwcyhmYWxzZSk7XG4iLCJpbXBvcnQgeyBVUklSZWdFeHBzIH0gZnJvbSBcIi4vdXJpXCI7XG5pbXBvcnQgeyBidWlsZEV4cHMgfSBmcm9tIFwiLi9yZWdleHBzLXVyaVwiO1xuXG5leHBvcnQgZGVmYXVsdCBidWlsZEV4cHModHJ1ZSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cbmNvbnN0IG1heEludCA9IDIxNDc0ODM2NDc7IC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuY29uc3QgYmFzZSA9IDM2O1xuY29uc3QgdE1pbiA9IDE7XG5jb25zdCB0TWF4ID0gMjY7XG5jb25zdCBza2V3ID0gMzg7XG5jb25zdCBkYW1wID0gNzAwO1xuY29uc3QgaW5pdGlhbEJpYXMgPSA3MjtcbmNvbnN0IGluaXRpYWxOID0gMTI4OyAvLyAweDgwXG5jb25zdCBkZWxpbWl0ZXIgPSAnLSc7IC8vICdcXHgyRCdcblxuLyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cbmNvbnN0IHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vO1xuY29uc3QgcmVnZXhOb25BU0NJSSA9IC9bXlxcMC1cXHg3RV0vOyAvLyBub24tQVNDSUkgY2hhcnNcbmNvbnN0IHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2c7IC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuLyoqIEVycm9yIG1lc3NhZ2VzICovXG5jb25zdCBlcnJvcnMgPSB7XG5cdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG59O1xuXG4vKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5jb25zdCBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW47XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xufVxuXG4vKipcbiAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcbiAqIGl0ZW0uXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0Y29uc3QgcmVzdWx0ID0gW107XG5cdGxldCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcbiAqIGFkZHJlc3Nlcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG4gKiBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdGNvbnN0IHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdGxldCByZXN1bHQgPSAnJztcblx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0fVxuXHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdGNvbnN0IGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRjb25zdCBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBkZWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdGNvbnN0IG91dHB1dCA9IFtdO1xuXHRsZXQgY291bnRlciA9IDA7XG5cdGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG5cdFx0XHRjb25zdCBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gTG93IHN1cnJvZ2F0ZS5cblx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEl0J3MgYW4gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlXG5cdFx0XHRcdC8vIG5leHQgY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGVuY29kZVxuICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cbiAqL1xuY29uc3QgdWNzMmVuY29kZSA9IGFycmF5ID0+IFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmFycmF5KTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG4gKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cbiAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcbiAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuICovXG5jb25zdCBiYXNpY1RvRGlnaXQgPSBmdW5jdGlvbihjb2RlUG9pbnQpIHtcblx0aWYgKGNvZGVQb2ludCAtIDB4MzAgPCAweDBBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4MTY7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NDEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NDE7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NjEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NjE7XG5cdH1cblx0cmV0dXJuIGJhc2U7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2VcbiAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcbiAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG4gKi9cbmNvbnN0IGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uKGRpZ2l0LCBmbGFnKSB7XG5cdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xufTtcblxuLyoqXG4gKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGFkYXB0ID0gZnVuY3Rpb24oZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdGxldCBrID0gMDtcblx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0fVxuXHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcbiAqIHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqL1xuY29uc3QgZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0Ly8gRG9uJ3QgdXNlIFVDUy0yLlxuXHRjb25zdCBvdXRwdXQgPSBbXTtcblx0Y29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdGxldCBpID0gMDtcblx0bGV0IG4gPSBpbml0aWFsTjtcblx0bGV0IGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0bGV0IGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdGJhc2ljID0gMDtcblx0fVxuXG5cdGZvciAobGV0IGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHR9XG5cdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdH1cblxuXHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0Zm9yIChsZXQgaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdGxldCBvbGRpID0gaTtcblx0XHRmb3IgKGxldCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRjb25zdCB0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgb3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRpICU9IG91dDtcblxuXHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXQuXG5cdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdH1cblxuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4ub3V0cHV0KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcbiAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqL1xuY29uc3QgZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0Y29uc3Qgb3V0cHV0ID0gW107XG5cblx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gYW4gYXJyYXkgb2YgVW5pY29kZSBjb2RlIHBvaW50cy5cblx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHQvLyBDYWNoZSB0aGUgbGVuZ3RoLlxuXHRsZXQgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuXG5cdGxldCBuID0gaW5pdGlhbE47XG5cdGxldCBkZWx0YSA9IDA7XG5cdGxldCBiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cy5cblx0Zm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcblx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdH1cblx0fVxuXG5cdGxldCBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cdGxldCBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoO1xuXG5cdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgd2l0aCBhIGRlbGltaXRlciB1bmxlc3MgaXQncyBlbXB0eS5cblx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0fVxuXG5cdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdGxldCBtID0gbWF4SW50O1xuXHRcdGZvciAoY29uc3QgY3VycmVudFZhbHVlIG9mIGlucHV0KSB7XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvdy5cblx0XHRjb25zdCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdH1cblxuXHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0biA9IG07XG5cblx0XHRmb3IgKGNvbnN0IGN1cnJlbnRWYWx1ZSBvZiBpbnB1dCkge1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cblx0XHRcdFx0bGV0IHEgPSBkZWx0YTtcblx0XHRcdFx0Zm9yIChsZXQgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0Y29uc3QgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc3QgcU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdGNvbnN0IGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQrK2RlbHRhO1xuXHRcdCsrbjtcblxuXHR9XG5cdHJldHVybiBvdXRwdXQuam9pbignJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3NcbiAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cbiAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuICogY29udmVydGVkIHRvIFVuaWNvZGUuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cbiAqIGNvbnZlcnQgdG8gVW5pY29kZS5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuICogc3RyaW5nLlxuICovXG5jb25zdCB0b1VuaWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0OiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cbiAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG4gKiBBU0NJSS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcbiAqIFVuaWNvZGUgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICogZW1haWwgYWRkcmVzcy5cbiAqL1xuY29uc3QgdG9BU0NJSSA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0OiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cbmNvbnN0IHB1bnljb2RlID0ge1xuXHQvKipcblx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqL1xuXHQndmVyc2lvbic6ICcyLjEuMCcsXG5cdC8qKlxuXHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0J3VjczInOiB7XG5cdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0fSxcblx0J2RlY29kZSc6IGRlY29kZSxcblx0J2VuY29kZSc6IGVuY29kZSxcblx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBwdW55Y29kZTtcbiIsIi8qKlxuICogVVJJLmpzXG4gKlxuICogQGZpbGVvdmVydmlldyBBbiBSRkMgMzk4NiBjb21wbGlhbnQsIHNjaGVtZSBleHRlbmRhYmxlIFVSSSBwYXJzaW5nL3ZhbGlkYXRpbmcvcmVzb2x2aW5nIGxpYnJhcnkgZm9yIEphdmFTY3JpcHQuXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86Z2FyeS5jb3VydEBnbWFpbC5jb21cIj5HYXJ5IENvdXJ0PC9hPlxuICogQHNlZSBodHRwOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvdXJpLWpzXG4gKi9cblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMSBHYXJ5IENvdXJ0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZVxuICogcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2ZcbiAqICAgICAgIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdFxuICogICAgICAgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAqICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIEdBUlkgQ09VUlQgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEXG4gKiBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgR0FSWSBDT1VSVCBPUlxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1JcbiAqIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbiAqIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRlxuICogQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuICogVGhlIHZpZXdzIGFuZCBjb25jbHVzaW9ucyBjb250YWluZWQgaW4gdGhlIHNvZnR3YXJlIGFuZCBkb2N1bWVudGF0aW9uIGFyZSB0aG9zZSBvZiB0aGVcbiAqIGF1dGhvcnMgYW5kIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgcmVwcmVzZW50aW5nIG9mZmljaWFsIHBvbGljaWVzLCBlaXRoZXIgZXhwcmVzc2VkXG4gKiBvciBpbXBsaWVkLCBvZiBHYXJ5IENvdXJ0LlxuICovXG5cbmltcG9ydCBVUklfUFJPVE9DT0wgZnJvbSBcIi4vcmVnZXhwcy11cmlcIjtcbmltcG9ydCBJUklfUFJPVE9DT0wgZnJvbSBcIi4vcmVnZXhwcy1pcmlcIjtcbmltcG9ydCBwdW55Y29kZSBmcm9tIFwicHVueWNvZGVcIjtcbmltcG9ydCB7IHRvVXBwZXJDYXNlLCB0eXBlT2YsIGFzc2lnbiB9IGZyb20gXCIuL3V0aWxcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVUklDb21wb25lbnRzIHtcblx0c2NoZW1lPzpzdHJpbmc7XG5cdHVzZXJpbmZvPzpzdHJpbmc7XG5cdGhvc3Q/OnN0cmluZztcblx0cG9ydD86bnVtYmVyfHN0cmluZztcblx0cGF0aD86c3RyaW5nO1xuXHRxdWVyeT86c3RyaW5nO1xuXHRmcmFnbWVudD86c3RyaW5nO1xuXHRyZWZlcmVuY2U/OnN0cmluZztcblx0ZXJyb3I/OnN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVUklPcHRpb25zIHtcblx0c2NoZW1lPzpzdHJpbmc7XG5cdHJlZmVyZW5jZT86c3RyaW5nO1xuXHR0b2xlcmFudD86Ym9vbGVhbjtcblx0YWJzb2x1dGVQYXRoPzpib29sZWFuO1xuXHRpcmk/OmJvb2xlYW47XG5cdHVuaWNvZGVTdXBwb3J0Pzpib29sZWFuO1xuXHRkb21haW5Ib3N0Pzpib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVSSVNjaGVtZUhhbmRsZXI8Q29tcG9uZW50cyBleHRlbmRzIFVSSUNvbXBvbmVudHMgPSBVUklDb21wb25lbnRzLCBPcHRpb25zIGV4dGVuZHMgVVJJT3B0aW9ucyA9IFVSSU9wdGlvbnMsIFBhcmVudENvbXBvbmVudHMgZXh0ZW5kcyBVUklDb21wb25lbnRzID0gVVJJQ29tcG9uZW50cz4ge1xuXHRzY2hlbWU6c3RyaW5nO1xuXHRwYXJzZShjb21wb25lbnRzOlBhcmVudENvbXBvbmVudHMsIG9wdGlvbnM6T3B0aW9ucyk6Q29tcG9uZW50cztcblx0c2VyaWFsaXplKGNvbXBvbmVudHM6Q29tcG9uZW50cywgb3B0aW9uczpPcHRpb25zKTpQYXJlbnRDb21wb25lbnRzO1xuXHR1bmljb2RlU3VwcG9ydD86Ym9vbGVhbjtcblx0ZG9tYWluSG9zdD86Ym9vbGVhbjtcblx0YWJzb2x1dGVQYXRoPzpib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVSSVJlZ0V4cHMge1xuXHROT1RfU0NIRU1FIDogUmVnRXhwLFxuXHROT1RfVVNFUklORk8gOiBSZWdFeHAsXG5cdE5PVF9IT1NUIDogUmVnRXhwLFxuXHROT1RfUEFUSCA6IFJlZ0V4cCxcblx0Tk9UX1BBVEhfTk9TQ0hFTUUgOiBSZWdFeHAsXG5cdE5PVF9RVUVSWSA6IFJlZ0V4cCxcblx0Tk9UX0ZSQUdNRU5UIDogUmVnRXhwLFxuXHRFU0NBUEUgOiBSZWdFeHAsXG5cdFVOUkVTRVJWRUQgOiBSZWdFeHAsXG5cdE9USEVSX0NIQVJTIDogUmVnRXhwLFxuXHRQQ1RfRU5DT0RFRCA6IFJlZ0V4cCxcblx0SVBWNEFERFJFU1MgOiBSZWdFeHAsXG5cdElQVjZBRERSRVNTIDogUmVnRXhwLFxufVxuXG5leHBvcnQgY29uc3QgU0NIRU1FUzp7W3NjaGVtZTpzdHJpbmddOlVSSVNjaGVtZUhhbmRsZXJ9ID0ge307XG5cbmV4cG9ydCBmdW5jdGlvbiBwY3RFbmNDaGFyKGNocjpzdHJpbmcpOnN0cmluZyB7XG5cdGNvbnN0IGMgPSBjaHIuY2hhckNvZGVBdCgwKTtcblx0bGV0IGU6c3RyaW5nO1xuXG5cdGlmIChjIDwgMTYpIGUgPSBcIiUwXCIgKyBjLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRlbHNlIGlmIChjIDwgMTI4KSBlID0gXCIlXCIgKyBjLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRlbHNlIGlmIChjIDwgMjA0OCkgZSA9IFwiJVwiICsgKChjID4+IDYpIHwgMTkyKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKChjICYgNjMpIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0ZWxzZSBlID0gXCIlXCIgKyAoKGMgPj4gMTIpIHwgMjI0KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKCgoYyA+PiA2KSAmIDYzKSB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArICgoYyAmIDYzKSB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cblx0cmV0dXJuIGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwY3REZWNDaGFycyhzdHI6c3RyaW5nKTpzdHJpbmcge1xuXHRsZXQgbmV3U3RyID0gXCJcIjtcblx0bGV0IGkgPSAwO1xuXHRjb25zdCBpbCA9IHN0ci5sZW5ndGg7XG5cblx0d2hpbGUgKGkgPCBpbCkge1xuXHRcdGNvbnN0IGMgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyAxLCAyKSwgMTYpO1xuXG5cdFx0aWYgKGMgPCAxMjgpIHtcblx0XHRcdG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuXHRcdFx0aSArPSAzO1xuXHRcdH1cblx0XHRlbHNlIGlmIChjID49IDE5NCAmJiBjIDwgMjI0KSB7XG5cdFx0XHRpZiAoKGlsIC0gaSkgPj0gNikge1xuXHRcdFx0XHRjb25zdCBjMiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDQsIDIpLCAxNik7XG5cdFx0XHRcdG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDMxKSA8PCA2KSB8IChjMiAmIDYzKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCA2KTtcblx0XHRcdH1cblx0XHRcdGkgKz0gNjtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoYyA+PSAyMjQpIHtcblx0XHRcdGlmICgoaWwgLSBpKSA+PSA5KSB7XG5cdFx0XHRcdGNvbnN0IGMyID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNCwgMiksIDE2KTtcblx0XHRcdFx0Y29uc3QgYzMgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA3LCAyKSwgMTYpO1xuXHRcdFx0XHRuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAxNSkgPDwgMTIpIHwgKChjMiAmIDYzKSA8PCA2KSB8IChjMyAmIDYzKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCA5KTtcblx0XHRcdH1cblx0XHRcdGkgKz0gOTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCAzKTtcblx0XHRcdGkgKz0gMztcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3U3RyO1xufVxuXG5mdW5jdGlvbiBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50czpVUklDb21wb25lbnRzLCBwcm90b2NvbDpVUklSZWdFeHBzKSB7XG5cdGZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyOnN0cmluZyk6c3RyaW5nIHtcblx0XHRjb25zdCBkZWNTdHIgPSBwY3REZWNDaGFycyhzdHIpO1xuXHRcdHJldHVybiAoIWRlY1N0ci5tYXRjaChwcm90b2NvbC5VTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cik7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50cy5zY2hlbWUpIGNvbXBvbmVudHMuc2NoZW1lID0gU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1NDSEVNRSwgXCJcIik7XG5cdGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMudXNlcmluZm8gPSBTdHJpbmcoY29tcG9uZW50cy51c2VyaW5mbykucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfVVNFUklORk8sIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcblx0aWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLmhvc3QgPSBTdHJpbmcoY29tcG9uZW50cy5ob3N0KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UocHJvdG9jb2wuTk9UX0hPU1QsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcblx0aWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnBhdGggPSBTdHJpbmcoY29tcG9uZW50cy5wYXRoKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKChjb21wb25lbnRzLnNjaGVtZSA/IHByb3RvY29sLk5PVF9QQVRIIDogcHJvdG9jb2wuTk9UX1BBVEhfTk9TQ0hFTUUpLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG5cdGlmIChjb21wb25lbnRzLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMucXVlcnkgPSBTdHJpbmcoY29tcG9uZW50cy5xdWVyeSkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfUVVFUlksIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcblx0aWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5mcmFnbWVudCA9IFN0cmluZyhjb21wb25lbnRzLmZyYWdtZW50KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9GUkFHTUVOVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuXG5cdHJldHVybiBjb21wb25lbnRzO1xufTtcblxuZnVuY3Rpb24gX3N0cmlwTGVhZGluZ1plcm9zKHN0cjpzdHJpbmcpOnN0cmluZyB7XG5cdHJldHVybiBzdHIucmVwbGFjZSgvXjAqKC4qKS8sIFwiJDFcIikgfHwgXCIwXCI7XG59XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVJUHY0KGhvc3Q6c3RyaW5nLCBwcm90b2NvbDpVUklSZWdFeHBzKTpzdHJpbmcge1xuXHRjb25zdCBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY0QUREUkVTUykgfHwgW107XG5cdGNvbnN0IFssIGFkZHJlc3NdID0gbWF0Y2hlcztcblx0XG5cdGlmIChhZGRyZXNzKSB7XG5cdFx0cmV0dXJuIGFkZHJlc3Muc3BsaXQoXCIuXCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpLmpvaW4oXCIuXCIpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBob3N0O1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVJUHY2KGhvc3Q6c3RyaW5nLCBwcm90b2NvbDpVUklSZWdFeHBzKTpzdHJpbmcge1xuXHRjb25zdCBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY2QUREUkVTUykgfHwgW107XG5cdGNvbnN0IFssIGFkZHJlc3MsIHpvbmVdID0gbWF0Y2hlcztcblxuXHRpZiAoYWRkcmVzcykge1xuXHRcdGNvbnN0IFtsYXN0LCBmaXJzdF0gPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkuc3BsaXQoJzo6JykucmV2ZXJzZSgpO1xuXHRcdGNvbnN0IGZpcnN0RmllbGRzID0gZmlyc3QgPyBmaXJzdC5zcGxpdChcIjpcIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcykgOiBbXTtcblx0XHRjb25zdCBsYXN0RmllbGRzID0gbGFzdC5zcGxpdChcIjpcIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcyk7XG5cdFx0Y29uc3QgaXNMYXN0RmllbGRJUHY0QWRkcmVzcyA9IHByb3RvY29sLklQVjRBRERSRVNTLnRlc3QobGFzdEZpZWxkc1tsYXN0RmllbGRzLmxlbmd0aCAtIDFdKTtcblx0XHRjb25zdCBmaWVsZENvdW50ID0gaXNMYXN0RmllbGRJUHY0QWRkcmVzcyA/IDcgOiA4O1xuXHRcdGNvbnN0IGxhc3RGaWVsZHNTdGFydCA9IGxhc3RGaWVsZHMubGVuZ3RoIC0gZmllbGRDb3VudDtcblx0XHRjb25zdCBmaWVsZHMgPSBBcnJheTxzdHJpbmc+KGZpZWxkQ291bnQpO1xuXG5cdFx0Zm9yIChsZXQgeCA9IDA7IHggPCBmaWVsZENvdW50OyArK3gpIHtcblx0XHRcdGZpZWxkc1t4XSA9IGZpcnN0RmllbGRzW3hdIHx8IGxhc3RGaWVsZHNbbGFzdEZpZWxkc1N0YXJ0ICsgeF0gfHwgJyc7XG5cdFx0fVxuXG5cdFx0aWYgKGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MpIHtcblx0XHRcdGZpZWxkc1tmaWVsZENvdW50IC0gMV0gPSBfbm9ybWFsaXplSVB2NChmaWVsZHNbZmllbGRDb3VudCAtIDFdLCBwcm90b2NvbCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgYWxsWmVyb0ZpZWxkcyA9IGZpZWxkcy5yZWR1Y2U8QXJyYXk8e2luZGV4Om51bWJlcixsZW5ndGg6bnVtYmVyfT4+KChhY2MsIGZpZWxkLCBpbmRleCkgPT4ge1xuXHRcdFx0aWYgKCFmaWVsZCB8fCBmaWVsZCA9PT0gXCIwXCIpIHtcblx0XHRcdFx0Y29uc3QgbGFzdExvbmdlc3QgPSBhY2NbYWNjLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRpZiAobGFzdExvbmdlc3QgJiYgbGFzdExvbmdlc3QuaW5kZXggKyBsYXN0TG9uZ2VzdC5sZW5ndGggPT09IGluZGV4KSB7XG5cdFx0XHRcdFx0bGFzdExvbmdlc3QubGVuZ3RoKys7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YWNjLnB1c2goeyBpbmRleCwgbGVuZ3RoIDogMSB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFjYztcblx0XHR9LCBbXSk7XG5cblx0XHRjb25zdCBsb25nZXN0WmVyb0ZpZWxkcyA9IGFsbFplcm9GaWVsZHMuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aClbMF07XG5cblx0XHRsZXQgbmV3SG9zdDpzdHJpbmc7XG5cdFx0aWYgKGxvbmdlc3RaZXJvRmllbGRzICYmIGxvbmdlc3RaZXJvRmllbGRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGNvbnN0IG5ld0ZpcnN0ID0gZmllbGRzLnNsaWNlKDAsIGxvbmdlc3RaZXJvRmllbGRzLmluZGV4KSA7XG5cdFx0XHRjb25zdCBuZXdMYXN0ID0gZmllbGRzLnNsaWNlKGxvbmdlc3RaZXJvRmllbGRzLmluZGV4ICsgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoKTtcblx0XHRcdG5ld0hvc3QgPSBuZXdGaXJzdC5qb2luKFwiOlwiKSArIFwiOjpcIiArIG5ld0xhc3Quam9pbihcIjpcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld0hvc3QgPSBmaWVsZHMuam9pbihcIjpcIik7XG5cdFx0fVxuXG5cdFx0aWYgKHpvbmUpIHtcblx0XHRcdG5ld0hvc3QgKz0gXCIlXCIgKyB6b25lO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXdIb3N0O1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBob3N0O1xuXHR9XG59XG5cbmNvbnN0IFVSSV9QQVJTRSA9IC9eKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKCg/OihbXlxcLz8jQF0qKUApPyhcXFtbXlxcLz8jXFxdXStcXF18W15cXC8/IzpdKikoPzpcXDooXFxkKikpPykpPyhbXj8jXSopKD86XFw/KFteI10qKSk/KD86IygoPzoufFxcbnxcXHIpKikpPy9pO1xuY29uc3QgTk9fTUFUQ0hfSVNfVU5ERUZJTkVEID0gKDxSZWdFeHBNYXRjaEFycmF5PihcIlwiKS5tYXRjaCgvKCl7MH0vKSlbMV0gPT09IHVuZGVmaW5lZDtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHVyaVN0cmluZzpzdHJpbmcsIG9wdGlvbnM6VVJJT3B0aW9ucyA9IHt9KTpVUklDb21wb25lbnRzIHtcblx0Y29uc3QgY29tcG9uZW50czpVUklDb21wb25lbnRzID0ge307XG5cdGNvbnN0IHByb3RvY29sID0gKG9wdGlvbnMuaXJpICE9PSBmYWxzZSA/IElSSV9QUk9UT0NPTCA6IFVSSV9QUk9UT0NPTCk7XG5cblx0aWYgKG9wdGlvbnMucmVmZXJlbmNlID09PSBcInN1ZmZpeFwiKSB1cmlTdHJpbmcgPSAob3B0aW9ucy5zY2hlbWUgPyBvcHRpb25zLnNjaGVtZSArIFwiOlwiIDogXCJcIikgKyBcIi8vXCIgKyB1cmlTdHJpbmc7XG5cblx0Y29uc3QgbWF0Y2hlcyA9IHVyaVN0cmluZy5tYXRjaChVUklfUEFSU0UpO1xuXG5cdGlmIChtYXRjaGVzKSB7XG5cdFx0aWYgKE5PX01BVENIX0lTX1VOREVGSU5FRCkge1xuXHRcdFx0Ly9zdG9yZSBlYWNoIGNvbXBvbmVudFxuXHRcdFx0Y29tcG9uZW50cy5zY2hlbWUgPSBtYXRjaGVzWzFdO1xuXHRcdFx0Y29tcG9uZW50cy51c2VyaW5mbyA9IG1hdGNoZXNbM107XG5cdFx0XHRjb21wb25lbnRzLmhvc3QgPSBtYXRjaGVzWzRdO1xuXHRcdFx0Y29tcG9uZW50cy5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuXHRcdFx0Y29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1s2XSB8fCBcIlwiO1xuXHRcdFx0Y29tcG9uZW50cy5xdWVyeSA9IG1hdGNoZXNbN107XG5cdFx0XHRjb21wb25lbnRzLmZyYWdtZW50ID0gbWF0Y2hlc1s4XTtcblxuXHRcdFx0Ly9maXggcG9ydCBudW1iZXJcblx0XHRcdGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG5cdFx0XHRcdGNvbXBvbmVudHMucG9ydCA9IG1hdGNoZXNbNV07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHsgIC8vSUUgRklYIGZvciBpbXByb3BlciBSZWdFeHAgbWF0Y2hpbmdcblx0XHRcdC8vc3RvcmUgZWFjaCBjb21wb25lbnRcblx0XHRcdGNvbXBvbmVudHMuc2NoZW1lID0gbWF0Y2hlc1sxXSB8fCB1bmRlZmluZWQ7XG5cdFx0XHRjb21wb25lbnRzLnVzZXJpbmZvID0gKHVyaVN0cmluZy5pbmRleE9mKFwiQFwiKSAhPT0gLTEgPyBtYXRjaGVzWzNdIDogdW5kZWZpbmVkKTtcblx0XHRcdGNvbXBvbmVudHMuaG9zdCA9ICh1cmlTdHJpbmcuaW5kZXhPZihcIi8vXCIpICE9PSAtMSA/IG1hdGNoZXNbNF0gOiB1bmRlZmluZWQpO1xuXHRcdFx0Y29tcG9uZW50cy5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuXHRcdFx0Y29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1s2XSB8fCBcIlwiO1xuXHRcdFx0Y29tcG9uZW50cy5xdWVyeSA9ICh1cmlTdHJpbmcuaW5kZXhPZihcIj9cIikgIT09IC0xID8gbWF0Y2hlc1s3XSA6IHVuZGVmaW5lZCk7XG5cdFx0XHRjb21wb25lbnRzLmZyYWdtZW50ID0gKHVyaVN0cmluZy5pbmRleE9mKFwiI1wiKSAhPT0gLTEgPyBtYXRjaGVzWzhdIDogdW5kZWZpbmVkKTtcblxuXHRcdFx0Ly9maXggcG9ydCBudW1iZXJcblx0XHRcdGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG5cdFx0XHRcdGNvbXBvbmVudHMucG9ydCA9ICh1cmlTdHJpbmcubWF0Y2goL1xcL1xcLyg/Oi58XFxuKSpcXDooPzpcXC98XFw/fFxcI3wkKS8pID8gbWF0Y2hlc1s0XSA6IHVuZGVmaW5lZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNvbXBvbmVudHMuaG9zdCkge1xuXHRcdFx0Ly9ub3JtYWxpemUgSVAgaG9zdHNcblx0XHRcdGNvbXBvbmVudHMuaG9zdCA9IF9ub3JtYWxpemVJUHY2KF9ub3JtYWxpemVJUHY0KGNvbXBvbmVudHMuaG9zdCwgcHJvdG9jb2wpLCBwcm90b2NvbCk7XG5cdFx0fVxuXG5cdFx0Ly9kZXRlcm1pbmUgcmVmZXJlbmNlIHR5cGVcblx0XHRpZiAoY29tcG9uZW50cy5zY2hlbWUgPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLnVzZXJpbmZvID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5ob3N0ID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5wb3J0ID09PSB1bmRlZmluZWQgJiYgIWNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJzYW1lLWRvY3VtZW50XCI7XG5cdFx0fSBlbHNlIGlmIChjb21wb25lbnRzLnNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwicmVsYXRpdmVcIjtcblx0XHR9IGVsc2UgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29tcG9uZW50cy5yZWZlcmVuY2UgPSBcImFic29sdXRlXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJ1cmlcIjtcblx0XHR9XG5cblx0XHQvL2NoZWNrIGZvciByZWZlcmVuY2UgZXJyb3JzXG5cdFx0aWYgKG9wdGlvbnMucmVmZXJlbmNlICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBjb21wb25lbnRzLnJlZmVyZW5jZSkge1xuXHRcdFx0Y29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgaXMgbm90IGEgXCIgKyBvcHRpb25zLnJlZmVyZW5jZSArIFwiIHJlZmVyZW5jZS5cIjtcblx0XHR9XG5cblx0XHQvL2ZpbmQgc2NoZW1lIGhhbmRsZXJcblx0XHRjb25zdCBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG5cblx0XHQvL2NoZWNrIGlmIHNjaGVtZSBjYW4ndCBoYW5kbGUgSVJJc1xuXHRcdGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIudW5pY29kZVN1cHBvcnQpKSB7XG5cdFx0XHQvL2lmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcblx0XHRcdGlmIChjb21wb25lbnRzLmhvc3QgJiYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSkge1xuXHRcdFx0XHQvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50cy5ob3N0ID0gcHVueWNvZGUudG9BU0NJSShjb21wb25lbnRzLmhvc3QucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpLnRvTG93ZXJDYXNlKCkpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUkgdmlhIHB1bnljb2RlOiBcIiArIGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vY29udmVydCBJUkkgLT4gVVJJXG5cdFx0XHRfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgVVJJX1BST1RPQ09MKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly9ub3JtYWxpemUgZW5jb2RpbmdzXG5cdFx0XHRfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpO1xuXHRcdH1cblxuXHRcdC8vcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgcGFyc2luZ1xuXHRcdGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIucGFyc2UpIHtcblx0XHRcdHNjaGVtZUhhbmRsZXIucGFyc2UoY29tcG9uZW50cywgb3B0aW9ucyk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiVVJJIGNhbiBub3QgYmUgcGFyc2VkLlwiO1xuXHR9XG5cblx0cmV0dXJuIGNvbXBvbmVudHM7XG59O1xuXG5mdW5jdGlvbiBfcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpzdHJpbmd8dW5kZWZpbmVkIHtcblx0Y29uc3QgcHJvdG9jb2wgPSAob3B0aW9ucy5pcmkgIT09IGZhbHNlID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MKTtcblx0Y29uc3QgdXJpVG9rZW5zOkFycmF5PHN0cmluZz4gPSBbXTtcblxuXHRpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0dXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy51c2VyaW5mbyk7XG5cdFx0dXJpVG9rZW5zLnB1c2goXCJAXCIpO1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly9ub3JtYWxpemUgSVAgaG9zdHMsIGFkZCBicmFja2V0cyBhbmQgZXNjYXBlIHpvbmUgc2VwYXJhdG9yIGZvciBJUHY2XG5cdFx0dXJpVG9rZW5zLnB1c2goX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoU3RyaW5nKGNvbXBvbmVudHMuaG9zdCksIHByb3RvY29sKSwgcHJvdG9jb2wpLnJlcGxhY2UocHJvdG9jb2wuSVBWNkFERFJFU1MsIChfLCAkMSwgJDIpID0+IFwiW1wiICsgJDEgKyAoJDIgPyBcIiUyNVwiICsgJDIgOiBcIlwiKSArIFwiXVwiKSk7XG5cdH1cblxuXHRpZiAodHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gXCJudW1iZXJcIikge1xuXHRcdHVyaVRva2Vucy5wdXNoKFwiOlwiKTtcblx0XHR1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnBvcnQudG9TdHJpbmcoMTApKTtcblx0fVxuXG5cdHJldHVybiB1cmlUb2tlbnMubGVuZ3RoID8gdXJpVG9rZW5zLmpvaW4oXCJcIikgOiB1bmRlZmluZWQ7XG59O1xuXG5jb25zdCBSRFMxID0gL15cXC5cXC4/XFwvLztcbmNvbnN0IFJEUzIgPSAvXlxcL1xcLihcXC98JCkvO1xuY29uc3QgUkRTMyA9IC9eXFwvXFwuXFwuKFxcL3wkKS87XG5jb25zdCBSRFM0ID0gL15cXC5cXC4/JC87XG5jb25zdCBSRFM1ID0gL15cXC8/KD86LnxcXG4pKj8oPz1cXC98JCkvO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRG90U2VnbWVudHMoaW5wdXQ6c3RyaW5nKTpzdHJpbmcge1xuXHRjb25zdCBvdXRwdXQ6QXJyYXk8c3RyaW5nPiA9IFtdO1xuXG5cdHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcblx0XHRpZiAoaW5wdXQubWF0Y2goUkRTMSkpIHtcblx0XHRcdGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMxLCBcIlwiKTtcblx0XHR9IGVsc2UgaWYgKGlucHV0Lm1hdGNoKFJEUzIpKSB7XG5cdFx0XHRpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMiwgXCIvXCIpO1xuXHRcdH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMykpIHtcblx0XHRcdGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMzLCBcIi9cIik7XG5cdFx0XHRvdXRwdXQucG9wKCk7XG5cdFx0fSBlbHNlIGlmIChpbnB1dCA9PT0gXCIuXCIgfHwgaW5wdXQgPT09IFwiLi5cIikge1xuXHRcdFx0aW5wdXQgPSBcIlwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBpbSA9IGlucHV0Lm1hdGNoKFJEUzUpO1xuXHRcdFx0aWYgKGltKSB7XG5cdFx0XHRcdGNvbnN0IHMgPSBpbVswXTtcblx0XHRcdFx0aW5wdXQgPSBpbnB1dC5zbGljZShzLmxlbmd0aCk7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBkb3Qgc2VnbWVudCBjb25kaXRpb25cIik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG91dHB1dC5qb2luKFwiXCIpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShjb21wb25lbnRzOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyA9IHt9KTpzdHJpbmcge1xuXHRjb25zdCBwcm90b2NvbCA9IChvcHRpb25zLmlyaSA/IElSSV9QUk9UT0NPTCA6IFVSSV9QUk9UT0NPTCk7XG5cdGNvbnN0IHVyaVRva2VuczpBcnJheTxzdHJpbmc+ID0gW107XG5cblx0Ly9maW5kIHNjaGVtZSBoYW5kbGVyXG5cdGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnRzLnNjaGVtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpXTtcblxuXHQvL3BlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHNlcmlhbGl6YXRpb25cblx0aWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUpIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuXG5cdGlmIChjb21wb25lbnRzLmhvc3QpIHtcblx0XHQvL2lmIGhvc3QgY29tcG9uZW50IGlzIGFuIElQdjYgYWRkcmVzc1xuXHRcdGlmIChwcm90b2NvbC5JUFY2QUREUkVTUy50ZXN0KGNvbXBvbmVudHMuaG9zdCkpIHtcblx0XHRcdC8vVE9ETzogbm9ybWFsaXplIElQdjYgYWRkcmVzcyBhcyBwZXIgUkZDIDU5NTJcblx0XHR9XG5cblx0XHQvL2lmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcblx0XHRlbHNlIGlmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSkge1xuXHRcdFx0Ly9jb252ZXJ0IElETiB2aWEgcHVueWNvZGVcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBvbmVudHMuaG9zdCA9ICghb3B0aW9ucy5pcmkgPyBwdW55Y29kZS50b0FTQ0lJKGNvbXBvbmVudHMuaG9zdC5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBwY3REZWNDaGFycykudG9Mb3dlckNhc2UoKSkgOiBwdW55Y29kZS50b1VuaWNvZGUoY29tcG9uZW50cy5ob3N0KSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIFwiICsgKCFvcHRpb25zLmlyaSA/IFwiQVNDSUlcIiA6IFwiVW5pY29kZVwiKSArIFwiIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vbm9ybWFsaXplIGVuY29kaW5nXG5cdF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCk7XG5cblx0aWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiICYmIGNvbXBvbmVudHMuc2NoZW1lKSB7XG5cdFx0dXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5zY2hlbWUpO1xuXHRcdHVyaVRva2Vucy5wdXNoKFwiOlwiKTtcblx0fVxuXG5cdGNvbnN0IGF1dGhvcml0eSA9IF9yZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50cywgb3B0aW9ucyk7XG5cdGlmIChhdXRob3JpdHkgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIikge1xuXHRcdFx0dXJpVG9rZW5zLnB1c2goXCIvL1wiKTtcblx0XHR9XG5cblx0XHR1cmlUb2tlbnMucHVzaChhdXRob3JpdHkpO1xuXG5cdFx0aWYgKGNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnBhdGguY2hhckF0KDApICE9PSBcIi9cIikge1xuXHRcdFx0dXJpVG9rZW5zLnB1c2goXCIvXCIpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkge1xuXHRcdGxldCBzID0gY29tcG9uZW50cy5wYXRoO1xuXG5cdFx0aWYgKCFvcHRpb25zLmFic29sdXRlUGF0aCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIuYWJzb2x1dGVQYXRoKSkge1xuXHRcdFx0cyA9IHJlbW92ZURvdFNlZ21lbnRzKHMpO1xuXHRcdH1cblxuXHRcdGlmIChhdXRob3JpdHkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cyA9IHMucmVwbGFjZSgvXlxcL1xcLy8sIFwiLyUyRlwiKTsgIC8vZG9uJ3QgYWxsb3cgdGhlIHBhdGggdG8gc3RhcnQgd2l0aCBcIi8vXCJcblx0XHR9XG5cblx0XHR1cmlUb2tlbnMucHVzaChzKTtcblx0fVxuXG5cdGlmIChjb21wb25lbnRzLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcblx0XHR1cmlUb2tlbnMucHVzaChcIj9cIik7XG5cdFx0dXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5xdWVyeSk7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0dXJpVG9rZW5zLnB1c2goXCIjXCIpO1xuXHRcdHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuZnJhZ21lbnQpO1xuXHR9XG5cblx0cmV0dXJuIHVyaVRva2Vucy5qb2luKFwiXCIpOyAgLy9tZXJnZSB0b2tlbnMgaW50byBhIHN0cmluZ1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRzKGJhc2U6VVJJQ29tcG9uZW50cywgcmVsYXRpdmU6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zID0ge30sIHNraXBOb3JtYWxpemF0aW9uPzpib29sZWFuKTpVUklDb21wb25lbnRzIHtcblx0Y29uc3QgdGFyZ2V0OlVSSUNvbXBvbmVudHMgPSB7fTtcblxuXHRpZiAoIXNraXBOb3JtYWxpemF0aW9uKSB7XG5cdFx0YmFzZSA9IHBhcnNlKHNlcmlhbGl6ZShiYXNlLCBvcHRpb25zKSwgb3B0aW9ucyk7ICAvL25vcm1hbGl6ZSBiYXNlIGNvbXBvbmVudHNcblx0XHRyZWxhdGl2ZSA9IHBhcnNlKHNlcmlhbGl6ZShyZWxhdGl2ZSwgb3B0aW9ucyksIG9wdGlvbnMpOyAgLy9ub3JtYWxpemUgcmVsYXRpdmUgY29tcG9uZW50c1xuXHR9XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdGlmICghb3B0aW9ucy50b2xlcmFudCAmJiByZWxhdGl2ZS5zY2hlbWUpIHtcblx0XHR0YXJnZXQuc2NoZW1lID0gcmVsYXRpdmUuc2NoZW1lO1xuXHRcdC8vdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcblx0XHR0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcblx0XHR0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XG5cdFx0dGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuXHRcdHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcblx0XHR0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcblx0fSBlbHNlIHtcblx0XHRpZiAocmVsYXRpdmUudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG5cdFx0XHR0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcblx0XHRcdHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdDtcblx0XHRcdHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcblx0XHRcdHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcblx0XHRcdHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIXJlbGF0aXZlLnBhdGgpIHtcblx0XHRcdFx0dGFyZ2V0LnBhdGggPSBiYXNlLnBhdGg7XG5cdFx0XHRcdGlmIChyZWxhdGl2ZS5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0LnF1ZXJ5ID0gYmFzZS5xdWVyeTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHJlbGF0aXZlLnBhdGguY2hhckF0KDApID09PSBcIi9cIikge1xuXHRcdFx0XHRcdHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKChiYXNlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgYmFzZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgYmFzZS5wb3J0ICE9PSB1bmRlZmluZWQpICYmICFiYXNlLnBhdGgpIHtcblx0XHRcdFx0XHRcdHRhcmdldC5wYXRoID0gXCIvXCIgKyByZWxhdGl2ZS5wYXRoO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIWJhc2UucGF0aCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQucGF0aCA9IGJhc2UucGF0aC5zbGljZSgwLCBiYXNlLnBhdGgubGFzdEluZGV4T2YoXCIvXCIpICsgMSkgKyByZWxhdGl2ZS5wYXRoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHRhcmdldC5wYXRoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcblx0XHRcdH1cblx0XHRcdC8vdGFyZ2V0LmF1dGhvcml0eSA9IGJhc2UuYXV0aG9yaXR5O1xuXHRcdFx0dGFyZ2V0LnVzZXJpbmZvID0gYmFzZS51c2VyaW5mbztcblx0XHRcdHRhcmdldC5ob3N0ID0gYmFzZS5ob3N0O1xuXHRcdFx0dGFyZ2V0LnBvcnQgPSBiYXNlLnBvcnQ7XG5cdFx0fVxuXHRcdHRhcmdldC5zY2hlbWUgPSBiYXNlLnNjaGVtZTtcblx0fVxuXG5cdHRhcmdldC5mcmFnbWVudCA9IHJlbGF0aXZlLmZyYWdtZW50O1xuXG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZShiYXNlVVJJOnN0cmluZywgcmVsYXRpdmVVUkk6c3RyaW5nLCBvcHRpb25zPzpVUklPcHRpb25zKTpzdHJpbmcge1xuXHRjb25zdCBzY2hlbWVsZXNzT3B0aW9ucyA9IGFzc2lnbih7IHNjaGVtZSA6ICdudWxsJyB9LCBvcHRpb25zKTtcblx0cmV0dXJuIHNlcmlhbGl6ZShyZXNvbHZlQ29tcG9uZW50cyhwYXJzZShiYXNlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHBhcnNlKHJlbGF0aXZlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHNjaGVtZWxlc3NPcHRpb25zLCB0cnVlKSwgc2NoZW1lbGVzc09wdGlvbnMpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZSh1cmk6c3RyaW5nLCBvcHRpb25zPzpVUklPcHRpb25zKTpzdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHVyaTpVUklDb21wb25lbnRzLCBvcHRpb25zPzpVUklPcHRpb25zKTpVUklDb21wb25lbnRzO1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZSh1cmk6YW55LCBvcHRpb25zPzpVUklPcHRpb25zKTphbnkge1xuXHRpZiAodHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHVyaSA9IHNlcmlhbGl6ZShwYXJzZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcblx0fSBlbHNlIGlmICh0eXBlT2YodXJpKSA9PT0gXCJvYmplY3RcIikge1xuXHRcdHVyaSA9IHBhcnNlKHNlcmlhbGl6ZSg8VVJJQ29tcG9uZW50cz51cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcblx0fVxuXG5cdHJldHVybiB1cmk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWwodXJpQTpzdHJpbmcsIHVyaUI6c3RyaW5nLCBvcHRpb25zPzogVVJJT3B0aW9ucyk6Ym9vbGVhbjtcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbCh1cmlBOlVSSUNvbXBvbmVudHMsIHVyaUI6VVJJQ29tcG9uZW50cywgb3B0aW9ucz86VVJJT3B0aW9ucyk6Ym9vbGVhbjtcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbCh1cmlBOmFueSwgdXJpQjphbnksIG9wdGlvbnM/OlVSSU9wdGlvbnMpOmJvb2xlYW4ge1xuXHRpZiAodHlwZW9mIHVyaUEgPT09IFwic3RyaW5nXCIpIHtcblx0XHR1cmlBID0gc2VyaWFsaXplKHBhcnNlKHVyaUEsIG9wdGlvbnMpLCBvcHRpb25zKTtcblx0fSBlbHNlIGlmICh0eXBlT2YodXJpQSkgPT09IFwib2JqZWN0XCIpIHtcblx0XHR1cmlBID0gc2VyaWFsaXplKDxVUklDb21wb25lbnRzPnVyaUEsIG9wdGlvbnMpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiB1cmlCID09PSBcInN0cmluZ1wiKSB7XG5cdFx0dXJpQiA9IHNlcmlhbGl6ZShwYXJzZSh1cmlCLCBvcHRpb25zKSwgb3B0aW9ucyk7XG5cdH0gZWxzZSBpZiAodHlwZU9mKHVyaUIpID09PSBcIm9iamVjdFwiKSB7XG5cdFx0dXJpQiA9IHNlcmlhbGl6ZSg8VVJJQ29tcG9uZW50cz51cmlCLCBvcHRpb25zKTtcblx0fVxuXG5cdHJldHVybiB1cmlBID09PSB1cmlCO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUNvbXBvbmVudChzdHI6c3RyaW5nLCBvcHRpb25zPzpVUklPcHRpb25zKTpzdHJpbmcge1xuXHRyZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoKCFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5FU0NBUEUgOiBJUklfUFJPVE9DT0wuRVNDQVBFKSwgcGN0RW5jQ2hhcik7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdW5lc2NhcGVDb21wb25lbnQoc3RyOnN0cmluZywgb3B0aW9ucz86VVJJT3B0aW9ucyk6c3RyaW5nIHtcblx0cmV0dXJuIHN0ciAmJiBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKCghb3B0aW9ucyB8fCAhb3B0aW9ucy5pcmkgPyBVUklfUFJPVE9DT0wuUENUX0VOQ09ERUQgOiBJUklfUFJPVE9DT0wuUENUX0VOQ09ERUQpLCBwY3REZWNDaGFycyk7XG59O1xuIiwiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcblxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyID0ge1xuXHRzY2hlbWUgOiBcImh0dHBcIixcblxuXHRkb21haW5Ib3N0IDogdHJ1ZSxcblxuXHRwYXJzZSA6IGZ1bmN0aW9uIChjb21wb25lbnRzOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyk6VVJJQ29tcG9uZW50cyB7XG5cdFx0Ly9yZXBvcnQgbWlzc2luZyBob3N0XG5cdFx0aWYgKCFjb21wb25lbnRzLmhvc3QpIHtcblx0XHRcdGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH0sXG5cblx0c2VyaWFsaXplIDogZnVuY3Rpb24gKGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpVUklDb21wb25lbnRzIHtcblx0XHQvL25vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG5cdFx0aWYgKGNvbXBvbmVudHMucG9ydCA9PT0gKFN0cmluZyhjb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSAhPT0gXCJodHRwc1wiID8gODAgOiA0NDMpIHx8IGNvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuXHRcdFx0Y29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRcblx0XHQvL25vcm1hbGl6ZSB0aGUgZW1wdHkgcGF0aFxuXHRcdGlmICghY29tcG9uZW50cy5wYXRoKSB7XG5cdFx0XHRjb21wb25lbnRzLnBhdGggPSBcIi9cIjtcblx0XHR9XG5cblx0XHQvL05PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcblx0XHQvL2FzIFdXVyBGb3JtIFVybCBFbmNvZGVkIHF1ZXJ5IHN0cmluZ3MgYXJlIHBhcnQgb2YgdGhlIEhUTUw0KyBzcGVjLFxuXHRcdC8vYW5kIG5vdCB0aGUgSFRUUCBzcGVjLlxuXG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGhhbmRsZXI7IiwiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcbmltcG9ydCBodHRwIGZyb20gXCIuL2h0dHBcIjtcblxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyID0ge1xuXHRzY2hlbWUgOiBcImh0dHBzXCIsXG5cdGRvbWFpbkhvc3QgOiBodHRwLmRvbWFpbkhvc3QsXG5cdHBhcnNlIDogaHR0cC5wYXJzZSxcblx0c2VyaWFsaXplIDogaHR0cC5zZXJpYWxpemVcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiLCJpbXBvcnQgeyBVUklTY2hlbWVIYW5kbGVyLCBVUklDb21wb25lbnRzLCBVUklPcHRpb25zIH0gZnJvbSBcIi4uL3VyaVwiO1xuaW1wb3J0IHsgcGN0RW5jQ2hhciwgcGN0RGVjQ2hhcnMsIHVuZXNjYXBlQ29tcG9uZW50IH0gZnJvbSBcIi4uL3VyaVwiO1xuaW1wb3J0IHB1bnljb2RlIGZyb20gXCJwdW55Y29kZVwiO1xuaW1wb3J0IHsgbWVyZ2UsIHN1YmV4cCwgdG9VcHBlckNhc2UsIHRvQXJyYXkgfSBmcm9tIFwiLi4vdXRpbFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1haWx0b0hlYWRlcnMge1xuXHRbaGZuYW1lOnN0cmluZ106c3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFpbHRvQ29tcG9uZW50cyBleHRlbmRzIFVSSUNvbXBvbmVudHMge1xuXHR0bzpBcnJheTxzdHJpbmc+LFxuXHRoZWFkZXJzPzpNYWlsdG9IZWFkZXJzLFxuXHRzdWJqZWN0PzpzdHJpbmcsXG5cdGJvZHk/OnN0cmluZ1xufVxuXG5jb25zdCBPOk1haWx0b0hlYWRlcnMgPSB7fTtcbmNvbnN0IGlzSVJJID0gdHJ1ZTtcblxuLy9SRkMgMzk4NlxuY29uc3QgVU5SRVNFUlZFRCQkID0gXCJbQS1aYS16MC05XFxcXC1cXFxcLlxcXFxfXFxcXH5cIiArIChpc0lSSSA/IFwiXFxcXHhBMC1cXFxcdTIwMERcXFxcdTIwMTAtXFxcXHUyMDI5XFxcXHUyMDJGLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXCIgOiBcIlwiKSArIFwiXVwiO1xuY29uc3QgSEVYRElHJCQgPSBcIlswLTlBLUZhLWZdXCI7ICAvL2Nhc2UtaW5zZW5zaXRpdmVcbmNvbnN0IFBDVF9FTkNPREVEJCA9IHN1YmV4cChzdWJleHAoXCIlW0VGZWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVbODlBLUZhLWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpKTsgIC8vZXhwYW5kZWRcblxuLy9SRkMgNTMyMiwgZXhjZXB0IHRoZXNlIHN5bWJvbHMgYXMgcGVyIFJGQyA2MDY4OiBAIDogLyA/ICMgWyBdICYgOyA9XG4vL2NvbnN0IEFURVhUJCQgPSBcIltBLVphLXowLTlcXFxcIVxcXFwjXFxcXCRcXFxcJVxcXFwmXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcL1xcXFw9XFxcXD9cXFxcXlxcXFxfXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl1cIjtcbi8vY29uc3QgV1NQJCQgPSBcIltcXFxceDIwXFxcXHgwOV1cIjtcbi8vY29uc3QgT0JTX1FURVhUJCQgPSBcIltcXFxceDAxLVxcXFx4MDhcXFxceDBCXFxcXHgwQ1xcXFx4MEUtXFxcXHgxRlxcXFx4N0ZdXCI7ICAvLyglZDEtOCAvICVkMTEtMTIgLyAlZDE0LTMxIC8gJWQxMjcpXG4vL2NvbnN0IFFURVhUJCQgPSBtZXJnZShcIltcXFxceDIxXFxcXHgyMy1cXFxceDVCXFxcXHg1RC1cXFxceDdFXVwiLCBPQlNfUVRFWFQkJCk7ICAvLyVkMzMgLyAlZDM1LTkxIC8gJWQ5My0xMjYgLyBvYnMtcXRleHRcbi8vY29uc3QgVkNIQVIkJCA9IFwiW1xcXFx4MjEtXFxcXHg3RV1cIjtcbi8vY29uc3QgV1NQJCQgPSBcIltcXFxceDIwXFxcXHgwOV1cIjtcbi8vY29uc3QgT0JTX1FQJCA9IHN1YmV4cChcIlxcXFxcXFxcXCIgKyBtZXJnZShcIltcXFxceDAwXFxcXHgwRFxcXFx4MEFdXCIsIE9CU19RVEVYVCQkKSk7ICAvLyVkMCAvIENSIC8gTEYgLyBvYnMtcXRleHRcbi8vY29uc3QgRldTJCA9IHN1YmV4cChzdWJleHAoV1NQJCQgKyBcIipcIiArIFwiXFxcXHgwRFxcXFx4MEFcIikgKyBcIj9cIiArIFdTUCQkICsgXCIrXCIpO1xuLy9jb25zdCBRVU9URURfUEFJUiQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXFxcXFxcIiArIHN1YmV4cChWQ0hBUiQkICsgXCJ8XCIgKyBXU1AkJCkpICsgXCJ8XCIgKyBPQlNfUVAkKTtcbi8vY29uc3QgUVVPVEVEX1NUUklORyQgPSBzdWJleHAoJ1xcXFxcIicgKyBzdWJleHAoRldTJCArIFwiP1wiICsgUUNPTlRFTlQkKSArIFwiKlwiICsgRldTJCArIFwiP1wiICsgJ1xcXFxcIicpO1xuY29uc3QgQVRFWFQkJCA9IFwiW0EtWmEtejAtOVxcXFwhXFxcXCRcXFxcJVxcXFwnXFxcXCpcXFxcK1xcXFwtXFxcXF5cXFxcX1xcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dXCI7XG5jb25zdCBRVEVYVCQkID0gXCJbXFxcXCFcXFxcJFxcXFwlXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXC1cXFxcLjAtOVxcXFw8XFxcXD5BLVpcXFxceDVFLVxcXFx4N0VdXCI7XG5jb25zdCBWQ0hBUiQkID0gbWVyZ2UoUVRFWFQkJCwgXCJbXFxcXFxcXCJcXFxcXFxcXF1cIik7XG5jb25zdCBET1RfQVRPTV9URVhUJCA9IHN1YmV4cChBVEVYVCQkICsgXCIrXCIgKyBzdWJleHAoXCJcXFxcLlwiICsgQVRFWFQkJCArIFwiK1wiKSArIFwiKlwiKTtcbmNvbnN0IFFVT1RFRF9QQUlSJCA9IHN1YmV4cChcIlxcXFxcXFxcXCIgKyBWQ0hBUiQkKTtcbmNvbnN0IFFDT05URU5UJCA9IHN1YmV4cChRVEVYVCQkICsgXCJ8XCIgKyBRVU9URURfUEFJUiQpO1xuY29uc3QgUVVPVEVEX1NUUklORyQgPSBzdWJleHAoJ1xcXFxcIicgKyBRQ09OVEVOVCQgKyBcIipcIiArICdcXFxcXCInKTtcblxuLy9SRkMgNjA2OFxuY29uc3QgRFRFWFRfTk9fT0JTJCQgPSBcIltcXFxceDIxLVxcXFx4NUFcXFxceDVFLVxcXFx4N0VdXCI7ICAvLyVkMzMtOTAgLyAlZDk0LTEyNlxuY29uc3QgU09NRV9ERUxJTVMkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw6XFxcXEBdXCI7XG5jb25zdCBRQ0hBUiQgPSBzdWJleHAoVU5SRVNFUlZFRCQkICsgXCJ8XCIgKyBQQ1RfRU5DT0RFRCQgKyBcInxcIiArIFNPTUVfREVMSU1TJCQpO1xuY29uc3QgRE9NQUlOJCA9IHN1YmV4cChET1RfQVRPTV9URVhUJCArIFwifFwiICsgXCJcXFxcW1wiICsgRFRFWFRfTk9fT0JTJCQgKyBcIipcIiArIFwiXFxcXF1cIik7XG5jb25zdCBMT0NBTF9QQVJUJCA9IHN1YmV4cChET1RfQVRPTV9URVhUJCArIFwifFwiICsgUVVPVEVEX1NUUklORyQpO1xuY29uc3QgQUREUl9TUEVDJCA9IHN1YmV4cChMT0NBTF9QQVJUJCArIFwiXFxcXEBcIiArIERPTUFJTiQpO1xuY29uc3QgVE8kID0gc3ViZXhwKEFERFJfU1BFQyQgKyBzdWJleHAoXCJcXFxcLFwiICsgQUREUl9TUEVDJCkgKyBcIipcIik7XG5jb25zdCBIRk5BTUUkID0gc3ViZXhwKFFDSEFSJCArIFwiKlwiKTtcbmNvbnN0IEhGVkFMVUUkID0gSEZOQU1FJDtcbmNvbnN0IEhGSUVMRCQgPSBzdWJleHAoSEZOQU1FJCArIFwiXFxcXD1cIiArIEhGVkFMVUUkKTtcbmNvbnN0IEhGSUVMRFMyJCA9IHN1YmV4cChIRklFTEQkICsgc3ViZXhwKFwiXFxcXCZcIiArIEhGSUVMRCQpICsgXCIqXCIpO1xuY29uc3QgSEZJRUxEUyQgPSBzdWJleHAoXCJcXFxcP1wiICsgSEZJRUxEUzIkKTtcbmNvbnN0IE1BSUxUT19VUkkgPSBuZXcgUmVnRXhwKFwiXm1haWx0b1xcXFw6XCIgKyBUTyQgKyBcIj9cIiArIEhGSUVMRFMkICsgXCI/JFwiKTtcblxuY29uc3QgVU5SRVNFUlZFRCA9IG5ldyBSZWdFeHAoVU5SRVNFUlZFRCQkLCBcImdcIik7XG5jb25zdCBQQ1RfRU5DT0RFRCA9IG5ldyBSZWdFeHAoUENUX0VOQ09ERUQkLCBcImdcIik7XG5jb25zdCBOT1RfTE9DQUxfUEFSVCA9IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgQVRFWFQkJCwgXCJbXFxcXC5dXCIsICdbXFxcXFwiXScsIFZDSEFSJCQpLCBcImdcIik7XG5jb25zdCBOT1RfRE9NQUlOID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBVEVYVCQkLCBcIltcXFxcLl1cIiwgXCJbXFxcXFtdXCIsIERURVhUX05PX09CUyQkLCBcIltcXFxcXV1cIiksIFwiZ1wiKTtcbmNvbnN0IE5PVF9IRk5BTUUgPSBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIFVOUkVTRVJWRUQkJCwgU09NRV9ERUxJTVMkJCksIFwiZ1wiKTtcbmNvbnN0IE5PVF9IRlZBTFVFID0gTk9UX0hGTkFNRTtcbmNvbnN0IFRPID0gbmV3IFJlZ0V4cChcIl5cIiArIFRPJCArIFwiJFwiKTtcbmNvbnN0IEhGSUVMRFMgPSBuZXcgUmVnRXhwKFwiXlwiICsgSEZJRUxEUzIkICsgXCIkXCIpO1xuXG5mdW5jdGlvbiBkZWNvZGVVbnJlc2VydmVkKHN0cjpzdHJpbmcpOnN0cmluZyB7XG5cdGNvbnN0IGRlY1N0ciA9IHBjdERlY0NoYXJzKHN0cik7XG5cdHJldHVybiAoIWRlY1N0ci5tYXRjaChVTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cik7XG59XG5cbmNvbnN0IGhhbmRsZXI6VVJJU2NoZW1lSGFuZGxlcjxNYWlsdG9Db21wb25lbnRzPiA9ICB7XG5cdHNjaGVtZSA6IFwibWFpbHRvXCIsXG5cblx0cGFyc2UgOiBmdW5jdGlvbiAoY29tcG9uZW50czpVUklDb21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMpOk1haWx0b0NvbXBvbmVudHMge1xuXHRcdGNvbnN0IG1haWx0b0NvbXBvbmVudHMgPSBjb21wb25lbnRzIGFzIE1haWx0b0NvbXBvbmVudHM7XG5cdFx0Y29uc3QgdG8gPSBtYWlsdG9Db21wb25lbnRzLnRvID0gKG1haWx0b0NvbXBvbmVudHMucGF0aCA/IG1haWx0b0NvbXBvbmVudHMucGF0aC5zcGxpdChcIixcIikgOiBbXSk7XG5cdFx0bWFpbHRvQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuXG5cdFx0aWYgKG1haWx0b0NvbXBvbmVudHMucXVlcnkpIHtcblx0XHRcdGxldCB1bmtub3duSGVhZGVycyA9IGZhbHNlXG5cdFx0XHRjb25zdCBoZWFkZXJzOk1haWx0b0hlYWRlcnMgPSB7fTtcblx0XHRcdGNvbnN0IGhmaWVsZHMgPSBtYWlsdG9Db21wb25lbnRzLnF1ZXJ5LnNwbGl0KFwiJlwiKTtcblxuXHRcdFx0Zm9yIChsZXQgeCA9IDAsIHhsID0gaGZpZWxkcy5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG5cdFx0XHRcdGNvbnN0IGhmaWVsZCA9IGhmaWVsZHNbeF0uc3BsaXQoXCI9XCIpO1xuXG5cdFx0XHRcdHN3aXRjaCAoaGZpZWxkWzBdKSB7XG5cdFx0XHRcdFx0Y2FzZSBcInRvXCI6XG5cdFx0XHRcdFx0XHRjb25zdCB0b0FkZHJzID0gaGZpZWxkWzFdLnNwbGl0KFwiLFwiKTtcblx0XHRcdFx0XHRcdGZvciAobGV0IHggPSAwLCB4bCA9IHRvQWRkcnMubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuXHRcdFx0XHRcdFx0XHR0by5wdXNoKHRvQWRkcnNbeF0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcInN1YmplY3RcIjpcblx0XHRcdFx0XHRcdG1haWx0b0NvbXBvbmVudHMuc3ViamVjdCA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiYm9keVwiOlxuXHRcdFx0XHRcdFx0bWFpbHRvQ29tcG9uZW50cy5ib2R5ID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHR1bmtub3duSGVhZGVycyA9IHRydWU7XG5cdFx0XHRcdFx0XHRoZWFkZXJzW3VuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFswXSwgb3B0aW9ucyldID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh1bmtub3duSGVhZGVycykgbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzID0gaGVhZGVycztcblx0XHR9XG5cblx0XHRtYWlsdG9Db21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuXG5cdFx0Zm9yIChsZXQgeCA9IDAsIHhsID0gdG8ubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuXHRcdFx0Y29uc3QgYWRkciA9IHRvW3hdLnNwbGl0KFwiQFwiKTtcblxuXHRcdFx0YWRkclswXSA9IHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMF0pO1xuXG5cdFx0XHRpZiAoIW9wdGlvbnMudW5pY29kZVN1cHBvcnQpIHtcblx0XHRcdFx0Ly9jb252ZXJ0IFVuaWNvZGUgSUROIC0+IEFTQ0lJIElETlxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGFkZHJbMV0gPSBwdW55Y29kZS50b0FTQ0lJKHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMV0sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCkpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0bWFpbHRvQ29tcG9uZW50cy5lcnJvciA9IG1haWx0b0NvbXBvbmVudHMuZXJyb3IgfHwgXCJFbWFpbCBhZGRyZXNzJ3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUkgdmlhIHB1bnljb2RlOiBcIiArIGU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFkZHJbMV0gPSB1bmVzY2FwZUNvbXBvbmVudChhZGRyWzFdLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHR0b1t4XSA9IGFkZHIuam9pbihcIkBcIik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1haWx0b0NvbXBvbmVudHM7XG5cdH0sXG5cblx0c2VyaWFsaXplIDogZnVuY3Rpb24gKG1haWx0b0NvbXBvbmVudHM6TWFpbHRvQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpVUklDb21wb25lbnRzIHtcblx0XHRjb25zdCBjb21wb25lbnRzID0gbWFpbHRvQ29tcG9uZW50cyBhcyBVUklDb21wb25lbnRzO1xuXHRcdGNvbnN0IHRvID0gdG9BcnJheShtYWlsdG9Db21wb25lbnRzLnRvKTtcblx0XHRpZiAodG8pIHtcblx0XHRcdGZvciAobGV0IHggPSAwLCB4bCA9IHRvLmxlbmd0aDsgeCA8IHhsOyArK3gpIHtcblx0XHRcdFx0Y29uc3QgdG9BZGRyID0gU3RyaW5nKHRvW3hdKTtcblx0XHRcdFx0Y29uc3QgYXRJZHggPSB0b0FkZHIubGFzdEluZGV4T2YoXCJAXCIpO1xuXHRcdFx0XHRjb25zdCBsb2NhbFBhcnQgPSAodG9BZGRyLnNsaWNlKDAsIGF0SWR4KSkucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0xPQ0FMX1BBUlQsIHBjdEVuY0NoYXIpO1xuXHRcdFx0XHRsZXQgZG9tYWluID0gdG9BZGRyLnNsaWNlKGF0SWR4ICsgMSk7XG5cblx0XHRcdFx0Ly9jb252ZXJ0IElETiB2aWEgcHVueWNvZGVcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRkb21haW4gPSAoIW9wdGlvbnMuaXJpID8gcHVueWNvZGUudG9BU0NJSSh1bmVzY2FwZUNvbXBvbmVudChkb21haW4sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCkpIDogcHVueWNvZGUudG9Vbmljb2RlKGRvbWFpbikpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJFbWFpbCBhZGRyZXNzJ3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0b1t4XSA9IGxvY2FsUGFydCArIFwiQFwiICsgZG9tYWluO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wb25lbnRzLnBhdGggPSB0by5qb2luKFwiLFwiKTtcblx0XHR9XG5cblx0XHRjb25zdCBoZWFkZXJzID0gbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzID0gbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzIHx8IHt9O1xuXG5cdFx0aWYgKG1haWx0b0NvbXBvbmVudHMuc3ViamVjdCkgaGVhZGVyc1tcInN1YmplY3RcIl0gPSBtYWlsdG9Db21wb25lbnRzLnN1YmplY3Q7XG5cdFx0aWYgKG1haWx0b0NvbXBvbmVudHMuYm9keSkgaGVhZGVyc1tcImJvZHlcIl0gPSBtYWlsdG9Db21wb25lbnRzLmJvZHk7XG5cblx0XHRjb25zdCBmaWVsZHMgPSBbXTtcblx0XHRmb3IgKGNvbnN0IG5hbWUgaW4gaGVhZGVycykge1xuXHRcdFx0aWYgKGhlYWRlcnNbbmFtZV0gIT09IE9bbmFtZV0pIHtcblx0XHRcdFx0ZmllbGRzLnB1c2goXG5cdFx0XHRcdFx0bmFtZS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfSEZOQU1FLCBwY3RFbmNDaGFyKSArXG5cdFx0XHRcdFx0XCI9XCIgK1xuXHRcdFx0XHRcdGhlYWRlcnNbbmFtZV0ucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0hGVkFMVUUsIHBjdEVuY0NoYXIpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChmaWVsZHMubGVuZ3RoKSB7XG5cdFx0XHRjb21wb25lbnRzLnF1ZXJ5ID0gZmllbGRzLmpvaW4oXCImXCIpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wb25lbnRzO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhbmRsZXI7IiwiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcbmltcG9ydCB7IHBjdEVuY0NoYXIsIFNDSEVNRVMgfSBmcm9tIFwiLi4vdXJpXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVVJOQ29tcG9uZW50cyBleHRlbmRzIFVSSUNvbXBvbmVudHMge1xuXHRuaWQ/OnN0cmluZztcblx0bnNzPzpzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVVJOT3B0aW9ucyBleHRlbmRzIFVSSU9wdGlvbnMge1xuXHRuaWQ/OnN0cmluZztcbn1cblxuY29uc3QgTklEJCA9IFwiKD86WzAtOUEtWmEtel1bMC05QS1aYS16XFxcXC1dezEsMzF9KVwiO1xuY29uc3QgUENUX0VOQ09ERUQkID0gXCIoPzpcXFxcJVswLTlBLUZhLWZdezJ9KVwiO1xuY29uc3QgVFJBTlMkJCA9IFwiWzAtOUEtWmEtelxcXFwoXFxcXClcXFxcK1xcXFwsXFxcXC1cXFxcLlxcXFw6XFxcXD1cXFxcQFxcXFw7XFxcXCRcXFxcX1xcXFwhXFxcXCpcXFxcJ1xcXFwvXFxcXD9cXFxcI11cIjtcbmNvbnN0IE5TUyQgPSBcIig/Oig/OlwiICsgUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBUUkFOUyQkICsgXCIpKylcIjtcbmNvbnN0IFVSTl9TQ0hFTUUgPSBuZXcgUmVnRXhwKFwiXnVyblxcXFw6KFwiICsgTklEJCArIFwiKSRcIik7XG5jb25zdCBVUk5fUEFUSCA9IG5ldyBSZWdFeHAoXCJeKFwiICsgTklEJCArIFwiKVxcXFw6KFwiICsgTlNTJCArIFwiKSRcIik7XG5jb25zdCBVUk5fUEFSU0UgPSAvXihbXlxcOl0rKVxcOiguKikvO1xuY29uc3QgVVJOX0VYQ0xVREVEID0gL1tcXHgwMC1cXHgyMFxcXFxcXFwiXFwmXFw8XFw+XFxbXFxdXFxeXFxgXFx7XFx8XFx9XFx+XFx4N0YtXFx4RkZdL2c7XG5cbi8vUkZDIDIxNDFcbmNvbnN0IGhhbmRsZXI6VVJJU2NoZW1lSGFuZGxlcjxVUk5Db21wb25lbnRzLFVSTk9wdGlvbnM+ID0ge1xuXHRzY2hlbWUgOiBcInVyblwiLFxuXG5cdHBhcnNlIDogZnVuY3Rpb24gKGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUk5PcHRpb25zKTpVUk5Db21wb25lbnRzIHtcblx0XHRjb25zdCBtYXRjaGVzID0gY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5tYXRjaChVUk5fUEFSU0UpO1xuXHRcdGxldCB1cm5Db21wb25lbnRzID0gY29tcG9uZW50cyBhcyBVUk5Db21wb25lbnRzO1xuXG5cdFx0aWYgKG1hdGNoZXMpIHtcblx0XHRcdGNvbnN0IHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG5cdFx0XHRjb25zdCBuaWQgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRjb25zdCBuc3MgPSBtYXRjaGVzWzJdO1xuXHRcdFx0Y29uc3QgdXJuU2NoZW1lID0gYCR7c2NoZW1lfToke29wdGlvbnMubmlkIHx8IG5pZH1gO1xuXHRcdFx0Y29uc3Qgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXTtcblxuXHRcdFx0dXJuQ29tcG9uZW50cy5uaWQgPSBuaWQ7XG5cdFx0XHR1cm5Db21wb25lbnRzLm5zcyA9IG5zcztcblx0XHRcdHVybkNvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKHNjaGVtZUhhbmRsZXIpIHtcblx0XHRcdFx0dXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIucGFyc2UodXJuQ29tcG9uZW50cywgb3B0aW9ucykgYXMgVVJOQ29tcG9uZW50cztcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dXJuQ29tcG9uZW50cy5lcnJvciA9IHVybkNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUk4gY2FuIG5vdCBiZSBwYXJzZWQuXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVybkNvbXBvbmVudHM7XG5cdH0sXG5cblx0c2VyaWFsaXplIDogZnVuY3Rpb24gKHVybkNvbXBvbmVudHM6VVJOQ29tcG9uZW50cywgb3B0aW9uczpVUk5PcHRpb25zKTpVUklDb21wb25lbnRzIHtcblx0XHRjb25zdCBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnRzLnNjaGVtZSB8fCBcInVyblwiO1xuXHRcdGNvbnN0IG5pZCA9IHVybkNvbXBvbmVudHMubmlkO1xuXHRcdGNvbnN0IHVyblNjaGVtZSA9IGAke3NjaGVtZX06JHtvcHRpb25zLm5pZCB8fCBuaWR9YDtcblx0XHRjb25zdCBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdO1xuXG5cdFx0aWYgKHNjaGVtZUhhbmRsZXIpIHtcblx0XHRcdHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKSBhcyBVUk5Db21wb25lbnRzO1xuXHRcdH1cblxuXHRcdGNvbnN0IHVyaUNvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzIGFzIFVSSUNvbXBvbmVudHM7XG5cdFx0Y29uc3QgbnNzID0gdXJuQ29tcG9uZW50cy5uc3M7XG5cdFx0dXJpQ29tcG9uZW50cy5wYXRoID0gYCR7bmlkIHx8IG9wdGlvbnMubmlkfToke25zc31gO1xuXG5cdFx0cmV0dXJuIHVyaUNvbXBvbmVudHM7XG5cdH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBoYW5kbGVyOyIsImltcG9ydCB7IFVSSVNjaGVtZUhhbmRsZXIsIFVSSUNvbXBvbmVudHMsIFVSSU9wdGlvbnMgfSBmcm9tIFwiLi4vdXJpXCI7XG5pbXBvcnQgeyBVUk5Db21wb25lbnRzIH0gZnJvbSBcIi4vdXJuXCI7XG5pbXBvcnQgeyBTQ0hFTUVTIH0gZnJvbSBcIi4uL3VyaVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVVSURDb21wb25lbnRzIGV4dGVuZHMgVVJOQ29tcG9uZW50cyB7XG5cdHV1aWQ/OiBzdHJpbmc7XG59XG5cbmNvbnN0IFVVSUQgPSAvXlswLTlBLUZhLWZdezh9KD86XFwtWzAtOUEtRmEtZl17NH0pezN9XFwtWzAtOUEtRmEtZl17MTJ9JC87XG5jb25zdCBVVUlEX1BBUlNFID0gL15bMC05QS1GYS1mXFwtXXszNn0vO1xuXG4vL1JGQyA0MTIyXG5jb25zdCBoYW5kbGVyOlVSSVNjaGVtZUhhbmRsZXI8VVVJRENvbXBvbmVudHMsIFVSSU9wdGlvbnMsIFVSTkNvbXBvbmVudHM+ID0ge1xuXHRzY2hlbWUgOiBcInVybjp1dWlkXCIsXG5cblx0cGFyc2UgOiBmdW5jdGlvbiAodXJuQ29tcG9uZW50czpVUk5Db21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMpOlVVSURDb21wb25lbnRzIHtcblx0XHRjb25zdCB1dWlkQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHMgYXMgVVVJRENvbXBvbmVudHM7XG5cdFx0dXVpZENvbXBvbmVudHMudXVpZCA9IHV1aWRDb21wb25lbnRzLm5zcztcblx0XHR1dWlkQ29tcG9uZW50cy5uc3MgPSB1bmRlZmluZWQ7XG5cblx0XHRpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgKCF1dWlkQ29tcG9uZW50cy51dWlkIHx8ICF1dWlkQ29tcG9uZW50cy51dWlkLm1hdGNoKFVVSUQpKSkge1xuXHRcdFx0dXVpZENvbXBvbmVudHMuZXJyb3IgPSB1dWlkQ29tcG9uZW50cy5lcnJvciB8fCBcIlVVSUQgaXMgbm90IHZhbGlkLlwiO1xuXHRcdH1cblxuXHRcdHJldHVybiB1dWlkQ29tcG9uZW50cztcblx0fSxcblxuXHRzZXJpYWxpemUgOiBmdW5jdGlvbiAodXVpZENvbXBvbmVudHM6VVVJRENvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyk6VVJOQ29tcG9uZW50cyB7XG5cdFx0Y29uc3QgdXJuQ29tcG9uZW50cyA9IHV1aWRDb21wb25lbnRzIGFzIFVSTkNvbXBvbmVudHM7XG5cdFx0Ly9ub3JtYWxpemUgVVVJRFxuXHRcdHVybkNvbXBvbmVudHMubnNzID0gKHV1aWRDb21wb25lbnRzLnV1aWQgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gdXJuQ29tcG9uZW50cztcblx0fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGhhbmRsZXI7IiwiaW1wb3J0IHsgU0NIRU1FUyB9IGZyb20gXCIuL3VyaVwiO1xuXG5pbXBvcnQgaHR0cCBmcm9tIFwiLi9zY2hlbWVzL2h0dHBcIjtcblNDSEVNRVNbaHR0cC5zY2hlbWVdID0gaHR0cDtcblxuaW1wb3J0IGh0dHBzIGZyb20gXCIuL3NjaGVtZXMvaHR0cHNcIjtcblNDSEVNRVNbaHR0cHMuc2NoZW1lXSA9IGh0dHBzO1xuXG5pbXBvcnQgbWFpbHRvIGZyb20gXCIuL3NjaGVtZXMvbWFpbHRvXCI7XG5TQ0hFTUVTW21haWx0by5zY2hlbWVdID0gbWFpbHRvO1xuXG5pbXBvcnQgdXJuIGZyb20gXCIuL3NjaGVtZXMvdXJuXCI7XG5TQ0hFTUVTW3Vybi5zY2hlbWVdID0gdXJuO1xuXG5pbXBvcnQgdXVpZCBmcm9tIFwiLi9zY2hlbWVzL3Vybi11dWlkXCI7XG5TQ0hFTUVTW3V1aWQuc2NoZW1lXSA9IHV1aWQ7XG5cbmV4cG9ydCAqIGZyb20gXCIuL3VyaVwiO1xuIiwiLyogZ2xvYmFscyBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXyAqL1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsIi8vIC5kaXJuYW1lLCAuYmFzZW5hbWUsIGFuZCAuZXh0bmFtZSBtZXRob2RzIGFyZSBleHRyYWN0ZWQgZnJvbSBOb2RlLmpzIHY4LjExLjEsXG4vLyBiYWNrcG9ydGVkIGFuZCB0cmFuc3BsaXRlZCB3aXRoIEJhYmVsLCB3aXRoIGJhY2t3YXJkcy1jb21wYXQgZml4ZXNcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgdmFyIGhhc1Jvb3QgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHtcbiAgICAvLyByZXR1cm4gJy8vJztcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGZpeDpcbiAgICByZXR1cm4gJy8nO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG5cbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5cbi8vIFVzZXMgYSBtaXhlZCBhcHByb2FjaCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIGFzIGV4dCBiZWhhdmlvciBjaGFuZ2VkXG4vLyBpbiBuZXcgTm9kZS5qcyB2ZXJzaW9ucywgc28gb25seSBiYXNlbmFtZSgpIGFib3ZlIGlzIGJhY2twb3J0ZWQgaGVyZVxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uIChwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBiYXNlbmFtZShwYXRoKTtcbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIHZhciBzdGFydERvdCA9IC0xO1xuICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iXSwic291cmNlUm9vdCI6IiJ9